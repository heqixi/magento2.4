require.config({"config": {
        "jsbuild":{"Magezon_Builder/vendor/angular/angular.min.js":"/*\n AngularJS v1.7.5\n (c) 2010-2018 Google, Inc. http://angularjs.org\n License: MIT\n*/\n(function(B){'use strict';function oe(a){if(F(a))v(a.objectMaxDepth)&&(Vb.objectMaxDepth=Wb(a.objectMaxDepth)?a.objectMaxDepth:NaN),v(a.urlErrorParamsEnabled)&&Fa(a.urlErrorParamsEnabled)&&(Vb.urlErrorParamsEnabled=a.urlErrorParamsEnabled);else return Vb}function Wb(a){return ba(a)&&0<a}function M(a,b){b=b||Error;return function(){var d=arguments[0],c;c=\"[\"+(a?a+\":\":\"\")+d+\"] http://errors.angularjs.org/1.7.5/\"+(a?a+\"/\":\"\")+d;for(d=1;d<arguments.length;d++){c=c+(1==d?\"?\":\"&\")+\"p\"+(d-1)+\"=\";var e=encodeURIComponent,\nf;f=arguments[d];f=\"function\"==typeof f?f.toString().replace(/ \\{[\\s\\S]*$/,\"\"):\"undefined\"==typeof f?\"undefined\":\"string\"!=typeof f?JSON.stringify(f):f;c+=e(f)}return new b(c)}}function xa(a){if(null==a||$a(a))return!1;if(I(a)||C(a)||y&&a instanceof y)return!0;var b=\"length\"in Object(a)&&a.length;return ba(b)&&(0<=b&&b-1 in a||\"function\"===typeof a.item)}function r(a,b,d){var c,e;if(a)if(z(a))for(c in a)\"prototype\"!==c&&\"length\"!==c&&\"name\"!==c&&a.hasOwnProperty(c)&&b.call(d,a[c],c,a);else if(I(a)||\nxa(a)){var f=\"object\"!==typeof a;c=0;for(e=a.length;c<e;c++)(f||c in a)&&b.call(d,a[c],c,a)}else if(a.forEach&&a.forEach!==r)a.forEach(b,d,a);else if(Mc(a))for(c in a)b.call(d,a[c],c,a);else if(\"function\"===typeof a.hasOwnProperty)for(c in a)a.hasOwnProperty(c)&&b.call(d,a[c],c,a);else for(c in a)sa.call(a,c)&&b.call(d,a[c],c,a);return a}function Nc(a,b,d){for(var c=Object.keys(a).sort(),e=0;e<c.length;e++)b.call(d,a[c[e]],c[e]);return c}function Xb(a){return function(b,d){a(d,b)}}function pe(){return++pb}\nfunction Yb(a,b,d){for(var c=a.$$hashKey,e=0,f=b.length;e<f;++e){var g=b[e];if(F(g)||z(g))for(var k=Object.keys(g),h=0,l=k.length;h<l;h++){var m=k[h],q=g[m];d&&F(q)?ha(q)?a[m]=new Date(q.valueOf()):ab(q)?a[m]=new RegExp(q):q.nodeName?a[m]=q.cloneNode(!0):Zb(q)?a[m]=q.clone():(F(a[m])||(a[m]=I(q)?[]:{}),Yb(a[m],[q],!0)):a[m]=q}}c?a.$$hashKey=c:delete a.$$hashKey;return a}function R(a){return Yb(a,Ga.call(arguments,1),!1)}function qe(a){return Yb(a,Ga.call(arguments,1),!0)}function da(a){return parseInt(a,\n10)}function $b(a,b){return R(Object.create(a),b)}function A(){}function Ta(a){return a}function ia(a){return function(){return a}}function ac(a){return z(a.toString)&&a.toString!==ma}function x(a){return\"undefined\"===typeof a}function v(a){return\"undefined\"!==typeof a}function F(a){return null!==a&&\"object\"===typeof a}function Mc(a){return null!==a&&\"object\"===typeof a&&!Oc(a)}function C(a){return\"string\"===typeof a}function ba(a){return\"number\"===typeof a}function ha(a){return\"[object Date]\"===\nma.call(a)}function I(a){return Array.isArray(a)||a instanceof Array}function bc(a){switch(ma.call(a)){case \"[object Error]\":return!0;case \"[object Exception]\":return!0;case \"[object DOMException]\":return!0;default:return a instanceof Error}}function z(a){return\"function\"===typeof a}function ab(a){return\"[object RegExp]\"===ma.call(a)}function $a(a){return a&&a.window===a}function bb(a){return a&&a.$evalAsync&&a.$watch}function Fa(a){return\"boolean\"===typeof a}function re(a){return a&&ba(a.length)&&\nse.test(ma.call(a))}function Zb(a){return!(!a||!(a.nodeName||a.prop&&a.attr&&a.find))}function te(a){var b={};a=a.split(\",\");var d;for(d=0;d<a.length;d++)b[a[d]]=!0;return b}function ta(a){return O(a.nodeName||a[0]&&a[0].nodeName)}function cb(a,b){var d=a.indexOf(b);0<=d&&a.splice(d,1);return d}function Ha(a,b,d){function c(a,b,c){c--;if(0>c)return\"...\";var d=b.$$hashKey,f;if(I(a)){f=0;for(var g=a.length;f<g;f++)b.push(e(a[f],c))}else if(Mc(a))for(f in a)b[f]=e(a[f],c);else if(a&&\"function\"===typeof a.hasOwnProperty)for(f in a)a.hasOwnProperty(f)&&\n(b[f]=e(a[f],c));else for(f in a)sa.call(a,f)&&(b[f]=e(a[f],c));d?b.$$hashKey=d:delete b.$$hashKey;return b}function e(a,b){if(!F(a))return a;var d=g.indexOf(a);if(-1!==d)return k[d];if($a(a)||bb(a))throw Ia(\"cpws\");var d=!1,e=f(a);void 0===e&&(e=I(a)?[]:Object.create(Oc(a)),d=!0);g.push(a);k.push(e);return d?c(a,e,b):e}function f(a){switch(ma.call(a)){case \"[object Int8Array]\":case \"[object Int16Array]\":case \"[object Int32Array]\":case \"[object Float32Array]\":case \"[object Float64Array]\":case \"[object Uint8Array]\":case \"[object Uint8ClampedArray]\":case \"[object Uint16Array]\":case \"[object Uint32Array]\":return new a.constructor(e(a.buffer),\na.byteOffset,a.length);case \"[object ArrayBuffer]\":if(!a.slice){var b=new ArrayBuffer(a.byteLength);(new Uint8Array(b)).set(new Uint8Array(a));return b}return a.slice(0);case \"[object Boolean]\":case \"[object Number]\":case \"[object String]\":case \"[object Date]\":return new a.constructor(a.valueOf());case \"[object RegExp]\":return b=new RegExp(a.source,a.toString().match(/[^/]*$/)[0]),b.lastIndex=a.lastIndex,b;case \"[object Blob]\":return new a.constructor([a],{type:a.type})}if(z(a.cloneNode))return a.cloneNode(!0)}\nvar g=[],k=[];d=Wb(d)?d:NaN;if(b){if(re(b)||\"[object ArrayBuffer]\"===ma.call(b))throw Ia(\"cpta\");if(a===b)throw Ia(\"cpi\");I(b)?b.length=0:r(b,function(a,c){\"$$hashKey\"!==c&&delete b[c]});g.push(a);k.push(b);return c(a,b,d)}return e(a,d)}function cc(a,b){return a===b||a!==a&&b!==b}function ua(a,b){if(a===b)return!0;if(null===a||null===b)return!1;if(a!==a&&b!==b)return!0;var d=typeof a,c;if(d===typeof b&&\"object\"===d)if(I(a)){if(!I(b))return!1;if((d=a.length)===b.length){for(c=0;c<d;c++)if(!ua(a[c],\nb[c]))return!1;return!0}}else{if(ha(a))return ha(b)?cc(a.getTime(),b.getTime()):!1;if(ab(a))return ab(b)?a.toString()===b.toString():!1;if(bb(a)||bb(b)||$a(a)||$a(b)||I(b)||ha(b)||ab(b))return!1;d=S();for(c in a)if(\"$\"!==c.charAt(0)&&!z(a[c])){if(!ua(a[c],b[c]))return!1;d[c]=!0}for(c in b)if(!(c in d)&&\"$\"!==c.charAt(0)&&v(b[c])&&!z(b[c]))return!1;return!0}return!1}function db(a,b,d){return a.concat(Ga.call(b,d))}function Va(a,b){var d=2<arguments.length?Ga.call(arguments,2):[];return!z(b)||b instanceof\nRegExp?b:d.length?function(){return arguments.length?b.apply(a,db(d,arguments,0)):b.apply(a,d)}:function(){return arguments.length?b.apply(a,arguments):b.call(a)}}function Pc(a,b){var d=b;\"string\"===typeof a&&\"$\"===a.charAt(0)&&\"$\"===a.charAt(1)?d=void 0:$a(b)?d=\"$WINDOW\":b&&B.document===b?d=\"$DOCUMENT\":bb(b)&&(d=\"$SCOPE\");return d}function eb(a,b){if(!x(a))return ba(b)||(b=b?2:null),JSON.stringify(a,Pc,b)}function Qc(a){return C(a)?JSON.parse(a):a}function dc(a,b){a=a.replace(ue,\"\");var d=Date.parse(\"Jan 01, 1970 00:00:00 \"+\na)/6E4;return V(d)?b:d}function Rc(a,b){a=new Date(a.getTime());a.setMinutes(a.getMinutes()+b);return a}function ec(a,b,d){d=d?-1:1;var c=a.getTimezoneOffset();b=dc(b,c);return Rc(a,d*(b-c))}function ya(a){a=y(a).clone().empty();var b=y(\"<div></div>\").append(a).html();try{return a[0].nodeType===Oa?O(b):b.match(/^(<[^>]+>)/)[1].replace(/^<([\\w-]+)/,function(a,b){return\"<\"+O(b)})}catch(d){return O(b)}}function Sc(a){try{return decodeURIComponent(a)}catch(b){}}function fc(a){var b={};r((a||\"\").split(\"&\"),\nfunction(a){var c,e,f;a&&(e=a=a.replace(/\\+/g,\"%20\"),c=a.indexOf(\"=\"),-1!==c&&(e=a.substring(0,c),f=a.substring(c+1)),e=Sc(e),v(e)&&(f=v(f)?Sc(f):!0,sa.call(b,e)?I(b[e])?b[e].push(f):b[e]=[b[e],f]:b[e]=f))});return b}function ve(a){var b=[];r(a,function(a,c){I(a)?r(a,function(a){b.push(ca(c,!0)+(!0===a?\"\":\"=\"+ca(a,!0)))}):b.push(ca(c,!0)+(!0===a?\"\":\"=\"+ca(a,!0)))});return b.length?b.join(\"&\"):\"\"}function gc(a){return ca(a,!0).replace(/%26/gi,\"&\").replace(/%3D/gi,\"=\").replace(/%2B/gi,\"+\")}function ca(a,\nb){return encodeURIComponent(a).replace(/%40/gi,\"@\").replace(/%3A/gi,\":\").replace(/%24/g,\"$\").replace(/%2C/gi,\",\").replace(/%3B/gi,\";\").replace(/%20/g,b?\"%20\":\"+\")}function we(a,b){var d,c,e=Pa.length;for(c=0;c<e;++c)if(d=Pa[c]+b,C(d=a.getAttribute(d)))return d;return null}function xe(a,b){var d,c,e={};r(Pa,function(b){b+=\"app\";!d&&a.hasAttribute&&a.hasAttribute(b)&&(d=a,c=a.getAttribute(b))});r(Pa,function(b){b+=\"app\";var e;!d&&(e=a.querySelector(\"[\"+b.replace(\":\",\"\\\\:\")+\"]\"))&&(d=e,c=e.getAttribute(b))});\nif(d)if(ye)e.strictDi=null!==we(d,\"strict-di\"),b(d,c?[c]:[],e);else try{B.console.error(\"AngularJS: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match.\")}catch(f){}}function Tc(a,b,d){F(d)||(d={});d=R({strictDi:!1},d);var c=function(){a=y(a);if(a.injector()){var c=a[0]===B.document?\"document\":ya(a);throw Ia(\"btstrpd\",c.replace(/</,\"&lt;\").replace(/>/,\"&gt;\"));}b=b||[];b.unshift([\"$provide\",function(b){b.value(\"$rootElement\",a)}]);d.debugInfoEnabled&&\nb.push([\"$compileProvider\",function(a){a.debugInfoEnabled(!0)}]);b.unshift(\"ng\");c=fb(b,d.strictDi);c.invoke([\"$rootScope\",\"$rootElement\",\"$compile\",\"$injector\",function(a,b,c,d){a.$apply(function(){b.data(\"$injector\",d);c(b)(a)})}]);return c},e=/^NG_ENABLE_DEBUG_INFO!/,f=/^NG_DEFER_BOOTSTRAP!/;B&&e.test(B.name)&&(d.debugInfoEnabled=!0,B.name=B.name.replace(e,\"\"));if(B&&!f.test(B.name))return c();B.name=B.name.replace(f,\"\");ea.resumeBootstrap=function(a){r(a,function(a){b.push(a)});return c()};z(ea.resumeDeferredBootstrap)&&\nea.resumeDeferredBootstrap()}function ze(){B.name=\"NG_ENABLE_DEBUG_INFO!\"+B.name;B.location.reload()}function Ae(a){a=ea.element(a).injector();if(!a)throw Ia(\"test\");return a.get(\"$$testability\")}function Uc(a,b){b=b||\"_\";return a.replace(Be,function(a,c){return(c?b:\"\")+a.toLowerCase()})}function Ce(){var a;if(!Vc){var b=qb();(rb=x(b)?B.jQuery:b?B[b]:void 0)&&rb.fn.on?(y=rb,R(rb.fn,{scope:Wa.scope,isolateScope:Wa.isolateScope,controller:Wa.controller,injector:Wa.injector,inheritedData:Wa.inheritedData})):\ny=W;a=y.cleanData;y.cleanData=function(b){for(var c,e=0,f;null!=(f=b[e]);e++)(c=(y._data(f)||{}).events)&&c.$destroy&&y(f).triggerHandler(\"$destroy\");a(b)};ea.element=y;Vc=!0}}function gb(a,b,d){if(!a)throw Ia(\"areq\",b||\"?\",d||\"required\");return a}function sb(a,b,d){d&&I(a)&&(a=a[a.length-1]);gb(z(a),b,\"not a function, got \"+(a&&\"object\"===typeof a?a.constructor.name||\"Object\":typeof a));return a}function Qa(a,b){if(\"hasOwnProperty\"===a)throw Ia(\"badname\",b);}function De(a,b,d){if(!b)return a;b=b.split(\".\");\nfor(var c,e=a,f=b.length,g=0;g<f;g++)c=b[g],a&&(a=(e=a)[c]);return!d&&z(a)?Va(e,a):a}function tb(a){for(var b=a[0],d=a[a.length-1],c,e=1;b!==d&&(b=b.nextSibling);e++)if(c||a[e]!==b)c||(c=y(Ga.call(a,0,e))),c.push(b);return c||a}function S(){return Object.create(null)}function hc(a){if(null==a)return\"\";switch(typeof a){case \"string\":break;case \"number\":a=\"\"+a;break;default:a=!ac(a)||I(a)||ha(a)?eb(a):a.toString()}return a}function Ee(a){function b(a,b,c){return a[b]||(a[b]=c())}var d=M(\"$injector\"),\nc=M(\"ng\");a=b(a,\"angular\",Object);a.$$minErr=a.$$minErr||M;return b(a,\"module\",function(){var a={};return function(f,g,k){var h={};if(\"hasOwnProperty\"===f)throw c(\"badname\",\"module\");g&&a.hasOwnProperty(f)&&(a[f]=null);return b(a,f,function(){function a(b,c,d,f){f||(f=e);return function(){f[d||\"push\"]([b,c,arguments]);return u}}function b(a,c,d){d||(d=e);return function(b,e){e&&z(e)&&(e.$$moduleName=f);d.push([a,c,arguments]);return u}}if(!g)throw d(\"nomod\",f);var e=[],n=[],s=[],t=a(\"$injector\",\"invoke\",\n\"push\",n),u={_invokeQueue:e,_configBlocks:n,_runBlocks:s,info:function(a){if(v(a)){if(!F(a))throw c(\"aobj\",\"value\");h=a;return this}return h},requires:g,name:f,provider:b(\"$provide\",\"provider\"),factory:b(\"$provide\",\"factory\"),service:b(\"$provide\",\"service\"),value:a(\"$provide\",\"value\"),constant:a(\"$provide\",\"constant\",\"unshift\"),decorator:b(\"$provide\",\"decorator\",n),animation:b(\"$animateProvider\",\"register\"),filter:b(\"$filterProvider\",\"register\"),controller:b(\"$controllerProvider\",\"register\"),directive:b(\"$compileProvider\",\n\"directive\"),component:b(\"$compileProvider\",\"component\"),config:t,run:function(a){s.push(a);return this}};k&&t(k);return u})}})}function oa(a,b){if(I(a)){b=b||[];for(var d=0,c=a.length;d<c;d++)b[d]=a[d]}else if(F(a))for(d in b=b||{},a)if(\"$\"!==d.charAt(0)||\"$\"!==d.charAt(1))b[d]=a[d];return b||a}function Fe(a,b){var d=[];Wb(b)&&(a=ea.copy(a,null,b));return JSON.stringify(a,function(a,b){b=Pc(a,b);if(F(b)){if(0<=d.indexOf(b))return\"...\";d.push(b)}return b})}function Ge(a){R(a,{errorHandlingConfig:oe,\nbootstrap:Tc,copy:Ha,extend:R,merge:qe,equals:ua,element:y,forEach:r,injector:fb,noop:A,bind:Va,toJson:eb,fromJson:Qc,identity:Ta,isUndefined:x,isDefined:v,isString:C,isFunction:z,isObject:F,isNumber:ba,isElement:Zb,isArray:I,version:He,isDate:ha,callbacks:{$$counter:0},getTestability:Ae,reloadWithDebugInfo:ze,$$minErr:M,$$csp:pa,$$encodeUriSegment:gc,$$encodeUriQuery:ca,$$lowercase:O,$$stringify:hc,$$uppercase:ub});jc=Ee(B);jc(\"ng\",[\"ngLocale\"],[\"$provide\",function(a){a.provider({$$sanitizeUri:Ie});\na.provider(\"$compile\",Wc).directive({a:Je,input:Xc,textarea:Xc,form:Ke,script:Le,select:Me,option:Ne,ngBind:Oe,ngBindHtml:Pe,ngBindTemplate:Qe,ngClass:Re,ngClassEven:Se,ngClassOdd:Te,ngCloak:Ue,ngController:Ve,ngForm:We,ngHide:Xe,ngIf:Ye,ngInclude:Ze,ngInit:$e,ngNonBindable:af,ngPluralize:bf,ngRef:cf,ngRepeat:df,ngShow:ef,ngStyle:ff,ngSwitch:gf,ngSwitchWhen:hf,ngSwitchDefault:jf,ngOptions:kf,ngTransclude:lf,ngModel:mf,ngList:nf,ngChange:of,pattern:Yc,ngPattern:Yc,required:Zc,ngRequired:Zc,minlength:$c,\nngMinlength:$c,maxlength:ad,ngMaxlength:ad,ngValue:pf,ngModelOptions:qf}).directive({ngInclude:rf}).directive(vb).directive(bd);a.provider({$anchorScroll:sf,$animate:tf,$animateCss:uf,$$animateJs:vf,$$animateQueue:wf,$$AnimateRunner:xf,$$animateAsyncRun:yf,$browser:zf,$cacheFactory:Af,$controller:Bf,$document:Cf,$$isDocumentHidden:Df,$exceptionHandler:Ef,$filter:cd,$$forceReflow:Ff,$interpolate:Gf,$interval:Hf,$$intervalFactory:If,$http:Jf,$httpParamSerializer:Kf,$httpParamSerializerJQLike:Lf,$httpBackend:Mf,\n$xhrFactory:Nf,$jsonpCallbacks:Of,$location:Pf,$log:Qf,$parse:Rf,$rootScope:Sf,$q:Tf,$$q:Uf,$sce:Vf,$sceDelegate:Wf,$sniffer:Xf,$$taskTrackerFactory:Yf,$templateCache:Zf,$templateRequest:$f,$$testability:ag,$timeout:bg,$window:cg,$$rAF:dg,$$jqLite:eg,$$Map:fg,$$cookieReader:gg})}]).info({angularVersion:\"1.7.5\"})}function wb(a,b){return b.toUpperCase()}function xb(a){return a.replace(hg,wb)}function kc(a){a=a.nodeType;return 1===a||!a||9===a}function dd(a,b){var d,c,e=b.createDocumentFragment(),f=\n[];if(lc.test(a)){d=e.appendChild(b.createElement(\"div\"));c=(ig.exec(a)||[\"\",\"\"])[1].toLowerCase();c=ja[c]||ja._default;d.innerHTML=c[1]+a.replace(jg,\"<$1></$2>\")+c[2];for(c=c[0];c--;)d=d.lastChild;f=db(f,d.childNodes);d=e.firstChild;d.textContent=\"\"}else f.push(b.createTextNode(a));e.textContent=\"\";e.innerHTML=\"\";r(f,function(a){e.appendChild(a)});return e}function W(a){if(a instanceof W)return a;var b;C(a)&&(a=T(a),b=!0);if(!(this instanceof W)){if(b&&\"<\"!==a.charAt(0))throw mc(\"nosel\");return new W(a)}if(b){b=\nB.document;var d;a=(d=kg.exec(a))?[b.createElement(d[1])]:(d=dd(a,b))?d.childNodes:[];nc(this,a)}else z(a)?ed(a):nc(this,a)}function oc(a){return a.cloneNode(!0)}function yb(a,b){!b&&kc(a)&&y.cleanData([a]);a.querySelectorAll&&y.cleanData(a.querySelectorAll(\"*\"))}function fd(a){for(var b in a)return!1;return!0}function gd(a){var b=a.ng339,d=b&&Ja[b],c=d&&d.events,d=d&&d.data;d&&!fd(d)||c&&!fd(c)||(delete Ja[b],a.ng339=void 0)}function hd(a,b,d,c){if(v(c))throw mc(\"offargs\");var e=(c=zb(a))&&c.events,\nf=c&&c.handle;if(f){if(b){var g=function(b){var c=e[b];v(d)&&cb(c||[],d);v(d)&&c&&0<c.length||(a.removeEventListener(b,f),delete e[b])};r(b.split(\" \"),function(a){g(a);Ab[a]&&g(Ab[a])})}else for(b in e)\"$destroy\"!==b&&a.removeEventListener(b,f),delete e[b];gd(a)}}function pc(a,b){var d=a.ng339;if(d=d&&Ja[d])b?delete d.data[b]:d.data={},gd(a)}function zb(a,b){var d=a.ng339,d=d&&Ja[d];b&&!d&&(a.ng339=d=++lg,d=Ja[d]={events:{},data:{},handle:void 0});return d}function qc(a,b,d){if(kc(a)){var c,e=v(d),\nf=!e&&b&&!F(b),g=!b;a=(a=zb(a,!f))&&a.data;if(e)a[xb(b)]=d;else{if(g)return a;if(f)return a&&a[xb(b)];for(c in b)a[xb(c)]=b[c]}}}function Bb(a,b){return a.getAttribute?-1<(\" \"+(a.getAttribute(\"class\")||\"\")+\" \").replace(/[\\n\\t]/g,\" \").indexOf(\" \"+b+\" \"):!1}function Cb(a,b){if(b&&a.setAttribute){var d=(\" \"+(a.getAttribute(\"class\")||\"\")+\" \").replace(/[\\n\\t]/g,\" \"),c=d;r(b.split(\" \"),function(a){a=T(a);c=c.replace(\" \"+a+\" \",\" \")});c!==d&&a.setAttribute(\"class\",T(c))}}function Db(a,b){if(b&&a.setAttribute){var d=\n(\" \"+(a.getAttribute(\"class\")||\"\")+\" \").replace(/[\\n\\t]/g,\" \"),c=d;r(b.split(\" \"),function(a){a=T(a);-1===c.indexOf(\" \"+a+\" \")&&(c+=a+\" \")});c!==d&&a.setAttribute(\"class\",T(c))}}function nc(a,b){if(b)if(b.nodeType)a[a.length++]=b;else{var d=b.length;if(\"number\"===typeof d&&b.window!==b){if(d)for(var c=0;c<d;c++)a[a.length++]=b[c]}else a[a.length++]=b}}function id(a,b){return Eb(a,\"$\"+(b||\"ngController\")+\"Controller\")}function Eb(a,b,d){9===a.nodeType&&(a=a.documentElement);for(b=I(b)?b:[b];a;){for(var c=\n0,e=b.length;c<e;c++)if(v(d=y.data(a,b[c])))return d;a=a.parentNode||11===a.nodeType&&a.host}}function jd(a){for(yb(a,!0);a.firstChild;)a.removeChild(a.firstChild)}function Fb(a,b){b||yb(a);var d=a.parentNode;d&&d.removeChild(a)}function mg(a,b){b=b||B;if(\"complete\"===b.document.readyState)b.setTimeout(a);else y(b).on(\"load\",a)}function ed(a){function b(){B.document.removeEventListener(\"DOMContentLoaded\",b);B.removeEventListener(\"load\",b);a()}\"complete\"===B.document.readyState?B.setTimeout(a):(B.document.addEventListener(\"DOMContentLoaded\",\nb),B.addEventListener(\"load\",b))}function kd(a,b){var d=Gb[b.toLowerCase()];return d&&ld[ta(a)]&&d}function ng(a,b){var d=function(c,d){c.isDefaultPrevented=function(){return c.defaultPrevented};var f=b[d||c.type],g=f?f.length:0;if(g){if(x(c.immediatePropagationStopped)){var k=c.stopImmediatePropagation;c.stopImmediatePropagation=function(){c.immediatePropagationStopped=!0;c.stopPropagation&&c.stopPropagation();k&&k.call(c)}}c.isImmediatePropagationStopped=function(){return!0===c.immediatePropagationStopped};\nvar h=f.specialHandlerWrapper||og;1<g&&(f=oa(f));for(var l=0;l<g;l++)c.isImmediatePropagationStopped()||h(a,c,f[l])}};d.elem=a;return d}function og(a,b,d){d.call(a,b)}function pg(a,b,d){var c=b.relatedTarget;c&&(c===a||qg.call(a,c))||d.call(a,b)}function eg(){this.$get=function(){return R(W,{hasClass:function(a,b){a.attr&&(a=a[0]);return Bb(a,b)},addClass:function(a,b){a.attr&&(a=a[0]);return Db(a,b)},removeClass:function(a,b){a.attr&&(a=a[0]);return Cb(a,b)}})}}function Ka(a,b){var d=a&&a.$$hashKey;\nif(d)return\"function\"===typeof d&&(d=a.$$hashKey()),d;d=typeof a;return d=\"function\"===d||\"object\"===d&&null!==a?a.$$hashKey=d+\":\"+(b||pe)():d+\":\"+a}function md(){this._keys=[];this._values=[];this._lastKey=NaN;this._lastIndex=-1}function nd(a){a=Function.prototype.toString.call(a).replace(rg,\"\");return a.match(sg)||a.match(tg)}function ug(a){return(a=nd(a))?\"function(\"+(a[1]||\"\").replace(/[\\s\\r\\n]+/,\" \")+\")\":\"fn\"}function fb(a,b){function d(a){return function(b,c){if(F(b))r(b,Xb(a));else return a(b,\nc)}}function c(a,b){Qa(a,\"service\");if(z(b)||I(b))b=n.instantiate(b);if(!b.$get)throw za(\"pget\",a);return q[a+\"Provider\"]=b}function e(a,b){return function(){var c=u.invoke(b,this);if(x(c))throw za(\"undef\",a);return c}}function f(a,b,d){return c(a,{$get:!1!==d?e(a,b):b})}function g(a){gb(x(a)||I(a),\"modulesToLoad\",\"not an array\");var b=[],c;r(a,function(a){function d(a){var b,c;b=0;for(c=a.length;b<c;b++){var e=a[b],f=n.get(e[0]);f[e[1]].apply(f,e[2])}}if(!m.get(a)){m.set(a,!0);try{C(a)?(c=jc(a),\nu.modules[a]=c,b=b.concat(g(c.requires)).concat(c._runBlocks),d(c._invokeQueue),d(c._configBlocks)):z(a)?b.push(n.invoke(a)):I(a)?b.push(n.invoke(a)):sb(a,\"module\")}catch(e){throw I(a)&&(a=a[a.length-1]),e.message&&e.stack&&-1===e.stack.indexOf(e.message)&&(e=e.message+\"\\n\"+e.stack),za(\"modulerr\",a,e.stack||e.message||e);}}});return b}function k(a,c){function d(b,e){if(a.hasOwnProperty(b)){if(a[b]===h)throw za(\"cdep\",b+\" <- \"+l.join(\" <- \"));return a[b]}try{return l.unshift(b),a[b]=h,a[b]=c(b,e),\na[b]}catch(f){throw a[b]===h&&delete a[b],f;}finally{l.shift()}}function e(a,c,f){var g=[];a=fb.$$annotate(a,b,f);for(var h=0,k=a.length;h<k;h++){var l=a[h];if(\"string\"!==typeof l)throw za(\"itkn\",l);g.push(c&&c.hasOwnProperty(l)?c[l]:d(l,f))}return g}return{invoke:function(a,b,c,d){\"string\"===typeof c&&(d=c,c=null);c=e(a,c,d);I(a)&&(a=a[a.length-1]);d=a;if(Aa||\"function\"!==typeof d)d=!1;else{var f=d.$$ngIsClass;Fa(f)||(f=d.$$ngIsClass=/^class\\b/.test(Function.prototype.toString.call(d)));d=f}return d?\n(c.unshift(null),new (Function.prototype.bind.apply(a,c))):a.apply(b,c)},instantiate:function(a,b,c){var d=I(a)?a[a.length-1]:a;a=e(a,b,c);a.unshift(null);return new (Function.prototype.bind.apply(d,a))},get:d,annotate:fb.$$annotate,has:function(b){return q.hasOwnProperty(b+\"Provider\")||a.hasOwnProperty(b)}}}b=!0===b;var h={},l=[],m=new Hb,q={$provide:{provider:d(c),factory:d(f),service:d(function(a,b){return f(a,[\"$injector\",function(a){return a.instantiate(b)}])}),value:d(function(a,b){return f(a,\nia(b),!1)}),constant:d(function(a,b){Qa(a,\"constant\");q[a]=b;s[a]=b}),decorator:function(a,b){var c=n.get(a+\"Provider\"),d=c.$get;c.$get=function(){var a=u.invoke(d,c);return u.invoke(b,null,{$delegate:a})}}}},n=q.$injector=k(q,function(a,b){ea.isString(b)&&l.push(b);throw za(\"unpr\",l.join(\" <- \"));}),s={},t=k(s,function(a,b){var c=n.get(a+\"Provider\",b);return u.invoke(c.$get,c,void 0,a)}),u=t;q.$injectorProvider={$get:ia(t)};u.modules=n.modules=S();var D=g(a),u=t.get(\"$injector\");u.strictDi=b;r(D,\nfunction(a){a&&u.invoke(a)});u.loadNewModules=function(a){r(g(a),function(a){a&&u.invoke(a)})};return u}function sf(){var a=!0;this.disableAutoScrolling=function(){a=!1};this.$get=[\"$window\",\"$location\",\"$rootScope\",function(b,d,c){function e(a){var b=null;Array.prototype.some.call(a,function(a){if(\"a\"===ta(a))return b=a,!0});return b}function f(a){if(a){a.scrollIntoView();var c;c=g.yOffset;z(c)?c=c():Zb(c)?(c=c[0],c=\"fixed\"!==b.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):ba(c)||\n(c=0);c&&(a=a.getBoundingClientRect().top,b.scrollBy(0,a-c))}else b.scrollTo(0,0)}function g(a){a=C(a)?a:ba(a)?a.toString():d.hash();var b;a?(b=k.getElementById(a))?f(b):(b=e(k.getElementsByName(a)))?f(b):\"top\"===a&&f(null):f(null)}var k=b.document;a&&c.$watch(function(){return d.hash()},function(a,b){a===b&&\"\"===a||mg(function(){c.$evalAsync(g)})});return g}]}function hb(a,b){if(!a&&!b)return\"\";if(!a)return b;if(!b)return a;I(a)&&(a=a.join(\" \"));I(b)&&(b=b.join(\" \"));return a+\" \"+b}function vg(a){C(a)&&\n(a=a.split(\" \"));var b=S();r(a,function(a){a.length&&(b[a]=!0)});return b}function Ba(a){return F(a)?a:{}}function wg(a,b,d,c,e){function f(){Z=null;k()}function g(){u=E();u=x(u)?null:u;ua(u,H)&&(u=H);D=H=u}function k(){var a=D;g();if(w!==h.url()||a!==u)w=h.url(),D=u,r(G,function(a){a(h.url(),u)})}var h=this,l=a.location,m=a.history,q=a.setTimeout,n=a.clearTimeout,s={},t=e(d);h.isMock=!1;h.$$completeOutstandingRequest=t.completeTask;h.$$incOutstandingRequestCount=t.incTaskCount;h.notifyWhenNoOutstandingRequests=\nt.notifyWhenNoPendingTasks;var u,D,w=l.href,ic=b.find(\"base\"),Z=null,E=c.history?function(){try{return m.state}catch(a){}}:A;g();h.url=function(b,d,e){x(e)&&(e=null);l!==a.location&&(l=a.location);m!==a.history&&(m=a.history);if(b){var f=D===e;if(w===b&&(!c.history||f))return h;var k=w&&qa(w)===qa(b);w=b;D=e;!c.history||k&&f?(k||(Z=b),d?l.replace(b):k?(d=l,e=b.indexOf(\"#\"),e=-1===e?\"\":b.substr(e),d.hash=e):l.href=b,l.href!==b&&(Z=b)):(m[d?\"replaceState\":\"pushState\"](e,\"\",b),g());Z&&(Z=b);return h}return(Z||\nl.href).replace(/#$/,\"\")};h.state=function(){return u};var G=[],J=!1,H=null;h.onUrlChange=function(b){if(!J){if(c.history)y(a).on(\"popstate\",f);y(a).on(\"hashchange\",f);J=!0}G.push(b);return b};h.$$applicationDestroyed=function(){y(a).off(\"hashchange popstate\",f)};h.$$checkUrlChange=k;h.baseHref=function(){var a=ic.attr(\"href\");return a?a.replace(/^(https?:)?\\/\\/[^/]*/,\"\"):\"\"};h.defer=function(a,b,c){var d;b=b||0;c=c||t.DEFAULT_TASK_TYPE;t.incTaskCount(c);d=q(function(){delete s[d];t.completeTask(a,\nc)},b);s[d]=c;return d};h.defer.cancel=function(a){if(s.hasOwnProperty(a)){var b=s[a];delete s[a];n(a);t.completeTask(A,b);return!0}return!1}}function zf(){this.$get=[\"$window\",\"$log\",\"$sniffer\",\"$document\",\"$$taskTrackerFactory\",function(a,b,d,c,e){return new wg(a,c,b,d,e)}]}function Af(){this.$get=function(){function a(a,c){function e(a){a!==q&&(n?n===a&&(n=a.n):n=a,f(a.n,a.p),f(a,q),q=a,q.n=null)}function f(a,b){a!==b&&(a&&(a.p=b),b&&(b.n=a))}if(a in b)throw M(\"$cacheFactory\")(\"iid\",a);var g=0,\nk=R({},c,{id:a}),h=S(),l=c&&c.capacity||Number.MAX_VALUE,m=S(),q=null,n=null;return b[a]={put:function(a,b){if(!x(b)){if(l<Number.MAX_VALUE){var c=m[a]||(m[a]={key:a});e(c)}a in h||g++;h[a]=b;g>l&&this.remove(n.key);return b}},get:function(a){if(l<Number.MAX_VALUE){var b=m[a];if(!b)return;e(b)}return h[a]},remove:function(a){if(l<Number.MAX_VALUE){var b=m[a];if(!b)return;b===q&&(q=b.p);b===n&&(n=b.n);f(b.n,b.p);delete m[a]}a in h&&(delete h[a],g--)},removeAll:function(){h=S();g=0;m=S();q=n=null},\ndestroy:function(){m=k=h=null;delete b[a]},info:function(){return R({},k,{size:g})}}}var b={};a.info=function(){var a={};r(b,function(b,e){a[e]=b.info()});return a};a.get=function(a){return b[a]};return a}}function Zf(){this.$get=[\"$cacheFactory\",function(a){return a(\"templates\")}]}function Wc(a,b){function d(a,b,c){var d=/^([@&]|[=<](\\*?))(\\??)\\s*([\\w$]*)$/,e=S();r(a,function(a,f){a=a.trim();if(a in q)e[f]=q[a];else{var g=a.match(d);if(!g)throw aa(\"iscp\",b,f,a,c?\"controller bindings definition\":\n\"isolate scope definition\");e[f]={mode:g[1][0],collection:\"*\"===g[2],optional:\"?\"===g[3],attrName:g[4]||f};g[4]&&(q[a]=e[f])}});return e}function c(a){var b=a.charAt(0);if(!b||b!==O(b))throw aa(\"baddir\",a);if(a!==a.trim())throw aa(\"baddir\",a);}function e(a){var b=a.require||a.controller&&a.name;!I(b)&&F(b)&&r(b,function(a,c){var d=a.match(l);a.substring(d[0].length)||(b[c]=d[0]+c)});return b}var f={},g=/^\\s*directive:\\s*([\\w-]+)\\s+(.*)$/,k=/(([\\w-]+)(?::([^;]+))?;?)/,h=te(\"ngSrc,ngSrcset,src,srcset\"),\nl=/^(?:(\\^\\^?)?(\\?)?(\\^\\^?)?)?/,m=/^(on[a-z]+|formaction)$/,q=S();this.directive=function Z(b,d){gb(b,\"name\");Qa(b,\"directive\");C(b)?(c(b),gb(d,\"directiveFactory\"),f.hasOwnProperty(b)||(f[b]=[],a.factory(b+\"Directive\",[\"$injector\",\"$exceptionHandler\",function(a,c){var d=[];r(f[b],function(f,g){try{var h=a.invoke(f);z(h)?h={compile:ia(h)}:!h.compile&&h.link&&(h.compile=ia(h.link));h.priority=h.priority||0;h.index=g;h.name=h.name||b;h.require=e(h);var k=h,l=h.restrict;if(l&&(!C(l)||!/[EACM]/.test(l)))throw aa(\"badrestrict\",\nl,b);k.restrict=l||\"EA\";h.$$moduleName=f.$$moduleName;d.push(h)}catch(m){c(m)}});return d}])),f[b].push(d)):r(b,Xb(Z));return this};this.component=function E(a,b){function c(a){function e(b){return z(b)||I(b)?function(c,d){return a.invoke(b,this,{$element:c,$attrs:d})}:b}var f=b.template||b.templateUrl?b.template:\"\",g={controller:d,controllerAs:xg(b.controller)||b.controllerAs||\"$ctrl\",template:e(f),templateUrl:e(b.templateUrl),transclude:b.transclude,scope:{},bindToController:b.bindings||{},restrict:\"E\",\nrequire:b.require};r(b,function(a,b){\"$\"===b.charAt(0)&&(g[b]=a)});return g}if(!C(a))return r(a,Xb(Va(this,E))),this;var d=b.controller||function(){};r(b,function(a,b){\"$\"===b.charAt(0)&&(c[b]=a,z(d)&&(d[b]=a))});c.$inject=[\"$injector\"];return this.directive(a,c)};this.aHrefSanitizationWhitelist=function(a){return v(a)?(b.aHrefSanitizationWhitelist(a),this):b.aHrefSanitizationWhitelist()};this.imgSrcSanitizationWhitelist=function(a){return v(a)?(b.imgSrcSanitizationWhitelist(a),this):b.imgSrcSanitizationWhitelist()};\nvar n=!0;this.debugInfoEnabled=function(a){return v(a)?(n=a,this):n};var s=!1;this.strictComponentBindingsEnabled=function(a){return v(a)?(s=a,this):s};var t=10;this.onChangesTtl=function(a){return arguments.length?(t=a,this):t};var u=!0;this.commentDirectivesEnabled=function(a){return arguments.length?(u=a,this):u};var D=!0;this.cssClassDirectivesEnabled=function(a){return arguments.length?(D=a,this):D};var w=S();this.addPropertySecurityContext=function(a,b,c){var d=a.toLowerCase()+\"|\"+b.toLowerCase();\nif(d in w&&w[d]!==c)throw aa(\"ctxoverride\",a,b,w[d],c);w[d]=c;return this};(function(){function a(b,c){r(c,function(a){w[a.toLowerCase()]=b})}a(U.HTML,[\"iframe|srcdoc\",\"*|innerHTML\",\"*|outerHTML\"]);a(U.CSS,[\"*|style\"]);a(U.URL,\"area|href area|ping a|href a|ping blockquote|cite body|background del|cite input|src ins|cite q|cite\".split(\" \"));a(U.MEDIA_URL,\"audio|src img|src img|srcset source|src source|srcset track|src video|src video|poster\".split(\" \"));a(U.RESOURCE_URL,\"*|formAction applet|code applet|codebase base|href embed|src frame|src form|action head|profile html|manifest iframe|src link|href media|src object|codebase object|data script|src\".split(\" \"))})();\nthis.$get=[\"$injector\",\"$interpolate\",\"$exceptionHandler\",\"$templateRequest\",\"$parse\",\"$controller\",\"$rootScope\",\"$sce\",\"$animate\",function(a,b,c,e,q,K,L,P,Q){function p(){try{if(!--Ja)throw Ua=void 0,aa(\"infchng\",t);L.$apply(function(){for(var a=0,b=Ua.length;a<b;++a)try{Ua[a]()}catch(d){c(d)}Ua=void 0})}finally{Ja++}}function na(a,b){if(!a)return a;if(!C(a))throw aa(\"srcset\",b,a.toString());for(var c=\"\",d=T(a),e=/(\\s+\\d+x\\s*,|\\s+\\d+w\\s*,|\\s+,|,\\s+)/,e=/\\s/.test(d)?e:/(,)/,d=d.split(e),e=Math.floor(d.length/\n2),f=0;f<e;f++)var g=2*f,c=c+P.getTrustedMediaUrl(T(d[g])),c=c+(\" \"+T(d[g+1]));d=T(d[2*f]).split(/\\s/);c+=P.getTrustedMediaUrl(T(d[0]));2===d.length&&(c+=\" \"+T(d[1]));return c}function v(a,b){if(b){var c=Object.keys(b),d,e,f;d=0;for(e=c.length;d<e;d++)f=c[d],this[f]=b[f]}else this.$attr={};this.$$element=a}function N(a,b,c){Ea.innerHTML=\"<span \"+b+\">\";b=Ea.firstChild.attributes;var d=b[0];b.removeNamedItem(d.name);d.value=c;a.attributes.setNamedItem(d)}function ra(a,b){try{a.addClass(b)}catch(c){}}\nfunction fa(a,b,c,d,e){a instanceof y||(a=y(a));var f=Xa(a,b,a,c,d,e);fa.$$addScopeClass(a);var g=null;return function(b,c,d){if(!a)throw aa(\"multilink\");gb(b,\"scope\");e&&e.needsNewScope&&(b=b.$parent.$new());d=d||{};var h=d.parentBoundTranscludeFn,k=d.transcludeControllers;d=d.futureParentElement;h&&h.$$boundTransclude&&(h=h.$$boundTransclude);g||(g=(d=d&&d[0])?\"foreignobject\"!==ta(d)&&ma.call(d).match(/SVG/)?\"svg\":\"html\":\"html\");d=\"html\"!==g?y(ja(g,y(\"<div></div>\").append(a).html())):c?Wa.clone.call(a):\na;if(k)for(var l in k)d.data(\"$\"+l+\"Controller\",k[l].instance);fa.$$addScopeInfo(d,b);c&&c(d,b);f&&f(b,d,d,h);c||(a=f=null);return d}}function Xa(a,b,c,d,e,f){function g(a,c,d,e){var f,k,l,m,q,n,G;if(J)for(G=Array(c.length),m=0;m<h.length;m+=3)f=h[m],G[f]=c[f];else G=c;m=0;for(q=h.length;m<q;)k=G[h[m++]],c=h[m++],f=h[m++],c?(c.scope?(l=a.$new(),fa.$$addScopeInfo(y(k),l)):l=a,n=c.transcludeOnThisElement?ka(a,c.transclude,e):!c.templateOnThisElement&&e?e:!e&&b?ka(a,b):null,c(f,l,k,d,n)):f&&f(a,k.childNodes,\nvoid 0,e)}for(var h=[],k=I(a)||a instanceof y,l,m,q,n,J,G=0;G<a.length;G++){l=new v;11===Aa&&ib(a,G,k);m=rc(a[G],[],l,0===G?d:void 0,e);(f=m.length?ba(m,a[G],l,b,c,null,[],[],f):null)&&f.scope&&fa.$$addScopeClass(l.$$element);l=f&&f.terminal||!(q=a[G].childNodes)||!q.length?null:Xa(q,f?(f.transcludeOnThisElement||!f.templateOnThisElement)&&f.transclude:b);if(f||l)h.push(G,f,l),n=!0,J=J||f;f=null}return n?g:null}function ib(a,b,c){var d=a[b],e=d.parentNode,f;if(d.nodeType===Oa)for(;;){f=e?d.nextSibling:\na[b+1];if(!f||f.nodeType!==Oa)break;d.nodeValue+=f.nodeValue;f.parentNode&&f.parentNode.removeChild(f);c&&f===a[b+1]&&a.splice(b+1,1)}}function ka(a,b,c){function d(e,f,g,h,k){e||(e=a.$new(!1,k),e.$$transcluded=!0);return b(e,f,{parentBoundTranscludeFn:c,transcludeControllers:g,futureParentElement:h})}var e=d.$$slots=S(),f;for(f in b.$$slots)e[f]=b.$$slots[f]?ka(a,b.$$slots[f],c):null;return d}function rc(a,b,d,e,f){var g=d.$attr,h;switch(a.nodeType){case 1:h=ta(a);V(b,va(h),\"E\",e,f);for(var l,m,\nn,G,u,s=a.attributes,w=0,E=s&&s.length;w<E;w++){var D=!1,r=!1,P=!1,H=!1,t=!1,K;l=s[w];m=l.name;G=l.value;n=va(m.toLowerCase());(u=n.match(Ra))?(P=\"Attr\"===u[1],H=\"Prop\"===u[1],t=\"On\"===u[1],m=m.replace(od,\"\").toLowerCase().substr(4+u[1].length).replace(/_(.)/g,function(a,b){return b.toUpperCase()})):(K=n.match(Sa))&&ea(K[1])&&(D=m,r=m.substr(0,m.length-5)+\"end\",m=m.substr(0,m.length-6));if(H||t)d[n]=G,g[n]=l.name,H?Ha(a,b,n,m):b.push(pd(q,L,c,n,m,!1));else{n=va(m.toLowerCase());g[n]=m;if(P||!d.hasOwnProperty(n))d[n]=\nG,kd(a,n)&&(d[n]=!0);Ia(a,b,G,n,P);V(b,n,\"A\",e,f,D,r)}}\"input\"===h&&\"hidden\"===a.getAttribute(\"type\")&&a.setAttribute(\"autocomplete\",\"off\");if(!Qa)break;g=a.className;F(g)&&(g=g.animVal);if(C(g)&&\"\"!==g)for(;a=k.exec(g);)n=va(a[2]),V(b,n,\"C\",e,f)&&(d[n]=T(a[3])),g=g.substr(a.index+a[0].length);break;case Oa:oa(b,a.nodeValue);break;case 8:if(!Pa)break;M(a,b,d,e,f)}b.sort(la);return b}function M(a,b,c,d,e){try{var f=g.exec(a.nodeValue);if(f){var h=va(f[1]);V(b,h,\"M\",d,e)&&(c[h]=T(f[2]))}}catch(k){}}\nfunction U(a,b,c){var d=[],e=0;if(b&&a.hasAttribute&&a.hasAttribute(b)){do{if(!a)throw aa(\"uterdir\",b,c);1===a.nodeType&&(a.hasAttribute(b)&&e++,a.hasAttribute(c)&&e--);d.push(a);a=a.nextSibling}while(0<e)}else d.push(a);return y(d)}function W(a,b,c){return function(d,e,f,g,h){e=U(e[0],b,c);return a(d,e,f,g,h)}}function Y(a,b,c,d,e,f){var g;return a?fa(b,c,d,e,f):function(){g||(g=fa(b,c,d,e,f),b=c=f=null);return g.apply(this,arguments)}}function ba(a,b,d,e,f,g,h,k,l){function m(a,b,c,d){if(a){c&&\n(a=W(a,c,d));a.require=t.require;a.directiveName=K;if(s===t||t.$$isolateScope)a=za(a,{isolateScope:!0});h.push(a)}if(b){c&&(b=W(b,c,d));b.require=t.require;b.directiveName=K;if(s===t||t.$$isolateScope)b=za(b,{isolateScope:!0});k.push(b)}}function q(a,e,f,g,l){function m(a,b,c,d){var e;bb(a)||(d=c,c=b,b=a,a=void 0);P&&(e=D);c||(c=P?K.parent():K);if(d){var f=l.$$slots[d];if(f)return f(a,b,e,c,Q);if(x(f))throw aa(\"noslot\",d,ya(K));}else return l(a,b,e,c,Q)}var n,t,L,H,E,D,X,K;b===f?(g=d,K=d.$$element):\n(K=y(f),g=new v(K,d));E=e;s?H=e.$new(!0):G&&(E=e.$parent);l&&(X=m,X.$$boundTransclude=l,X.isSlotFilled=function(a){return!!l.$$slots[a]});u&&(D=ga(K,g,X,u,H,e,s));s&&(fa.$$addScopeInfo(K,H,!0,!(w&&(w===s||w===s.$$originalDirective))),fa.$$addScopeClass(K,!0),H.$$isolateBindings=s.$$isolateBindings,t=Ca(e,g,H,H.$$isolateBindings,s),t.removeWatches&&H.$on(\"$destroy\",t.removeWatches));for(n in D){t=u[n];L=D[n];var yg=t.$$bindings.bindToController;L.instance=L();K.data(\"$\"+t.name+\"Controller\",L.instance);\nL.bindingInfo=Ca(E,g,L.instance,yg,t)}r(u,function(a,b){var c=a.require;a.bindToController&&!I(c)&&F(c)&&R(D[b].instance,$(b,c,K,D))});r(D,function(a){var b=a.instance;if(z(b.$onChanges))try{b.$onChanges(a.bindingInfo.initialChanges)}catch(d){c(d)}if(z(b.$onInit))try{b.$onInit()}catch(e){c(e)}z(b.$doCheck)&&(E.$watch(function(){b.$doCheck()}),b.$doCheck());z(b.$onDestroy)&&E.$on(\"$destroy\",function(){b.$onDestroy()})});n=0;for(t=h.length;n<t;n++)L=h[n],Ba(L,L.isolateScope?H:e,K,g,L.require&&$(L.directiveName,\nL.require,K,D),X);var Q=e;s&&(s.template||null===s.templateUrl)&&(Q=H);a&&a(Q,f.childNodes,void 0,l);for(n=k.length-1;0<=n;n--)L=k[n],Ba(L,L.isolateScope?H:e,K,g,L.require&&$(L.directiveName,L.require,K,D),X);r(D,function(a){a=a.instance;z(a.$postLink)&&a.$postLink()})}l=l||{};for(var n=-Number.MAX_VALUE,G=l.newScopeDirective,u=l.controllerDirectives,s=l.newIsolateScopeDirective,w=l.templateDirective,L=l.nonTlbTranscludeDirective,E=!1,D=!1,P=l.hasElementTranscludeDirective,H=d.$$element=y(b),t,K,\nX,Q=e,p,na=!1,Ib=!1,N,ra=0,C=a.length;ra<C;ra++){t=a[ra];var A=t.$$start,ib=t.$$end;A&&(H=U(b,A,ib));X=void 0;if(n>t.priority)break;if(N=t.scope)t.templateUrl||(F(N)?(ca(\"new/isolated scope\",s||G,t,H),s=t):ca(\"new/isolated scope\",s,t,H)),G=G||t;K=t.name;if(!na&&(t.replace&&(t.templateUrl||t.template)||t.transclude&&!t.$$tlb)){for(N=ra+1;na=a[N++];)if(na.transclude&&!na.$$tlb||na.replace&&(na.templateUrl||na.template)){Ib=!0;break}na=!0}!t.templateUrl&&t.controller&&(u=u||S(),ca(\"'\"+K+\"' controller\",\nu[K],t,H),u[K]=t);if(N=t.transclude)if(E=!0,t.$$tlb||(ca(\"transclusion\",L,t,H),L=t),\"element\"===N)P=!0,n=t.priority,X=H,H=d.$$element=y(fa.$$createComment(K,d[K])),b=H[0],pa(f,Ga.call(X,0),b),Q=Y(Ib,X,e,n,g&&g.name,{nonTlbTranscludeDirective:L});else{var ka=S();if(F(N)){X=B.document.createDocumentFragment();var Xa=S(),M=S();r(N,function(a,b){var c=\"?\"===a.charAt(0);a=c?a.substring(1):a;Xa[a]=b;ka[b]=null;M[b]=c});r(H.contents(),function(a){var b=Xa[va(ta(a))];b?(M[b]=!0,ka[b]=ka[b]||B.document.createDocumentFragment(),\nka[b].appendChild(a)):X.appendChild(a)});r(M,function(a,b){if(!a)throw aa(\"reqslot\",b);});for(var O in ka)ka[O]&&(Q=y(ka[O].childNodes),ka[O]=Y(Ib,Q,e));X=y(X.childNodes)}else X=y(oc(b)).contents();H.empty();Q=Y(Ib,X,e,void 0,void 0,{needsNewScope:t.$$isolateScope||t.$$newScope});Q.$$slots=ka}if(t.template)if(D=!0,ca(\"template\",w,t,H),w=t,N=z(t.template)?t.template(H,d):t.template,N=Na(N),t.replace){g=t;X=lc.test(N)?qd(ja(t.templateNamespace,T(N))):[];b=X[0];if(1!==X.length||1!==b.nodeType)throw aa(\"tplrt\",\nK,\"\");pa(f,H,b);C={$attr:{}};N=rc(b,[],C);var zg=a.splice(ra+1,a.length-(ra+1));(s||G)&&da(N,s,G);a=a.concat(N).concat(zg);ha(d,C);C=a.length}else H.html(N);if(t.templateUrl)D=!0,ca(\"template\",w,t,H),w=t,t.replace&&(g=t),q=ia(a.splice(ra,a.length-ra),H,d,f,E&&Q,h,k,{controllerDirectives:u,newScopeDirective:G!==t&&G,newIsolateScopeDirective:s,templateDirective:w,nonTlbTranscludeDirective:L}),C=a.length;else if(t.compile)try{p=t.compile(H,d,Q);var V=t.$$originalDirective||t;z(p)?m(null,Va(V,p),A,ib):\np&&m(Va(V,p.pre),Va(V,p.post),A,ib)}catch(ea){c(ea,ya(H))}t.terminal&&(q.terminal=!0,n=Math.max(n,t.priority))}q.scope=G&&!0===G.scope;q.transcludeOnThisElement=E;q.templateOnThisElement=D;q.transclude=Q;l.hasElementTranscludeDirective=P;return q}function $(a,b,c,d){var e;if(C(b)){var f=b.match(l);b=b.substring(f[0].length);var g=f[1]||f[3],f=\"?\"===f[2];\"^^\"===g?c=c.parent():e=(e=d&&d[b])&&e.instance;if(!e){var h=\"$\"+b+\"Controller\";e=\"^^\"===g&&c[0]&&9===c[0].nodeType?null:g?c.inheritedData(h):c.data(h)}if(!e&&\n!f)throw aa(\"ctreq\",b,a);}else if(I(b))for(e=[],g=0,f=b.length;g<f;g++)e[g]=$(a,b[g],c,d);else F(b)&&(e={},r(b,function(b,f){e[f]=$(a,b,c,d)}));return e||null}function ga(a,b,c,d,e,f,g){var h=S(),k;for(k in d){var l=d[k],m={$scope:l===g||l.$$isolateScope?e:f,$element:a,$attrs:b,$transclude:c},n=l.controller;\"@\"===n&&(n=b[l.name]);m=K(n,m,!0,l.controllerAs);h[l.name]=m;a.data(\"$\"+l.name+\"Controller\",m.instance)}return h}function da(a,b,c){for(var d=0,e=a.length;d<e;d++)a[d]=$b(a[d],{$$isolateScope:b,\n$$newScope:c})}function V(b,c,e,g,h,k,l){if(c===h)return null;var m=null;if(f.hasOwnProperty(c)){h=a.get(c+\"Directive\");for(var n=0,q=h.length;n<q;n++)if(c=h[n],(x(g)||g>c.priority)&&-1!==c.restrict.indexOf(e)){k&&(c=$b(c,{$$start:k,$$end:l}));if(!c.$$bindings){var J=m=c,G=c.name,u={isolateScope:null,bindToController:null};F(J.scope)&&(!0===J.bindToController?(u.bindToController=d(J.scope,G,!0),u.isolateScope={}):u.isolateScope=d(J.scope,G,!1));F(J.bindToController)&&(u.bindToController=d(J.bindToController,\nG,!0));if(u.bindToController&&!J.controller)throw aa(\"noctrl\",G);m=m.$$bindings=u;F(m.isolateScope)&&(c.$$isolateBindings=m.isolateScope)}b.push(c);m=c}}return m}function ea(b){if(f.hasOwnProperty(b))for(var c=a.get(b+\"Directive\"),d=0,e=c.length;d<e;d++)if(b=c[d],b.multiElement)return!0;return!1}function ha(a,b){var c=b.$attr,d=a.$attr;r(a,function(d,e){\"$\"!==e.charAt(0)&&(b[e]&&b[e]!==d&&(d=d.length?d+((\"style\"===e?\";\":\" \")+b[e]):b[e]),a.$set(e,d,!0,c[e]))});r(b,function(b,e){a.hasOwnProperty(e)||\n\"$\"===e.charAt(0)||(a[e]=b,\"class\"!==e&&\"style\"!==e&&(d[e]=c[e]))})}function ia(a,b,d,f,g,h,k,l){var m=[],n,q,G=b[0],u=a.shift(),t=$b(u,{templateUrl:null,transclude:null,replace:null,$$originalDirective:u}),s=z(u.templateUrl)?u.templateUrl(b,d):u.templateUrl,L=u.templateNamespace;b.empty();e(s).then(function(c){var e,J;c=Na(c);if(u.replace){c=lc.test(c)?qd(ja(L,T(c))):[];e=c[0];if(1!==c.length||1!==e.nodeType)throw aa(\"tplrt\",u.name,s);c={$attr:{}};pa(f,b,e);var w=rc(e,[],c);F(u.scope)&&da(w,!0);\na=w.concat(a);ha(d,c)}else e=G,b.html(c);a.unshift(t);n=ba(a,e,d,g,b,u,h,k,l);r(f,function(a,c){a===e&&(f[c]=b[0])});for(q=Xa(b[0].childNodes,g);m.length;){c=m.shift();J=m.shift();var H=m.shift(),D=m.shift(),w=b[0];if(!c.$$destroyed){if(J!==G){var E=J.className;l.hasElementTranscludeDirective&&u.replace||(w=oc(e));pa(H,y(J),w);ra(y(w),E)}J=n.transcludeOnThisElement?ka(c,n.transclude,D):D;n(q,c,w,f,J)}}m=null}).catch(function(a){bc(a)&&c(a)});return function(a,b,c,d,e){a=e;b.$$destroyed||(m?m.push(b,\nc,d,a):(n.transcludeOnThisElement&&(a=ka(b,n.transclude,e)),n(q,b,c,d,a)))}}function la(a,b){var c=b.priority-a.priority;return 0!==c?c:a.name!==b.name?a.name<b.name?-1:1:a.index-b.index}function ca(a,b,c,d){function e(a){return a?\" (module: \"+a+\")\":\"\"}if(b)throw aa(\"multidir\",b.name,e(b.$$moduleName),c.name,e(c.$$moduleName),a,ya(d));}function oa(a,c){var d=b(c,!0);d&&a.push({priority:0,compile:function(a){a=a.parent();var b=!!a.length;b&&fa.$$addBindingClass(a);return function(a,c){var e=c.parent();\nb||fa.$$addBindingClass(e);fa.$$addBindingInfo(e,d.expressions);a.$watch(d,function(a){c[0].nodeValue=a})}}})}function ja(a,b){a=O(a||\"html\");switch(a){case \"svg\":case \"math\":var c=B.document.createElement(\"div\");c.innerHTML=\"<\"+a+\">\"+b+\"</\"+a+\">\";return c.childNodes[0].childNodes;default:return b}}function wa(a,b){if(\"srcdoc\"===b)return P.HTML;if(\"src\"===b||\"ngSrc\"===b)return-1===[\"img\",\"video\",\"audio\",\"source\",\"track\"].indexOf(a)?P.RESOURCE_URL:P.MEDIA_URL;if(\"xlinkHref\"===b)return\"image\"===a?P.MEDIA_URL:\n\"a\"===a?P.URL:P.RESOURCE_URL;if(\"form\"===a&&\"action\"===b||\"base\"===a&&\"href\"===b||\"link\"===a&&\"href\"===b)return P.RESOURCE_URL;if(\"a\"===a&&(\"href\"===b||\"ngHref\"===b))return P.URL}function xa(a,b){var c=b.toLowerCase();return w[a+\"|\"+c]||w[\"*|\"+c]}function Da(a){return na(P.valueOf(a),\"ng-prop-srcset\")}function Ha(a,b,c,d){if(m.test(d))throw aa(\"nodomevents\");a=ta(a);var e=xa(a,d),f=Ta;\"srcset\"!==d||\"img\"!==a&&\"source\"!==a?e&&(f=P.getTrusted.bind(P,e)):f=Da;b.push({priority:100,compile:function(a,\nb){var e=q(b[c]),g=q(b[c],function(a){return P.valueOf(a)});return{pre:function(a,b){function c(){var g=e(a);b.prop(d,f(g))}c();a.$watch(g,c)}}}})}function Ia(a,c,d,e,f){var g=ta(a),k=wa(g,e),l=h[e]||f,n=b(d,!f,k,l);if(n){if(\"multiple\"===e&&\"select\"===g)throw aa(\"selmulti\",ya(a));if(m.test(e))throw aa(\"nodomevents\");c.push({priority:100,compile:function(){return{pre:function(a,c,f){c=f.$$observers||(f.$$observers=S());var g=f[e];g!==d&&(n=g&&b(g,!0,k,l),d=g);n&&(f[e]=n(a),(c[e]||(c[e]=[])).$$inter=\n!0,(f.$$observers&&f.$$observers[e].$$scope||a).$watch(n,function(a,b){\"class\"===e&&a!==b?f.$updateClass(a,b):f.$set(e,a)}))}}}})}}function pa(a,b,c){var d=b[0],e=b.length,f=d.parentNode,g,h;if(a)for(g=0,h=a.length;g<h;g++)if(a[g]===d){a[g++]=c;h=g+e-1;for(var k=a.length;g<k;g++,h++)h<k?a[g]=a[h]:delete a[g];a.length-=e-1;a.context===d&&(a.context=c);break}f&&f.replaceChild(c,d);a=B.document.createDocumentFragment();for(g=0;g<e;g++)a.appendChild(b[g]);y.hasData(d)&&(y.data(c,y.data(d)),y(d).off(\"$destroy\"));\ny.cleanData(a.querySelectorAll(\"*\"));for(g=1;g<e;g++)delete b[g];b[0]=c;b.length=1}function za(a,b){return R(function(){return a.apply(null,arguments)},a,b)}function Ba(a,b,d,e,f,g){try{a(b,d,e,f,g)}catch(h){c(h,ya(d))}}function qa(a,b){if(s)throw aa(\"missingattr\",a,b);}function Ca(a,c,d,e,f){function g(b,c,e){z(d.$onChanges)&&!cc(c,e)&&(Ua||(a.$$postDigest(p),Ua=[]),m||(m={},Ua.push(h)),m[b]&&(e=m[b].previousValue),m[b]=new Jb(e,c))}function h(){d.$onChanges(m);m=void 0}var k=[],l={},m;r(e,function(e,\nh){var m=e.attrName,n=e.optional,J,u,t,s;switch(e.mode){case \"@\":n||sa.call(c,m)||(qa(m,f.name),d[h]=c[m]=void 0);n=c.$observe(m,function(a){if(C(a)||Fa(a))g(h,a,d[h]),d[h]=a});c.$$observers[m].$$scope=a;J=c[m];C(J)?d[h]=b(J)(a):Fa(J)&&(d[h]=J);l[h]=new Jb(sc,d[h]);k.push(n);break;case \"=\":if(!sa.call(c,m)){if(n)break;qa(m,f.name);c[m]=void 0}if(n&&!c[m])break;u=q(c[m]);s=u.literal?ua:cc;t=u.assign||function(){J=d[h]=u(a);throw aa(\"nonassign\",c[m],m,f.name);};J=d[h]=u(a);n=function(b){s(b,d[h])||\n(s(b,J)?t(a,b=d[h]):d[h]=b);return J=b};n.$stateful=!0;n=e.collection?a.$watchCollection(c[m],n):a.$watch(q(c[m],n),null,u.literal);k.push(n);break;case \"<\":if(!sa.call(c,m)){if(n)break;qa(m,f.name);c[m]=void 0}if(n&&!c[m])break;u=q(c[m]);var L=u.literal,w=d[h]=u(a);l[h]=new Jb(sc,d[h]);n=a[e.collection?\"$watchCollection\":\"$watch\"](u,function(a,b){if(b===a){if(b===w||L&&ua(b,w))return;b=w}g(h,a,b);d[h]=a});k.push(n);break;case \"&\":n||sa.call(c,m)||qa(m,f.name);u=c.hasOwnProperty(m)?q(c[m]):A;if(u===\nA&&n)break;d[h]=function(b){return u(a,b)}}});return{initialChanges:l,removeWatches:k.length&&function(){for(var a=0,b=k.length;a<b;++a)k[a]()}}}var Ma=/^\\w/,Ea=B.document.createElement(\"div\"),Pa=u,Qa=D,Ja=t,Ua;v.prototype={$normalize:va,$addClass:function(a){a&&0<a.length&&Q.addClass(this.$$element,a)},$removeClass:function(a){a&&0<a.length&&Q.removeClass(this.$$element,a)},$updateClass:function(a,b){var c=rd(a,b);c&&c.length&&Q.addClass(this.$$element,c);(c=rd(b,a))&&c.length&&Q.removeClass(this.$$element,\nc)},$set:function(a,b,d,e){var f=kd(this.$$element[0],a),g=sd[a],h=a;f?(this.$$element.prop(a,b),e=f):g&&(this[g]=b,h=g);this[a]=b;e?this.$attr[a]=e:(e=this.$attr[a])||(this.$attr[a]=e=Uc(a,\"-\"));\"img\"===ta(this.$$element)&&\"srcset\"===a&&(this[a]=b=na(b,\"$set('srcset', value)\"));!1!==d&&(null===b||x(b)?this.$$element.removeAttr(e):Ma.test(e)?this.$$element.attr(e,b):N(this.$$element[0],e,b));(a=this.$$observers)&&r(a[h],function(a){try{a(b)}catch(d){c(d)}})},$observe:function(a,b){var c=this,d=c.$$observers||\n(c.$$observers=S()),e=d[a]||(d[a]=[]);e.push(b);L.$evalAsync(function(){e.$$inter||!c.hasOwnProperty(a)||x(c[a])||b(c[a])});return function(){cb(e,b)}}};var Ka=b.startSymbol(),La=b.endSymbol(),Na=\"{{\"===Ka&&\"}}\"===La?Ta:function(a){return a.replace(/\\{\\{/g,Ka).replace(/}}/g,La)},Ra=/^ng(Attr|Prop|On)([A-Z].*)$/,Sa=/^(.+)Start$/;fa.$$addBindingInfo=n?function(a,b){var c=a.data(\"$binding\")||[];I(b)?c=c.concat(b):c.push(b);a.data(\"$binding\",c)}:A;fa.$$addBindingClass=n?function(a){ra(a,\"ng-binding\")}:\nA;fa.$$addScopeInfo=n?function(a,b,c,d){a.data(c?d?\"$isolateScopeNoTemplate\":\"$isolateScope\":\"$scope\",b)}:A;fa.$$addScopeClass=n?function(a,b){ra(a,b?\"ng-isolate-scope\":\"ng-scope\")}:A;fa.$$createComment=function(a,b){var c=\"\";n&&(c=\" \"+(a||\"\")+\": \",b&&(c+=b+\" \"));return B.document.createComment(c)};return fa}]}function Jb(a,b){this.previousValue=a;this.currentValue=b}function va(a){return a.replace(od,\"\").replace(Ag,function(a,d,c){return c?d.toUpperCase():d})}function rd(a,b){var d=\"\",c=a.split(/\\s+/),\ne=b.split(/\\s+/),f=0;a:for(;f<c.length;f++){for(var g=c[f],k=0;k<e.length;k++)if(g===e[k])continue a;d+=(0<d.length?\" \":\"\")+g}return d}function qd(a){a=y(a);var b=a.length;if(1>=b)return a;for(;b--;){var d=a[b];(8===d.nodeType||d.nodeType===Oa&&\"\"===d.nodeValue.trim())&&Bg.call(a,b,1)}return a}function xg(a,b){if(b&&C(b))return b;if(C(a)){var d=td.exec(a);if(d)return d[3]}}function Bf(){var a={};this.has=function(b){return a.hasOwnProperty(b)};this.register=function(b,d){Qa(b,\"controller\");F(b)?R(a,\nb):a[b]=d};this.$get=[\"$injector\",function(b){function d(a,b,d,g){if(!a||!F(a.$scope))throw M(\"$controller\")(\"noscp\",g,b);a.$scope[b]=d}return function(c,e,f,g){var k,h,l;f=!0===f;g&&C(g)&&(l=g);if(C(c)){g=c.match(td);if(!g)throw ud(\"ctrlfmt\",c);h=g[1];l=l||g[3];c=a.hasOwnProperty(h)?a[h]:De(e.$scope,h,!0);if(!c)throw ud(\"ctrlreg\",h);sb(c,h,!0)}if(f)return f=(I(c)?c[c.length-1]:c).prototype,k=Object.create(f||null),l&&d(e,l,k,h||c.name),R(function(){var a=b.invoke(c,k,e,h);a!==k&&(F(a)||z(a))&&(k=\na,l&&d(e,l,k,h||c.name));return k},{instance:k,identifier:l});k=b.instantiate(c,e,h);l&&d(e,l,k,h||c.name);return k}}]}function Cf(){this.$get=[\"$window\",function(a){return y(a.document)}]}function Df(){this.$get=[\"$document\",\"$rootScope\",function(a,b){function d(){e=c.hidden}var c=a[0],e=c&&c.hidden;a.on(\"visibilitychange\",d);b.$on(\"$destroy\",function(){a.off(\"visibilitychange\",d)});return function(){return e}}]}function Ef(){this.$get=[\"$log\",function(a){return function(b,d){a.error.apply(a,arguments)}}]}\nfunction tc(a){return F(a)?ha(a)?a.toISOString():eb(a):a}function Kf(){this.$get=function(){return function(a){if(!a)return\"\";var b=[];Nc(a,function(a,c){null===a||x(a)||z(a)||(I(a)?r(a,function(a){b.push(ca(c)+\"=\"+ca(tc(a)))}):b.push(ca(c)+\"=\"+ca(tc(a))))});return b.join(\"&\")}}}function Lf(){this.$get=function(){return function(a){function b(a,e,f){I(a)?r(a,function(a,c){b(a,e+\"[\"+(F(a)?c:\"\")+\"]\")}):F(a)&&!ha(a)?Nc(a,function(a,c){b(a,e+(f?\"\":\"[\")+c+(f?\"\":\"]\"))}):(z(a)&&(a=a()),d.push(ca(e)+\"=\"+\n(null==a?\"\":ca(tc(a)))))}if(!a)return\"\";var d=[];b(a,\"\",!0);return d.join(\"&\")}}}function uc(a,b){if(C(a)){var d=a.replace(Cg,\"\").trim();if(d){var c=b(\"Content-Type\"),c=c&&0===c.indexOf(vd),e;(e=c)||(e=(e=d.match(Dg))&&Eg[e[0]].test(d));if(e)try{a=Qc(d)}catch(f){if(!c)return a;throw Kb(\"baddata\",a,f);}}}return a}function wd(a){var b=S(),d;C(a)?r(a.split(\"\\n\"),function(a){d=a.indexOf(\":\");var e=O(T(a.substr(0,d)));a=T(a.substr(d+1));e&&(b[e]=b[e]?b[e]+\", \"+a:a)}):F(a)&&r(a,function(a,d){var f=O(d),\ng=T(a);f&&(b[f]=b[f]?b[f]+\", \"+g:g)});return b}function xd(a){var b;return function(d){b||(b=wd(a));return d?(d=b[O(d)],void 0===d&&(d=null),d):b}}function yd(a,b,d,c){if(z(c))return c(a,b,d);r(c,function(c){a=c(a,b,d)});return a}function Jf(){var a=this.defaults={transformResponse:[uc],transformRequest:[function(a){return F(a)&&\"[object File]\"!==ma.call(a)&&\"[object Blob]\"!==ma.call(a)&&\"[object FormData]\"!==ma.call(a)?eb(a):a}],headers:{common:{Accept:\"application/json, text/plain, */*\"},post:oa(vc),\nput:oa(vc),patch:oa(vc)},xsrfCookieName:\"XSRF-TOKEN\",xsrfHeaderName:\"X-XSRF-TOKEN\",paramSerializer:\"$httpParamSerializer\",jsonpCallbackParam:\"callback\"},b=!1;this.useApplyAsync=function(a){return v(a)?(b=!!a,this):b};var d=this.interceptors=[],c=this.xsrfWhitelistedOrigins=[];this.$get=[\"$browser\",\"$httpBackend\",\"$$cookieReader\",\"$cacheFactory\",\"$rootScope\",\"$q\",\"$injector\",\"$sce\",function(e,f,g,k,h,l,m,q){function n(b){function c(a,b){for(var d=0,e=b.length;d<e;){var f=b[d++],g=b[d++];a=a.then(f,\ng)}b.length=0;return a}function d(a,b){var c,e={};r(a,function(a,d){z(a)?(c=a(b),null!=c&&(e[d]=c)):e[d]=a});return e}function f(a){var b=R({},a);b.data=yd(a.data,a.headers,a.status,g.transformResponse);a=a.status;return 200<=a&&300>a?b:l.reject(b)}if(!F(b))throw M(\"$http\")(\"badreq\",b);if(!C(q.valueOf(b.url)))throw M(\"$http\")(\"badreq\",b.url);var g=R({method:\"get\",transformRequest:a.transformRequest,transformResponse:a.transformResponse,paramSerializer:a.paramSerializer,jsonpCallbackParam:a.jsonpCallbackParam},\nb);g.headers=function(b){var c=a.headers,e=R({},b.headers),f,g,h,c=R({},c.common,c[O(b.method)]);a:for(f in c){g=O(f);for(h in e)if(O(h)===g)continue a;e[f]=c[f]}return d(e,oa(b))}(b);g.method=ub(g.method);g.paramSerializer=C(g.paramSerializer)?m.get(g.paramSerializer):g.paramSerializer;e.$$incOutstandingRequestCount(\"$http\");var h=[],k=[];b=l.resolve(g);r(w,function(a){(a.request||a.requestError)&&h.unshift(a.request,a.requestError);(a.response||a.responseError)&&k.push(a.response,a.responseError)});\nb=c(b,h);b=b.then(function(b){var c=b.headers,d=yd(b.data,xd(c),void 0,b.transformRequest);x(d)&&r(c,function(a,b){\"content-type\"===O(b)&&delete c[b]});x(b.withCredentials)&&!x(a.withCredentials)&&(b.withCredentials=a.withCredentials);return s(b,d).then(f,f)});b=c(b,k);return b=b.finally(function(){e.$$completeOutstandingRequest(A,\"$http\")})}function s(c,d){function e(a){if(a){var c={};r(a,function(a,d){c[d]=function(c){function d(){a(c)}b?h.$applyAsync(d):h.$$phase?d():h.$apply(d)}});return c}}function k(a,\nc,d,e,f){function g(){m(c,a,d,e,f)}Q&&(200<=a&&300>a?Q.put(N,[a,c,wd(d),e,f]):Q.remove(N));b?h.$applyAsync(g):(g(),h.$$phase||h.$apply())}function m(a,b,d,e,f){b=-1<=b?b:0;(200<=b&&300>b?L.resolve:L.reject)({data:a,status:b,headers:xd(d),config:c,statusText:e,xhrStatus:f})}function s(a){m(a.data,a.status,oa(a.headers()),a.statusText,a.xhrStatus)}function w(){var a=n.pendingRequests.indexOf(c);-1!==a&&n.pendingRequests.splice(a,1)}var L=l.defer(),P=L.promise,Q,p,na=c.headers,y=\"jsonp\"===O(c.method),\nN=c.url;y?N=q.getTrustedResourceUrl(N):C(N)||(N=q.valueOf(N));N=t(N,c.paramSerializer(c.params));y&&(N=u(N,c.jsonpCallbackParam));n.pendingRequests.push(c);P.then(w,w);!c.cache&&!a.cache||!1===c.cache||\"GET\"!==c.method&&\"JSONP\"!==c.method||(Q=F(c.cache)?c.cache:F(a.cache)?a.cache:D);Q&&(p=Q.get(N),v(p)?p&&z(p.then)?p.then(s,s):I(p)?m(p[1],p[0],oa(p[2]),p[3],p[4]):m(p,200,{},\"OK\",\"complete\"):Q.put(N,P));x(p)&&((p=ic(c.url)?g()[c.xsrfCookieName||a.xsrfCookieName]:void 0)&&(na[c.xsrfHeaderName||a.xsrfHeaderName]=\np),f(c.method,N,d,k,na,c.timeout,c.withCredentials,c.responseType,e(c.eventHandlers),e(c.uploadEventHandlers)));return P}function t(a,b){0<b.length&&(a+=(-1===a.indexOf(\"?\")?\"?\":\"&\")+b);return a}function u(a,b){var c=a.split(\"?\");if(2<c.length)throw Kb(\"badjsonp\",a);c=fc(c[1]);r(c,function(c,d){if(\"JSON_CALLBACK\"===c)throw Kb(\"badjsonp\",a);if(d===b)throw Kb(\"badjsonp\",b,a);});return a+=(-1===a.indexOf(\"?\")?\"?\":\"&\")+b+\"=JSON_CALLBACK\"}var D=k(\"$http\");a.paramSerializer=C(a.paramSerializer)?m.get(a.paramSerializer):\na.paramSerializer;var w=[];r(d,function(a){w.unshift(C(a)?m.get(a):m.invoke(a))});var ic=Fg(c);n.pendingRequests=[];(function(a){r(arguments,function(a){n[a]=function(b,c){return n(R({},c||{},{method:a,url:b}))}})})(\"get\",\"delete\",\"head\",\"jsonp\");(function(a){r(arguments,function(a){n[a]=function(b,c,d){return n(R({},d||{},{method:a,url:b,data:c}))}})})(\"post\",\"put\",\"patch\");n.defaults=a;return n}]}function Nf(){this.$get=function(){return function(){return new B.XMLHttpRequest}}}function Mf(){this.$get=\n[\"$browser\",\"$jsonpCallbacks\",\"$document\",\"$xhrFactory\",function(a,b,d,c){return Gg(a,c,a.defer,b,d[0])}]}function Gg(a,b,d,c,e){function f(a,b,d){a=a.replace(\"JSON_CALLBACK\",b);var f=e.createElement(\"script\"),m=null;f.type=\"text/javascript\";f.src=a;f.async=!0;m=function(a){f.removeEventListener(\"load\",m);f.removeEventListener(\"error\",m);e.body.removeChild(f);f=null;var g=-1,s=\"unknown\";a&&(\"load\"!==a.type||c.wasCalled(b)||(a={type:\"error\"}),s=a.type,g=\"error\"===a.type?404:200);d&&d(g,s)};f.addEventListener(\"load\",\nm);f.addEventListener(\"error\",m);e.body.appendChild(f);return m}return function(e,k,h,l,m,q,n,s,t,u){function D(a){G=\"timeout\"===a;Z&&Z();E&&E.abort()}function w(a,b,c,e,f,g){v(H)&&d.cancel(H);Z=E=null;a(b,c,e,f,g)}k=k||a.url();if(\"jsonp\"===O(e))var p=c.createCallback(k),Z=f(k,p,function(a,b){var d=200===a&&c.getResponse(p);w(l,a,d,\"\",b,\"complete\");c.removeCallback(p)});else{var E=b(e,k),G=!1;E.open(e,k,!0);r(m,function(a,b){v(a)&&E.setRequestHeader(b,a)});E.onload=function(){var a=E.statusText||\n\"\",b=\"response\"in E?E.response:E.responseText,c=1223===E.status?204:E.status;0===c&&(c=b?200:\"file\"===la(k).protocol?404:0);w(l,c,b,E.getAllResponseHeaders(),a,\"complete\")};E.onerror=function(){w(l,-1,null,null,\"\",\"error\")};E.ontimeout=function(){w(l,-1,null,null,\"\",\"timeout\")};E.onabort=function(){w(l,-1,null,null,\"\",G?\"timeout\":\"abort\")};r(t,function(a,b){E.addEventListener(b,a)});r(u,function(a,b){E.upload.addEventListener(b,a)});n&&(E.withCredentials=!0);if(s)try{E.responseType=s}catch(J){if(\"json\"!==\ns)throw J;}E.send(x(h)?null:h)}if(0<q)var H=d(function(){D(\"timeout\")},q);else q&&z(q.then)&&q.then(function(){D(v(q.$$timeoutId)?\"timeout\":\"abort\")})}}function Gf(){var a=\"{{\",b=\"}}\";this.startSymbol=function(b){return b?(a=b,this):a};this.endSymbol=function(a){return a?(b=a,this):b};this.$get=[\"$parse\",\"$exceptionHandler\",\"$sce\",function(d,c,e){function f(a){return\"\\\\\\\\\\\\\"+a}function g(c){return c.replace(q,a).replace(n,b)}function k(a,b,c,d){var e=a.$watch(function(a){e();return d(a)},b,c);return e}\nfunction h(f,h,n,q){function w(a){try{return a=n&&!r?e.getTrusted(n,a):e.valueOf(a),q&&!v(a)?a:hc(a)}catch(b){c(Ca.interr(f,b))}}var r=n===e.URL||n===e.MEDIA_URL;if(!f.length||-1===f.indexOf(a)){if(h&&!r)return;h=g(f);r&&(h=e.getTrusted(n,h));h=ia(h);h.exp=f;h.expressions=[];h.$$watchDelegate=k;return h}q=!!q;for(var p,E,G=0,J=[],H,X=f.length,K=[],L=[],P;G<X;)if(-1!==(p=f.indexOf(a,G))&&-1!==(E=f.indexOf(b,p+l)))G!==p&&K.push(g(f.substring(G,p))),G=f.substring(p+l,E),J.push(G),G=E+m,L.push(K.length),\nK.push(\"\");else{G!==X&&K.push(g(f.substring(G)));break}P=1===K.length&&1===L.length;var Q=r&&P?void 0:w;H=J.map(function(a){return d(a,Q)});if(!h||J.length){var y=function(a){for(var b=0,c=J.length;b<c;b++){if(q&&x(a[b]))return;K[L[b]]=a[b]}if(r)return e.getTrusted(n,P?K[0]:K.join(\"\"));n&&1<K.length&&Ca.throwNoconcat(f);return K.join(\"\")};return R(function(a){var b=0,d=J.length,e=Array(d);try{for(;b<d;b++)e[b]=H[b](a);return y(e)}catch(g){c(Ca.interr(f,g))}},{exp:f,expressions:J,$$watchDelegate:function(a,\nb){var c;return a.$watchGroup(H,function(d,e){var f=y(d);b.call(this,f,d!==e?c:f,a);c=f})}})}}var l=a.length,m=b.length,q=new RegExp(a.replace(/./g,f),\"g\"),n=new RegExp(b.replace(/./g,f),\"g\");h.startSymbol=function(){return a};h.endSymbol=function(){return b};return h}]}function Hf(){this.$get=[\"$$intervalFactory\",\"$window\",function(a,b){var d={},c=function(a){b.clearInterval(a);delete d[a]},e=a(function(a,c,e){a=b.setInterval(a,c);d[a]=e;return a},c);e.cancel=function(a){if(!a)return!1;if(!a.hasOwnProperty(\"$$intervalId\"))throw Hg(\"badprom\");\nif(!d.hasOwnProperty(a.$$intervalId))return!1;a=a.$$intervalId;var b=d[a];b.promise.$$state.pur=!0;b.reject(\"canceled\");c(a);return!0};return e}]}function If(){this.$get=[\"$browser\",\"$q\",\"$$q\",\"$rootScope\",function(a,b,d,c){return function(e,f){return function(g,k,h,l){function m(){q?g.apply(null,n):g(s)}var q=4<arguments.length,n=q?Ga.call(arguments,4):[],s=0,t=v(l)&&!l,u=(t?d:b).defer(),D=u.promise;h=v(h)?h:0;D.$$intervalId=e(function(){t?a.defer(m):c.$evalAsync(m);u.notify(s++);0<h&&s>=h&&(u.resolve(s),\nf(D.$$intervalId));t||c.$apply()},k,u,t);return D}}}]}function zd(a,b){var d=la(a);b.$$protocol=d.protocol;b.$$host=d.hostname;b.$$port=da(d.port)||Ig[d.protocol]||null}function Ad(a,b,d){if(Jg.test(a))throw jb(\"badpath\",a);var c=\"/\"!==a.charAt(0);c&&(a=\"/\"+a);a=la(a);for(var c=(c&&\"/\"===a.pathname.charAt(0)?a.pathname.substring(1):a.pathname).split(\"/\"),e=c.length;e--;)c[e]=decodeURIComponent(c[e]),d&&(c[e]=c[e].replace(/\\//g,\"%2F\"));d=c.join(\"/\");b.$$path=d;b.$$search=fc(a.search);b.$$hash=decodeURIComponent(a.hash);\nb.$$path&&\"/\"!==b.$$path.charAt(0)&&(b.$$path=\"/\"+b.$$path)}function wc(a,b){return a.slice(0,b.length)===b}function wa(a,b){if(wc(b,a))return b.substr(a.length)}function qa(a){var b=a.indexOf(\"#\");return-1===b?a:a.substr(0,b)}function xc(a,b,d){this.$$html5=!0;d=d||\"\";zd(a,this);this.$$parse=function(a){var d=wa(b,a);if(!C(d))throw jb(\"ipthprfx\",a,b);Ad(d,this,!0);this.$$path||(this.$$path=\"/\");this.$$compose()};this.$$normalizeUrl=function(a){return b+a.substr(1)};this.$$parseLinkUrl=function(c,\ne){if(e&&\"#\"===e[0])return this.hash(e.slice(1)),!0;var f,g;v(f=wa(a,c))?(g=f,g=d&&v(f=wa(d,f))?b+(wa(\"/\",f)||f):a+g):v(f=wa(b,c))?g=b+f:b===c+\"/\"&&(g=b);g&&this.$$parse(g);return!!g}}function yc(a,b,d){zd(a,this);this.$$parse=function(c){var e=wa(a,c)||wa(b,c),f;x(e)||\"#\"!==e.charAt(0)?this.$$html5?f=e:(f=\"\",x(e)&&(a=c,this.replace())):(f=wa(d,e),x(f)&&(f=e));Ad(f,this,!1);c=this.$$path;var e=a,g=/^\\/[A-Z]:(\\/.*)/;wc(f,e)&&(f=f.replace(e,\"\"));g.exec(f)||(c=(f=g.exec(c))?f[1]:c);this.$$path=c;this.$$compose()};\nthis.$$normalizeUrl=function(b){return a+(b?d+b:\"\")};this.$$parseLinkUrl=function(b,d){return qa(a)===qa(b)?(this.$$parse(b),!0):!1}}function Bd(a,b,d){this.$$html5=!0;yc.apply(this,arguments);this.$$parseLinkUrl=function(c,e){if(e&&\"#\"===e[0])return this.hash(e.slice(1)),!0;var f,g;a===qa(c)?f=c:(g=wa(b,c))?f=a+d+g:b===c+\"/\"&&(f=b);f&&this.$$parse(f);return!!f};this.$$normalizeUrl=function(b){return a+d+b}}function Lb(a){return function(){return this[a]}}function Cd(a,b){return function(d){if(x(d))return this[a];\nthis[a]=b(d);this.$$compose();return this}}function Pf(){var a=\"!\",b={enabled:!1,requireBase:!0,rewriteLinks:!0};this.hashPrefix=function(b){return v(b)?(a=b,this):a};this.html5Mode=function(a){if(Fa(a))return b.enabled=a,this;if(F(a)){Fa(a.enabled)&&(b.enabled=a.enabled);Fa(a.requireBase)&&(b.requireBase=a.requireBase);if(Fa(a.rewriteLinks)||C(a.rewriteLinks))b.rewriteLinks=a.rewriteLinks;return this}return b};this.$get=[\"$rootScope\",\"$browser\",\"$sniffer\",\"$rootElement\",\"$window\",function(d,c,e,\nf,g){function k(a,b){return a===b||la(a).href===la(b).href}function h(a,b,d){var e=m.url(),f=m.$$state;try{c.url(a,b,d),m.$$state=c.state()}catch(g){throw m.url(e),m.$$state=f,g;}}function l(a,b){d.$broadcast(\"$locationChangeSuccess\",m.absUrl(),a,m.$$state,b)}var m,q;q=c.baseHref();var n=c.url(),s;if(b.enabled){if(!q&&b.requireBase)throw jb(\"nobase\");s=n.substring(0,n.indexOf(\"/\",n.indexOf(\"//\")+2))+(q||\"/\");q=e.history?xc:Bd}else s=qa(n),q=yc;var t=s.substr(0,qa(s).lastIndexOf(\"/\")+1);m=new q(s,\nt,\"#\"+a);m.$$parseLinkUrl(n,n);m.$$state=c.state();var u=/^\\s*(javascript|mailto):/i;f.on(\"click\",function(a){var e=b.rewriteLinks;if(e&&!a.ctrlKey&&!a.metaKey&&!a.shiftKey&&2!==a.which&&2!==a.button){for(var g=y(a.target);\"a\"!==ta(g[0]);)if(g[0]===f[0]||!(g=g.parent())[0])return;if(!C(e)||!x(g.attr(e))){var e=g.prop(\"href\"),h=g.attr(\"href\")||g.attr(\"xlink:href\");F(e)&&\"[object SVGAnimatedString]\"===e.toString()&&(e=la(e.animVal).href);u.test(e)||!e||g.attr(\"target\")||a.isDefaultPrevented()||!m.$$parseLinkUrl(e,\nh)||(a.preventDefault(),m.absUrl()!==c.url()&&d.$apply())}}});m.absUrl()!==n&&c.url(m.absUrl(),!0);var D=!0;c.onUrlChange(function(a,b){wc(a,t)?(d.$evalAsync(function(){var c=m.absUrl(),e=m.$$state,f;m.$$parse(a);m.$$state=b;f=d.$broadcast(\"$locationChangeStart\",a,c,b,e).defaultPrevented;m.absUrl()===a&&(f?(m.$$parse(c),m.$$state=e,h(c,!1,e)):(D=!1,l(c,e)))}),d.$$phase||d.$digest()):g.location.href=a});d.$watch(function(){if(D||m.$$urlUpdatedByLocation){m.$$urlUpdatedByLocation=!1;var a=c.url(),b=\nm.absUrl(),f=c.state(),g=m.$$replace,n=!k(a,b)||m.$$html5&&e.history&&f!==m.$$state;if(D||n)D=!1,d.$evalAsync(function(){var b=m.absUrl(),c=d.$broadcast(\"$locationChangeStart\",b,a,m.$$state,f).defaultPrevented;m.absUrl()===b&&(c?(m.$$parse(a),m.$$state=f):(n&&h(b,g,f===m.$$state?null:m.$$state),l(a,f)))})}m.$$replace=!1});return m}]}function Qf(){var a=!0,b=this;this.debugEnabled=function(b){return v(b)?(a=b,this):a};this.$get=[\"$window\",function(d){function c(a){bc(a)&&(a.stack&&f?a=a.message&&-1===\na.stack.indexOf(a.message)?\"Error: \"+a.message+\"\\n\"+a.stack:a.stack:a.sourceURL&&(a=a.message+\"\\n\"+a.sourceURL+\":\"+a.line));return a}function e(a){var b=d.console||{},e=b[a]||b.log||A;return function(){var a=[];r(arguments,function(b){a.push(c(b))});return Function.prototype.apply.call(e,b,a)}}var f=Aa||/\\bEdge\\//.test(d.navigator&&d.navigator.userAgent);return{log:e(\"log\"),info:e(\"info\"),warn:e(\"warn\"),error:e(\"error\"),debug:function(){var c=e(\"debug\");return function(){a&&c.apply(b,arguments)}}()}}]}\nfunction Kg(a){return a+\"\"}function Lg(a,b){return\"undefined\"!==typeof a?a:b}function Dd(a,b){return\"undefined\"===typeof a?b:\"undefined\"===typeof b?a:a+b}function Mg(a,b){switch(a.type){case p.MemberExpression:if(a.computed)return!1;break;case p.UnaryExpression:return 1;case p.BinaryExpression:return\"+\"!==a.operator?1:!1;case p.CallExpression:return!1}return void 0===b?Ed:b}function Y(a,b,d){var c,e,f=a.isPure=Mg(a,d);switch(a.type){case p.Program:c=!0;r(a.body,function(a){Y(a.expression,b,f);c=c&&\na.expression.constant});a.constant=c;break;case p.Literal:a.constant=!0;a.toWatch=[];break;case p.UnaryExpression:Y(a.argument,b,f);a.constant=a.argument.constant;a.toWatch=a.argument.toWatch;break;case p.BinaryExpression:Y(a.left,b,f);Y(a.right,b,f);a.constant=a.left.constant&&a.right.constant;a.toWatch=a.left.toWatch.concat(a.right.toWatch);break;case p.LogicalExpression:Y(a.left,b,f);Y(a.right,b,f);a.constant=a.left.constant&&a.right.constant;a.toWatch=a.constant?[]:[a];break;case p.ConditionalExpression:Y(a.test,\nb,f);Y(a.alternate,b,f);Y(a.consequent,b,f);a.constant=a.test.constant&&a.alternate.constant&&a.consequent.constant;a.toWatch=a.constant?[]:[a];break;case p.Identifier:a.constant=!1;a.toWatch=[a];break;case p.MemberExpression:Y(a.object,b,f);a.computed&&Y(a.property,b,f);a.constant=a.object.constant&&(!a.computed||a.property.constant);a.toWatch=a.constant?[]:[a];break;case p.CallExpression:c=d=a.filter?!b(a.callee.name).$stateful:!1;e=[];r(a.arguments,function(a){Y(a,b,f);c=c&&a.constant;e.push.apply(e,\na.toWatch)});a.constant=c;a.toWatch=d?e:[a];break;case p.AssignmentExpression:Y(a.left,b,f);Y(a.right,b,f);a.constant=a.left.constant&&a.right.constant;a.toWatch=[a];break;case p.ArrayExpression:c=!0;e=[];r(a.elements,function(a){Y(a,b,f);c=c&&a.constant;e.push.apply(e,a.toWatch)});a.constant=c;a.toWatch=e;break;case p.ObjectExpression:c=!0;e=[];r(a.properties,function(a){Y(a.value,b,f);c=c&&a.value.constant;e.push.apply(e,a.value.toWatch);a.computed&&(Y(a.key,b,!1),c=c&&a.key.constant,e.push.apply(e,\na.key.toWatch))});a.constant=c;a.toWatch=e;break;case p.ThisExpression:a.constant=!1;a.toWatch=[];break;case p.LocalsExpression:a.constant=!1,a.toWatch=[]}}function Fd(a){if(1===a.length){a=a[0].expression;var b=a.toWatch;return 1!==b.length?b:b[0]!==a?b:void 0}}function Gd(a){return a.type===p.Identifier||a.type===p.MemberExpression}function Hd(a){if(1===a.body.length&&Gd(a.body[0].expression))return{type:p.AssignmentExpression,left:a.body[0].expression,right:{type:p.NGValueParameter},operator:\"=\"}}\nfunction Id(a){this.$filter=a}function Jd(a){this.$filter=a}function Mb(a,b,d){this.ast=new p(a,d);this.astCompiler=d.csp?new Jd(b):new Id(b)}function zc(a){return z(a.valueOf)?a.valueOf():Ng.call(a)}function Rf(){var a=S(),b={\"true\":!0,\"false\":!1,\"null\":null,undefined:void 0},d,c;this.addLiteral=function(a,c){b[a]=c};this.setIdentifierFns=function(a,b){d=a;c=b;return this};this.$get=[\"$filter\",function(e){function f(b,c){var d,f;switch(typeof b){case \"string\":return f=b=b.trim(),d=a[f],d||(d=new Nb(t),\nd=(new Mb(d,e,t)).parse(b),a[f]=q(d)),s(d,c);case \"function\":return s(b,c);default:return s(A,c)}}function g(a,b,c){return null==a||null==b?a===b:\"object\"!==typeof a||(a=zc(a),\"object\"!==typeof a||c)?a===b||a!==a&&b!==b:!1}function k(a,b,c,d,e){var f=d.inputs,h;if(1===f.length){var k=g,f=f[0];return a.$watch(function(a){var b=f(a);g(b,k,f.isPure)||(h=d(a,void 0,void 0,[b]),k=b&&zc(b));return h},b,c,e)}for(var l=[],m=[],n=0,q=f.length;n<q;n++)l[n]=g,m[n]=null;return a.$watch(function(a){for(var b=\n!1,c=0,e=f.length;c<e;c++){var k=f[c](a);if(b||(b=!g(k,l[c],f[c].isPure)))m[c]=k,l[c]=k&&zc(k)}b&&(h=d(a,void 0,void 0,m));return h},b,c,e)}function h(a,b,c,d,e){function f(){h(m)&&k()}function g(a,b,c,d){m=s&&d?d[0]:n(a,b,c,d);h(m)&&a.$$postDigest(f);return t(m)}var h=d.literal?l:v,k,m,n=d.$$intercepted||d,t=d.$$interceptor||Ta,s=d.inputs&&!n.inputs;g.literal=d.literal;g.constant=d.constant;g.inputs=d.inputs;q(g);return k=a.$watch(g,b,c,e)}function l(a){var b=!0;r(a,function(a){v(a)||(b=!1)});return b}\nfunction m(a,b,c,d){var e=a.$watch(function(a){e();return d(a)},b,c);return e}function q(a){a.constant?a.$$watchDelegate=m:a.oneTime?a.$$watchDelegate=h:a.inputs&&(a.$$watchDelegate=k);return a}function n(a,b){function c(d){return b(a(d))}c.$stateful=a.$stateful||b.$stateful;c.$$pure=a.$$pure&&b.$$pure;return c}function s(a,b){if(!b)return a;a.$$interceptor&&(b=n(a.$$interceptor,b),a=a.$$intercepted);var c=!1,d=function(d,e,f,g){d=c&&g?g[0]:a(d,e,f,g);return b(d)};d.$$intercepted=a;d.$$interceptor=\nb;d.literal=a.literal;d.oneTime=a.oneTime;d.constant=a.constant;b.$stateful||(c=!a.inputs,d.inputs=a.inputs?a.inputs:[a],b.$$pure||(d.inputs=d.inputs.map(function(a){return a.isPure===Ed?function(b){return a(b)}:a})));return q(d)}var t={csp:pa().noUnsafeEval,literals:Ha(b),isIdentifierStart:z(d)&&d,isIdentifierContinue:z(c)&&c};f.$$getAst=function(a){var b=new Nb(t);return(new Mb(b,e,t)).getAst(a).ast};return f}]}function Tf(){var a=!0;this.$get=[\"$rootScope\",\"$exceptionHandler\",function(b,d){return Kd(function(a){b.$evalAsync(a)},\nd,a)}];this.errorOnUnhandledRejections=function(b){return v(b)?(a=b,this):a}}function Uf(){var a=!0;this.$get=[\"$browser\",\"$exceptionHandler\",function(b,d){return Kd(function(a){b.defer(a)},d,a)}];this.errorOnUnhandledRejections=function(b){return v(b)?(a=b,this):a}}function Kd(a,b,d){function c(){return new e}function e(){var a=this.promise=new f;this.resolve=function(b){h(a,b)};this.reject=function(b){m(a,b)};this.notify=function(b){n(a,b)}}function f(){this.$$state={status:0}}function g(){for(;!v&&\nZ.length;){var a=Z.shift();if(!a.pur){a.pur=!0;var c=a.value,c=\"Possibly unhandled rejection: \"+(\"function\"===typeof c?c.toString().replace(/ \\{[\\s\\S]*$/,\"\"):x(c)?\"undefined\":\"string\"!==typeof c?Fe(c,void 0):c);bc(a.value)?b(a.value,c):b(c)}}}function k(c){!d||c.pending||2!==c.status||c.pur||(0===v&&0===Z.length&&a(g),Z.push(c));!c.processScheduled&&c.pending&&(c.processScheduled=!0,++v,a(function(){var e,f,k;k=c.pending;c.processScheduled=!1;c.pending=void 0;try{for(var l=0,n=k.length;l<n;++l){c.pur=\n!0;f=k[l][0];e=k[l][c.status];try{z(e)?h(f,e(c.value)):1===c.status?h(f,c.value):m(f,c.value)}catch(q){m(f,q),q&&!0===q.$$passToExceptionHandler&&b(q)}}}finally{--v,d&&0===v&&a(g)}}))}function h(a,b){a.$$state.status||(b===a?q(a,w(\"qcycle\",b)):l(a,b))}function l(a,b){function c(b){g||(g=!0,l(a,b))}function d(b){g||(g=!0,q(a,b))}function e(b){n(a,b)}var f,g=!1;try{if(F(b)||z(b))f=b.then;z(f)?(a.$$state.status=-1,f.call(b,c,d,e)):(a.$$state.value=b,a.$$state.status=1,k(a.$$state))}catch(h){d(h)}}function m(a,\nb){a.$$state.status||q(a,b)}function q(a,b){a.$$state.value=b;a.$$state.status=2;k(a.$$state)}function n(c,d){var e=c.$$state.pending;0>=c.$$state.status&&e&&e.length&&a(function(){for(var a,c,f=0,g=e.length;f<g;f++){c=e[f][0];a=e[f][3];try{n(c,z(a)?a(d):d)}catch(h){b(h)}}})}function s(a){var b=new f;m(b,a);return b}function t(a,b,c){var d=null;try{z(c)&&(d=c())}catch(e){return s(e)}return d&&z(d.then)?d.then(function(){return b(a)},s):b(a)}function u(a,b,c,d){var e=new f;h(e,a);return e.then(b,c,\nd)}function p(a){if(!z(a))throw w(\"norslvr\",a);var b=new f;a(function(a){h(b,a)},function(a){m(b,a)});return b}var w=M(\"$q\",TypeError),v=0,Z=[];R(f.prototype,{then:function(a,b,c){if(x(a)&&x(b)&&x(c))return this;var d=new f;this.$$state.pending=this.$$state.pending||[];this.$$state.pending.push([d,a,b,c]);0<this.$$state.status&&k(this.$$state);return d},\"catch\":function(a){return this.then(null,a)},\"finally\":function(a,b){return this.then(function(b){return t(b,E,a)},function(b){return t(b,s,a)},\nb)}});var E=u;p.prototype=f.prototype;p.defer=c;p.reject=s;p.when=u;p.resolve=E;p.all=function(a){var b=new f,c=0,d=I(a)?[]:{};r(a,function(a,e){c++;u(a).then(function(a){d[e]=a;--c||h(b,d)},function(a){m(b,a)})});0===c&&h(b,d);return b};p.race=function(a){var b=c();r(a,function(a){u(a).then(b.resolve,b.reject)});return b.promise};return p}function dg(){this.$get=[\"$window\",\"$timeout\",function(a,b){var d=a.requestAnimationFrame||a.webkitRequestAnimationFrame,c=a.cancelAnimationFrame||a.webkitCancelAnimationFrame||\na.webkitCancelRequestAnimationFrame,e=!!d,f=e?function(a){var b=d(a);return function(){c(b)}}:function(a){var c=b(a,16.66,!1);return function(){b.cancel(c)}};f.supported=e;return f}]}function Sf(){function a(a){function b(){this.$$watchers=this.$$nextSibling=this.$$childHead=this.$$childTail=null;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$id=++pb;this.$$ChildScope=null;this.$$suspended=!1}b.prototype=a;return b}var b=10,d=M(\"$rootScope\"),c=null,e=null;this.digestTtl=\nfunction(a){arguments.length&&(b=a);return b};this.$get=[\"$exceptionHandler\",\"$parse\",\"$browser\",function(f,g,k){function h(a){a.currentScope.$$destroyed=!0}function l(a){9===Aa&&(a.$$childHead&&l(a.$$childHead),a.$$nextSibling&&l(a.$$nextSibling));a.$parent=a.$$nextSibling=a.$$prevSibling=a.$$childHead=a.$$childTail=a.$root=a.$$watchers=null}function m(){this.$id=++pb;this.$$phase=this.$parent=this.$$watchers=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=null;this.$root=\nthis;this.$$suspended=this.$$destroyed=!1;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$$isolateBindings=null}function q(a){if(w.$$phase)throw d(\"inprog\",w.$$phase);w.$$phase=a}function n(a,b){do a.$$watchersCount+=b;while(a=a.$parent)}function s(a,b,c){do a.$$listenerCount[c]-=b,0===a.$$listenerCount[c]&&delete a.$$listenerCount[c];while(a=a.$parent)}function t(){}function u(){for(;E.length;)try{E.shift()()}catch(a){f(a)}e=null}function p(){null===e&&(e=k.defer(function(){w.$apply(u)},\nnull,\"$applyAsync\"))}m.prototype={constructor:m,$new:function(b,c){var d;c=c||this;b?(d=new m,d.$root=this.$root):(this.$$ChildScope||(this.$$ChildScope=a(this)),d=new this.$$ChildScope);d.$parent=c;d.$$prevSibling=c.$$childTail;c.$$childHead?(c.$$childTail.$$nextSibling=d,c.$$childTail=d):c.$$childHead=c.$$childTail=d;(b||c!==this)&&d.$on(\"$destroy\",h);return d},$watch:function(a,b,d,e){var f=g(a);b=z(b)?b:A;if(f.$$watchDelegate)return f.$$watchDelegate(this,b,d,f,a);var h=this,k=h.$$watchers,l=\n{fn:b,last:t,get:f,exp:e||a,eq:!!d};c=null;k||(k=h.$$watchers=[],k.$$digestWatchIndex=-1);k.unshift(l);k.$$digestWatchIndex++;n(this,1);return function(){var a=cb(k,l);0<=a&&(n(h,-1),a<k.$$digestWatchIndex&&k.$$digestWatchIndex--);c=null}},$watchGroup:function(a,b){function c(){h=!1;try{k?(k=!1,b(e,e,g)):b(e,d,g)}finally{for(var f=0;f<a.length;f++)d[f]=e[f]}}var d=Array(a.length),e=Array(a.length),f=[],g=this,h=!1,k=!0;if(!a.length){var l=!0;g.$evalAsync(function(){l&&b(e,e,g)});return function(){l=\n!1}}if(1===a.length)return this.$watch(a[0],function(a,c,f){e[0]=a;d[0]=c;b(e,a===c?e:d,f)});r(a,function(a,b){var d=g.$watch(a,function(a){e[b]=a;h||(h=!0,g.$evalAsync(c))});f.push(d)});return function(){for(;f.length;)f.shift()()}},$watchCollection:function(a,b){function c(a){e=a;var b,d,g,h;if(!x(e)){if(F(e))if(xa(e))for(f!==n&&(f=n,s=f.length=0,l++),a=e.length,s!==a&&(l++,f.length=s=a),b=0;b<a;b++)h=f[b],g=e[b],d=h!==h&&g!==g,d||h===g||(l++,f[b]=g);else{f!==q&&(f=q={},s=0,l++);a=0;for(b in e)sa.call(e,\nb)&&(a++,g=e[b],h=f[b],b in f?(d=h!==h&&g!==g,d||h===g||(l++,f[b]=g)):(s++,f[b]=g,l++));if(s>a)for(b in l++,f)sa.call(e,b)||(s--,delete f[b])}else f!==e&&(f=e,l++);return l}}c.$$pure=g(a).literal;c.$stateful=!c.$$pure;var d=this,e,f,h,k=1<b.length,l=0,m=g(a,c),n=[],q={},t=!0,s=0;return this.$watch(m,function(){t?(t=!1,b(e,e,d)):b(e,h,d);if(k)if(F(e))if(xa(e)){h=Array(e.length);for(var a=0;a<e.length;a++)h[a]=e[a]}else for(a in h={},e)sa.call(e,a)&&(h[a]=e[a]);else h=e})},$digest:function(){var a,\ng,h,l,m,n,s,r=b,p,D=v.length?w:this,E=[],x,y;q(\"$digest\");k.$$checkUrlChange();this===w&&null!==e&&(k.defer.cancel(e),u());c=null;do{s=!1;p=D;for(n=0;n<v.length;n++){try{y=v[n],l=y.fn,l(y.scope,y.locals)}catch(C){f(C)}c=null}v.length=0;a:do{if(n=!p.$$suspended&&p.$$watchers)for(n.$$digestWatchIndex=n.length;n.$$digestWatchIndex--;)try{if(a=n[n.$$digestWatchIndex])if(m=a.get,(g=m(p))!==(h=a.last)&&!(a.eq?ua(g,h):V(g)&&V(h)))s=!0,c=a,a.last=a.eq?Ha(g,null):g,l=a.fn,l(g,h===t?g:h,p),5>r&&(x=4-r,E[x]||\n(E[x]=[]),E[x].push({msg:z(a.exp)?\"fn: \"+(a.exp.name||a.exp.toString()):a.exp,newVal:g,oldVal:h}));else if(a===c){s=!1;break a}}catch(B){f(B)}if(!(n=!p.$$suspended&&p.$$watchersCount&&p.$$childHead||p!==D&&p.$$nextSibling))for(;p!==D&&!(n=p.$$nextSibling);)p=p.$parent}while(p=n);if((s||v.length)&&!r--)throw w.$$phase=null,d(\"infdig\",b,E);}while(s||v.length);for(w.$$phase=null;G<Z.length;)try{Z[G++]()}catch(A){f(A)}Z.length=G=0;k.$$checkUrlChange()},$suspend:function(){this.$$suspended=!0},$isSuspended:function(){return this.$$suspended},\n$resume:function(){this.$$suspended=!1},$destroy:function(){if(!this.$$destroyed){var a=this.$parent;this.$broadcast(\"$destroy\");this.$$destroyed=!0;this===w&&k.$$applicationDestroyed();n(this,-this.$$watchersCount);for(var b in this.$$listenerCount)s(this,this.$$listenerCount[b],b);a&&a.$$childHead===this&&(a.$$childHead=this.$$nextSibling);a&&a.$$childTail===this&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=this.$$nextSibling);this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=\nthis.$$prevSibling);this.$destroy=this.$digest=this.$apply=this.$evalAsync=this.$applyAsync=A;this.$on=this.$watch=this.$watchGroup=function(){return A};this.$$listeners={};this.$$nextSibling=null;l(this)}},$eval:function(a,b){return g(a)(this,b)},$evalAsync:function(a,b){w.$$phase||v.length||k.defer(function(){v.length&&w.$digest()},null,\"$evalAsync\");v.push({scope:this,fn:g(a),locals:b})},$$postDigest:function(a){Z.push(a)},$apply:function(a){try{q(\"$apply\");try{return this.$eval(a)}finally{w.$$phase=\nnull}}catch(b){f(b)}finally{try{w.$digest()}catch(c){throw f(c),c;}}},$applyAsync:function(a){function b(){c.$eval(a)}var c=this;a&&E.push(b);a=g(a);p()},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);var d=this;do d.$$listenerCount[a]||(d.$$listenerCount[a]=0),d.$$listenerCount[a]++;while(d=d.$parent);var e=this;return function(){var d=c.indexOf(b);-1!==d&&(delete c[d],s(e,1,a))}},$emit:function(a,b){var c=[],d,e=this,g=!1,h={name:a,targetScope:e,stopPropagation:function(){g=\n!0},preventDefault:function(){h.defaultPrevented=!0},defaultPrevented:!1},k=db([h],arguments,1),l,m;do{d=e.$$listeners[a]||c;h.currentScope=e;l=0;for(m=d.length;l<m;l++)if(d[l])try{d[l].apply(null,k)}catch(n){f(n)}else d.splice(l,1),l--,m--;if(g)break;e=e.$parent}while(e);h.currentScope=null;return h},$broadcast:function(a,b){var c=this,d=this,e={name:a,targetScope:this,preventDefault:function(){e.defaultPrevented=!0},defaultPrevented:!1};if(!this.$$listenerCount[a])return e;for(var g=db([e],arguments,\n1),h,k;c=d;){e.currentScope=c;d=c.$$listeners[a]||[];h=0;for(k=d.length;h<k;h++)if(d[h])try{d[h].apply(null,g)}catch(l){f(l)}else d.splice(h,1),h--,k--;if(!(d=c.$$listenerCount[a]&&c.$$childHead||c!==this&&c.$$nextSibling))for(;c!==this&&!(d=c.$$nextSibling);)c=c.$parent}e.currentScope=null;return e}};var w=new m,v=w.$$asyncQueue=[],Z=w.$$postDigestQueue=[],E=w.$$applyAsyncQueue=[],G=0;return w}]}function Ie(){var a=/^\\s*(https?|s?ftp|mailto|tel|file):/,b=/^\\s*((https?|ftp|file|blob):|data:image\\/)/;\nthis.aHrefSanitizationWhitelist=function(b){return v(b)?(a=b,this):a};this.imgSrcSanitizationWhitelist=function(a){return v(a)?(b=a,this):b};this.$get=function(){return function(d,c){var e=c?b:a,f=la(d&&d.trim()).href;return\"\"===f||f.match(e)?d:\"unsafe:\"+f}}}function Og(a){if(\"self\"===a)return a;if(C(a)){if(-1<a.indexOf(\"***\"))throw Da(\"iwcard\",a);a=Ld(a).replace(/\\\\\\*\\\\\\*/g,\".*\").replace(/\\\\\\*/g,\"[^:/.?&;]*\");return new RegExp(\"^\"+a+\"$\")}if(ab(a))return new RegExp(\"^\"+a.source+\"$\");throw Da(\"imatcher\");\n}function Md(a){var b=[];v(a)&&r(a,function(a){b.push(Og(a))});return b}function Wf(){this.SCE_CONTEXTS=U;var a=[\"self\"],b=[];this.resourceUrlWhitelist=function(b){arguments.length&&(a=Md(b));return a};this.resourceUrlBlacklist=function(a){arguments.length&&(b=Md(a));return b};this.$get=[\"$injector\",\"$$sanitizeUri\",function(d,c){function e(a,b){var c;\"self\"===a?(c=Ac(b,Nd))||(B.document.baseURI?c=B.document.baseURI:(La||(La=B.document.createElement(\"a\"),La.href=\".\",La=La.cloneNode(!1)),c=La.href),\nc=Ac(b,c)):c=!!a.exec(b.href);return c}function f(a){var b=function(a){this.$$unwrapTrustedValue=function(){return a}};a&&(b.prototype=new a);b.prototype.valueOf=function(){return this.$$unwrapTrustedValue()};b.prototype.toString=function(){return this.$$unwrapTrustedValue().toString()};return b}var g=function(a){throw Da(\"unsafe\");};d.has(\"$sanitize\")&&(g=d.get(\"$sanitize\"));var k=f(),h={};h[U.HTML]=f(k);h[U.CSS]=f(k);h[U.MEDIA_URL]=f(k);h[U.URL]=f(h[U.MEDIA_URL]);h[U.JS]=f(k);h[U.RESOURCE_URL]=\nf(h[U.URL]);return{trustAs:function(a,b){var c=h.hasOwnProperty(a)?h[a]:null;if(!c)throw Da(\"icontext\",a,b);if(null===b||x(b)||\"\"===b)return b;if(\"string\"!==typeof b)throw Da(\"itype\",a);return new c(b)},getTrusted:function(d,f){if(null===f||x(f)||\"\"===f)return f;var k=h.hasOwnProperty(d)?h[d]:null;if(k&&f instanceof k)return f.$$unwrapTrustedValue();z(f.$$unwrapTrustedValue)&&(f=f.$$unwrapTrustedValue());if(d===U.MEDIA_URL||d===U.URL)return c(f.toString(),d===U.MEDIA_URL);if(d===U.RESOURCE_URL){var k=\nla(f.toString()),n,s,t=!1;n=0;for(s=a.length;n<s;n++)if(e(a[n],k)){t=!0;break}if(t)for(n=0,s=b.length;n<s;n++)if(e(b[n],k)){t=!1;break}if(t)return f;throw Da(\"insecurl\",f.toString());}if(d===U.HTML)return g(f);throw Da(\"unsafe\");},valueOf:function(a){return a instanceof k?a.$$unwrapTrustedValue():a}}}]}function Vf(){var a=!0;this.enabled=function(b){arguments.length&&(a=!!b);return a};this.$get=[\"$parse\",\"$sceDelegate\",function(b,d){if(a&&8>Aa)throw Da(\"iequirks\");var c=oa(U);c.isEnabled=function(){return a};\nc.trustAs=d.trustAs;c.getTrusted=d.getTrusted;c.valueOf=d.valueOf;a||(c.trustAs=c.getTrusted=function(a,b){return b},c.valueOf=Ta);c.parseAs=function(a,d){var e=b(d);return e.literal&&e.constant?e:b(d,function(b){return c.getTrusted(a,b)})};var e=c.parseAs,f=c.getTrusted,g=c.trustAs;r(U,function(a,b){var d=O(b);c[(\"parse_as_\"+d).replace(Bc,wb)]=function(b){return e(a,b)};c[(\"get_trusted_\"+d).replace(Bc,wb)]=function(b){return f(a,b)};c[(\"trust_as_\"+d).replace(Bc,wb)]=function(b){return g(a,b)}});\nreturn c}]}function Xf(){this.$get=[\"$window\",\"$document\",function(a,b){var d={},c=!((!a.nw||!a.nw.process)&&a.chrome&&(a.chrome.app&&a.chrome.app.runtime||!a.chrome.app&&a.chrome.runtime&&a.chrome.runtime.id))&&a.history&&a.history.pushState,e=da((/android (\\d+)/.exec(O((a.navigator||{}).userAgent))||[])[1]),f=/Boxee/i.test((a.navigator||{}).userAgent),g=b[0]||{},k=g.body&&g.body.style,h=!1,l=!1;k&&(h=!!(\"transition\"in k||\"webkitTransition\"in k),l=!!(\"animation\"in k||\"webkitAnimation\"in k));return{history:!(!c||\n4>e||f),hasEvent:function(a){if(\"input\"===a&&Aa)return!1;if(x(d[a])){var b=g.createElement(\"div\");d[a]=\"on\"+a in b}return d[a]},csp:pa(),transitions:h,animations:l,android:e}}]}function Yf(){this.$get=ia(function(a){return new Pg(a)})}function Pg(a){function b(){var a=e.pop();return a&&a.cb}function d(a){for(var b=e.length-1;0<=b;--b){var c=e[b];if(c.type===a)return e.splice(b,1),c.cb}}var c={},e=[],f=this.ALL_TASKS_TYPE=\"$$all$$\",g=this.DEFAULT_TASK_TYPE=\"$$default$$\";this.completeTask=function(e,\nh){h=h||g;try{e()}finally{var l;l=h||g;c[l]&&(c[l]--,c[f]--);l=c[h];var m=c[f];if(!m||!l)for(l=m?d:b;m=l(h);)try{m()}catch(q){a.error(q)}}};this.incTaskCount=function(a){a=a||g;c[a]=(c[a]||0)+1;c[f]=(c[f]||0)+1};this.notifyWhenNoPendingTasks=function(a,b){b=b||f;c[b]?e.push({type:b,cb:a}):a()}}function $f(){var a;this.httpOptions=function(b){return b?(a=b,this):a};this.$get=[\"$exceptionHandler\",\"$templateCache\",\"$http\",\"$q\",\"$sce\",function(b,d,c,e,f){function g(k,h){g.totalPendingRequests++;if(!C(k)||\nx(d.get(k)))k=f.getTrustedResourceUrl(k);var l=c.defaults&&c.defaults.transformResponse;I(l)?l=l.filter(function(a){return a!==uc}):l===uc&&(l=null);return c.get(k,R({cache:d,transformResponse:l},a)).finally(function(){g.totalPendingRequests--}).then(function(a){return d.put(k,a.data)},function(a){h||(a=Qg(\"tpload\",k,a.status,a.statusText),b(a));return e.reject(a)})}g.totalPendingRequests=0;return g}]}function ag(){this.$get=[\"$rootScope\",\"$browser\",\"$location\",function(a,b,d){return{findBindings:function(a,\nb,d){a=a.getElementsByClassName(\"ng-binding\");var g=[];r(a,function(a){var c=ea.element(a).data(\"$binding\");c&&r(c,function(c){d?(new RegExp(\"(^|\\\\s)\"+Ld(b)+\"(\\\\s|\\\\||$)\")).test(c)&&g.push(a):-1!==c.indexOf(b)&&g.push(a)})});return g},findModels:function(a,b,d){for(var g=[\"ng-\",\"data-ng-\",\"ng\\\\:\"],k=0;k<g.length;++k){var h=a.querySelectorAll(\"[\"+g[k]+\"model\"+(d?\"=\":\"*=\")+'\"'+b+'\"]');if(h.length)return h}},getLocation:function(){return d.url()},setLocation:function(b){b!==d.url()&&(d.url(b),a.$digest())},\nwhenStable:function(a){b.notifyWhenNoOutstandingRequests(a)}}}]}function bg(){this.$get=[\"$rootScope\",\"$browser\",\"$q\",\"$$q\",\"$exceptionHandler\",function(a,b,d,c,e){function f(f,h,l){z(f)||(l=h,h=f,f=A);var m=Ga.call(arguments,3),q=v(l)&&!l,n=(q?c:d).defer(),s=n.promise,t;t=b.defer(function(){try{n.resolve(f.apply(null,m))}catch(b){n.reject(b),e(b)}finally{delete g[s.$$timeoutId]}q||a.$apply()},h,\"$timeout\");s.$$timeoutId=t;g[t]=n;return s}var g={};f.cancel=function(a){if(!a)return!1;if(!a.hasOwnProperty(\"$$timeoutId\"))throw Rg(\"badprom\");\nif(!g.hasOwnProperty(a.$$timeoutId))return!1;a=a.$$timeoutId;var c=g[a];c.promise.$$state.pur=!0;c.reject(\"canceled\");delete g[a];return b.defer.cancel(a)};return f}]}function la(a){if(!C(a))return a;Aa&&($.setAttribute(\"href\",a),a=$.href);$.setAttribute(\"href\",a);return{href:$.href,protocol:$.protocol?$.protocol.replace(/:$/,\"\"):\"\",host:$.host,search:$.search?$.search.replace(/^\\?/,\"\"):\"\",hash:$.hash?$.hash.replace(/^#/,\"\"):\"\",hostname:$.hostname,port:$.port,pathname:\"/\"===$.pathname.charAt(0)?$.pathname:\n\"/\"+$.pathname}}function Fg(a){var b=[Nd].concat(a.map(la));return function(a){a=la(a);return b.some(Ac.bind(null,a))}}function Ac(a,b){a=la(a);b=la(b);return a.protocol===b.protocol&&a.host===b.host}function cg(){this.$get=ia(B)}function Od(a){function b(a){try{return decodeURIComponent(a)}catch(b){return a}}var d=a[0]||{},c={},e=\"\";return function(){var a,g,k,h,l;try{a=d.cookie||\"\"}catch(m){a=\"\"}if(a!==e)for(e=a,a=e.split(\"; \"),c={},k=0;k<a.length;k++)g=a[k],h=g.indexOf(\"=\"),0<h&&(l=b(g.substring(0,\nh)),x(c[l])&&(c[l]=b(g.substring(h+1))));return c}}function gg(){this.$get=Od}function cd(a){function b(d,c){if(F(d)){var e={};r(d,function(a,c){e[c]=b(c,a)});return e}return a.factory(d+\"Filter\",c)}this.register=b;this.$get=[\"$injector\",function(a){return function(b){return a.get(b+\"Filter\")}}];b(\"currency\",Pd);b(\"date\",Qd);b(\"filter\",Sg);b(\"json\",Tg);b(\"limitTo\",Ug);b(\"lowercase\",Vg);b(\"number\",Rd);b(\"orderBy\",Sd);b(\"uppercase\",Wg)}function Sg(){return function(a,b,d,c){if(!xa(a)){if(null==a)return a;\nthrow M(\"filter\")(\"notarray\",a);}c=c||\"$\";var e;switch(Cc(b)){case \"function\":break;case \"boolean\":case \"null\":case \"number\":case \"string\":e=!0;case \"object\":b=Xg(b,d,c,e);break;default:return a}return Array.prototype.filter.call(a,b)}}function Xg(a,b,d,c){var e=F(a)&&d in a;!0===b?b=ua:z(b)||(b=function(a,b){if(x(a))return!1;if(null===a||null===b)return a===b;if(F(b)||F(a)&&!ac(a))return!1;a=O(\"\"+a);b=O(\"\"+b);return-1!==a.indexOf(b)});return function(f){return e&&!F(f)?Ma(f,a[d],b,d,!1):Ma(f,a,b,\nd,c)}}function Ma(a,b,d,c,e,f){var g=Cc(a),k=Cc(b);if(\"string\"===k&&\"!\"===b.charAt(0))return!Ma(a,b.substring(1),d,c,e);if(I(a))return a.some(function(a){return Ma(a,b,d,c,e)});switch(g){case \"object\":var h;if(e){for(h in a)if(h.charAt&&\"$\"!==h.charAt(0)&&Ma(a[h],b,d,c,!0))return!0;return f?!1:Ma(a,b,d,c,!1)}if(\"object\"===k){for(h in b)if(f=b[h],!z(f)&&!x(f)&&(g=h===c,!Ma(g?a:a[h],f,d,c,g,g)))return!1;return!0}return d(a,b);case \"function\":return!1;default:return d(a,b)}}function Cc(a){return null===\na?\"null\":typeof a}function Pd(a){var b=a.NUMBER_FORMATS;return function(a,c,e){x(c)&&(c=b.CURRENCY_SYM);x(e)&&(e=b.PATTERNS[1].maxFrac);var f=c?/\\u00A4/g:/\\s*\\u00A4\\s*/g;return null==a?a:Td(a,b.PATTERNS[1],b.GROUP_SEP,b.DECIMAL_SEP,e).replace(f,c)}}function Rd(a){var b=a.NUMBER_FORMATS;return function(a,c){return null==a?a:Td(a,b.PATTERNS[0],b.GROUP_SEP,b.DECIMAL_SEP,c)}}function Yg(a){var b=0,d,c,e,f,g;-1<(c=a.indexOf(Ud))&&(a=a.replace(Ud,\"\"));0<(e=a.search(/e/i))?(0>c&&(c=e),c+=+a.slice(e+1),a=\na.substring(0,e)):0>c&&(c=a.length);for(e=0;a.charAt(e)===Dc;e++);if(e===(g=a.length))d=[0],c=1;else{for(g--;a.charAt(g)===Dc;)g--;c-=e;d=[];for(f=0;e<=g;e++,f++)d[f]=+a.charAt(e)}c>Vd&&(d=d.splice(0,Vd-1),b=c-1,c=1);return{d:d,e:b,i:c}}function Zg(a,b,d,c){var e=a.d,f=e.length-a.i;b=x(b)?Math.min(Math.max(d,f),c):+b;d=b+a.i;c=e[d];if(0<d){e.splice(Math.max(a.i,d));for(var g=d;g<e.length;g++)e[g]=0}else for(f=Math.max(0,f),a.i=1,e.length=Math.max(1,d=b+1),e[0]=0,g=1;g<d;g++)e[g]=0;if(5<=c)if(0>d-\n1){for(c=0;c>d;c--)e.unshift(0),a.i++;e.unshift(1);a.i++}else e[d-1]++;for(;f<Math.max(0,b);f++)e.push(0);if(b=e.reduceRight(function(a,b,c,d){b+=a;d[c]=b%10;return Math.floor(b/10)},0))e.unshift(b),a.i++}function Td(a,b,d,c,e){if(!C(a)&&!ba(a)||isNaN(a))return\"\";var f=!isFinite(a),g=!1,k=Math.abs(a)+\"\",h=\"\";if(f)h=\"\\u221e\";else{g=Yg(k);Zg(g,e,b.minFrac,b.maxFrac);h=g.d;k=g.i;e=g.e;f=[];for(g=h.reduce(function(a,b){return a&&!b},!0);0>k;)h.unshift(0),k++;0<k?f=h.splice(k,h.length):(f=h,h=[0]);k=[];\nfor(h.length>=b.lgSize&&k.unshift(h.splice(-b.lgSize,h.length).join(\"\"));h.length>b.gSize;)k.unshift(h.splice(-b.gSize,h.length).join(\"\"));h.length&&k.unshift(h.join(\"\"));h=k.join(d);f.length&&(h+=c+f.join(\"\"));e&&(h+=\"e+\"+e)}return 0>a&&!g?b.negPre+h+b.negSuf:b.posPre+h+b.posSuf}function Ob(a,b,d,c){var e=\"\";if(0>a||c&&0>=a)c?a=-a+1:(a=-a,e=\"-\");for(a=\"\"+a;a.length<b;)a=Dc+a;d&&(a=a.substr(a.length-b));return e+a}function ga(a,b,d,c,e){d=d||0;return function(f){f=f[\"get\"+a]();if(0<d||f>-d)f+=d;0===\nf&&-12===d&&(f=12);return Ob(f,b,c,e)}}function kb(a,b,d){return function(c,e){var f=c[\"get\"+a](),g=ub((d?\"STANDALONE\":\"\")+(b?\"SHORT\":\"\")+a);return e[g][f]}}function Wd(a){var b=(new Date(a,0,1)).getDay();return new Date(a,0,(4>=b?5:12)-b)}function Xd(a){return function(b){var d=Wd(b.getFullYear());b=+new Date(b.getFullYear(),b.getMonth(),b.getDate()+(4-b.getDay()))-+d;b=1+Math.round(b/6048E5);return Ob(b,a)}}function Ec(a,b){return 0>=a.getFullYear()?b.ERAS[0]:b.ERAS[1]}function Qd(a){function b(a){var b;\nif(b=a.match(d)){a=new Date(0);var f=0,g=0,k=b[8]?a.setUTCFullYear:a.setFullYear,h=b[8]?a.setUTCHours:a.setHours;b[9]&&(f=da(b[9]+b[10]),g=da(b[9]+b[11]));k.call(a,da(b[1]),da(b[2])-1,da(b[3]));f=da(b[4]||0)-f;g=da(b[5]||0)-g;k=da(b[6]||0);b=Math.round(1E3*parseFloat(\"0.\"+(b[7]||0)));h.call(a,f,g,k,b)}return a}var d=/^(\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d+))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d))?)?$/;return function(c,d,f){var g=\"\",k=[],h,l;d=d||\"mediumDate\";d=a.DATETIME_FORMATS[d]||\nd;C(c)&&(c=$g.test(c)?da(c):b(c));ba(c)&&(c=new Date(c));if(!ha(c)||!isFinite(c.getTime()))return c;for(;d;)(l=ah.exec(d))?(k=db(k,l,1),d=k.pop()):(k.push(d),d=null);var m=c.getTimezoneOffset();f&&(m=dc(f,m),c=ec(c,f,!0));r(k,function(b){h=bh[b];g+=h?h(c,a.DATETIME_FORMATS,m):\"''\"===b?\"'\":b.replace(/(^'|'$)/g,\"\").replace(/''/g,\"'\")});return g}}function Tg(){return function(a,b){x(b)&&(b=2);return eb(a,b)}}function Ug(){return function(a,b,d){b=Infinity===Math.abs(Number(b))?Number(b):da(b);if(V(b))return a;\nba(a)&&(a=a.toString());if(!xa(a))return a;d=!d||isNaN(d)?0:da(d);d=0>d?Math.max(0,a.length+d):d;return 0<=b?Fc(a,d,d+b):0===d?Fc(a,b,a.length):Fc(a,Math.max(0,d+b),d)}}function Fc(a,b,d){return C(a)?a.slice(b,d):Ga.call(a,b,d)}function Sd(a){function b(b){return b.map(function(b){var c=1,d=Ta;if(z(b))d=b;else if(C(b)){if(\"+\"===b.charAt(0)||\"-\"===b.charAt(0))c=\"-\"===b.charAt(0)?-1:1,b=b.substring(1);if(\"\"!==b&&(d=a(b),d.constant))var e=d(),d=function(a){return a[e]}}return{get:d,descending:c}})}function d(a){switch(typeof a){case \"number\":case \"boolean\":case \"string\":return!0;\ndefault:return!1}}function c(a,b){var c=0,d=a.type,h=b.type;if(d===h){var h=a.value,l=b.value;\"string\"===d?(h=h.toLowerCase(),l=l.toLowerCase()):\"object\"===d&&(F(h)&&(h=a.index),F(l)&&(l=b.index));h!==l&&(c=h<l?-1:1)}else c=\"undefined\"===d?1:\"undefined\"===h?-1:\"null\"===d?1:\"null\"===h?-1:d<h?-1:1;return c}return function(a,f,g,k){if(null==a)return a;if(!xa(a))throw M(\"orderBy\")(\"notarray\",a);I(f)||(f=[f]);0===f.length&&(f=[\"+\"]);var h=b(f),l=g?-1:1,m=z(k)?k:c;a=Array.prototype.map.call(a,function(a,\nb){return{value:a,tieBreaker:{value:b,type:\"number\",index:b},predicateValues:h.map(function(c){var e=c.get(a);c=typeof e;if(null===e)c=\"null\";else if(\"object\"===c)a:{if(z(e.valueOf)&&(e=e.valueOf(),d(e)))break a;ac(e)&&(e=e.toString(),d(e))}return{value:e,type:c,index:b}})}});a.sort(function(a,b){for(var d=0,e=h.length;d<e;d++){var f=m(a.predicateValues[d],b.predicateValues[d]);if(f)return f*h[d].descending*l}return(m(a.tieBreaker,b.tieBreaker)||c(a.tieBreaker,b.tieBreaker))*l});return a=a.map(function(a){return a.value})}}\nfunction Na(a){z(a)&&(a={link:a});a.restrict=a.restrict||\"AC\";return ia(a)}function Pb(a,b,d,c,e){this.$$controls=[];this.$error={};this.$$success={};this.$pending=void 0;this.$name=e(b.name||b.ngForm||\"\")(d);this.$dirty=!1;this.$valid=this.$pristine=!0;this.$submitted=this.$invalid=!1;this.$$parentForm=lb;this.$$element=a;this.$$animate=c;Yd(this)}function Yd(a){a.$$classCache={};a.$$classCache[Zd]=!(a.$$classCache[mb]=a.$$element.hasClass(mb))}function $d(a){function b(a,b,c){c&&!a.$$classCache[b]?\n(a.$$animate.addClass(a.$$element,b),a.$$classCache[b]=!0):!c&&a.$$classCache[b]&&(a.$$animate.removeClass(a.$$element,b),a.$$classCache[b]=!1)}function d(a,c,d){c=c?\"-\"+Uc(c,\"-\"):\"\";b(a,mb+c,!0===d);b(a,Zd+c,!1===d)}var c=a.set,e=a.unset;a.clazz.prototype.$setValidity=function(a,g,k){x(g)?(this.$pending||(this.$pending={}),c(this.$pending,a,k)):(this.$pending&&e(this.$pending,a,k),ae(this.$pending)&&(this.$pending=void 0));Fa(g)?g?(e(this.$error,a,k),c(this.$$success,a,k)):(c(this.$error,a,k),e(this.$$success,\na,k)):(e(this.$error,a,k),e(this.$$success,a,k));this.$pending?(b(this,\"ng-pending\",!0),this.$valid=this.$invalid=void 0,d(this,\"\",null)):(b(this,\"ng-pending\",!1),this.$valid=ae(this.$error),this.$invalid=!this.$valid,d(this,\"\",this.$valid));g=this.$pending&&this.$pending[a]?void 0:this.$error[a]?!1:this.$$success[a]?!0:null;d(this,a,g);this.$$parentForm.$setValidity(a,g,this)}}function ae(a){if(a)for(var b in a)if(a.hasOwnProperty(b))return!1;return!0}function Gc(a){a.$formatters.push(function(b){return a.$isEmpty(b)?\nb:b.toString()})}function Ra(a,b,d,c,e,f){var g=O(b[0].type);if(!e.android){var k=!1;b.on(\"compositionstart\",function(){k=!0});b.on(\"compositionupdate\",function(a){if(x(a.data)||\"\"===a.data)k=!1});b.on(\"compositionend\",function(){k=!1;l()})}var h,l=function(a){h&&(f.defer.cancel(h),h=null);if(!k){var e=b.val();a=a&&a.type;\"password\"===g||d.ngTrim&&\"false\"===d.ngTrim||(e=T(e));(c.$viewValue!==e||\"\"===e&&c.$$hasNativeValidators)&&c.$setViewValue(e,a)}};if(e.hasEvent(\"input\"))b.on(\"input\",l);else{var m=\nfunction(a,b,c){h||(h=f.defer(function(){h=null;b&&b.value===c||l(a)}))};b.on(\"keydown\",function(a){var b=a.keyCode;91===b||15<b&&19>b||37<=b&&40>=b||m(a,this,this.value)});if(e.hasEvent(\"paste\"))b.on(\"paste cut drop\",m)}b.on(\"change\",l);if(be[g]&&c.$$hasNativeValidators&&g===d.type)b.on(\"keydown wheel mousedown\",function(a){if(!h){var b=this.validity,c=b.badInput,d=b.typeMismatch;h=f.defer(function(){h=null;b.badInput===c&&b.typeMismatch===d||l(a)})}});c.$render=function(){var a=c.$isEmpty(c.$viewValue)?\n\"\":c.$viewValue;b.val()!==a&&b.val(a)}}function Qb(a,b){return function(d,c){var e,f;if(ha(d))return d;if(C(d)){'\"'===d.charAt(0)&&'\"'===d.charAt(d.length-1)&&(d=d.substring(1,d.length-1));if(ch.test(d))return new Date(d);a.lastIndex=0;if(e=a.exec(d))return e.shift(),f=c?{yyyy:c.getFullYear(),MM:c.getMonth()+1,dd:c.getDate(),HH:c.getHours(),mm:c.getMinutes(),ss:c.getSeconds(),sss:c.getMilliseconds()/1E3}:{yyyy:1970,MM:1,dd:1,HH:0,mm:0,ss:0,sss:0},r(e,function(a,c){c<b.length&&(f[b[c]]=+a)}),e=new Date(f.yyyy,\nf.MM-1,f.dd,f.HH,f.mm,f.ss||0,1E3*f.sss||0),100>f.yyyy&&e.setFullYear(f.yyyy),e}return NaN}}function nb(a,b,d,c){return function(e,f,g,k,h,l,m){function q(a){return a&&!(a.getTime&&a.getTime()!==a.getTime())}function n(a){return v(a)&&!ha(a)?s(a)||void 0:a}function s(a,b){var c=k.$options.getOption(\"timezone\");p&&p!==c&&(b=Rc(b,dc(p)));var e=d(a,b);!isNaN(e)&&c&&(e=ec(e,c));return e}Hc(e,f,g,k,a);Ra(e,f,g,k,h,l);var t=\"time\"===a||\"datetimelocal\"===a,u,p;k.$parsers.push(function(c){if(k.$isEmpty(c))return null;\nif(b.test(c))return s(c,u);k.$$parserName=a});k.$formatters.push(function(a){if(a&&!ha(a))throw ob(\"datefmt\",a);if(q(a)){u=a;var b=k.$options.getOption(\"timezone\");b&&(p=b,u=ec(u,b,!0));var d=c;t&&C(k.$options.getOption(\"timeSecondsFormat\"))&&(d=c.replace(\"ss.sss\",k.$options.getOption(\"timeSecondsFormat\")).replace(/:$/,\"\"));a=m(\"date\")(a,d,b);t&&k.$options.getOption(\"timeStripZeroSeconds\")&&(a=a.replace(/(?::00)?(?:\\.000)?$/,\"\"));return a}p=u=null;return\"\"});if(v(g.min)||g.ngMin){var r;k.$validators.min=\nfunction(a){return!q(a)||x(r)||d(a)>=r};g.$observe(\"min\",function(a){r=n(a);k.$validate()})}if(v(g.max)||g.ngMax){var y;k.$validators.max=function(a){return!q(a)||x(y)||d(a)<=y};g.$observe(\"max\",function(a){y=n(a);k.$validate()})}}}function Hc(a,b,d,c,e){(c.$$hasNativeValidators=F(b[0].validity))&&c.$parsers.push(function(a){var d=b.prop(\"validity\")||{};if(d.badInput||d.typeMismatch)c.$$parserName=e;else return a})}function ce(a){a.$parsers.push(function(b){if(a.$isEmpty(b))return null;if(dh.test(b))return parseFloat(b);\na.$$parserName=\"number\"});a.$formatters.push(function(b){if(!a.$isEmpty(b)){if(!ba(b))throw ob(\"numfmt\",b);b=b.toString()}return b})}function Sa(a){v(a)&&!ba(a)&&(a=parseFloat(a));return V(a)?void 0:a}function Ic(a){var b=a.toString(),d=b.indexOf(\".\");return-1===d?-1<a&&1>a&&(a=/e-(\\d+)$/.exec(b))?Number(a[1]):0:b.length-d-1}function de(a,b,d){a=Number(a);var c=(a|0)!==a,e=(b|0)!==b,f=(d|0)!==d;if(c||e||f){var g=c?Ic(a):0,k=e?Ic(b):0,h=f?Ic(d):0,g=Math.max(g,k,h),g=Math.pow(10,g);a*=g;b*=g;d*=g;c&&\n(a=Math.round(a));e&&(b=Math.round(b));f&&(d=Math.round(d))}return 0===(a-b)%d}function ee(a,b,d,c,e){if(v(c)){a=a(c);if(!a.constant)throw ob(\"constexpr\",d,c);return a(b)}return e}function Jc(a,b){function d(a,b){if(!a||!a.length)return[];if(!b||!b.length)return a;var c=[],d=0;a:for(;d<a.length;d++){for(var e=a[d],m=0;m<b.length;m++)if(e===b[m])continue a;c.push(e)}return c}function c(a){if(!a)return a;var b=a;I(a)?b=a.map(c).join(\" \"):F(a)?b=Object.keys(a).filter(function(b){return a[b]}).join(\" \"):\nC(a)||(b=a+\"\");return b}a=\"ngClass\"+a;var e;return[\"$parse\",function(f){return{restrict:\"AC\",link:function(g,k,h){function l(a,b){var c=[];r(a,function(a){if(0<b||q[a])q[a]=(q[a]||0)+b,q[a]===+(0<b)&&c.push(a)});return c.join(\" \")}function m(a){if(a===b){var c=s,c=l(c&&c.split(\" \"),1);h.$addClass(c)}else c=s,c=l(c&&c.split(\" \"),-1),h.$removeClass(c);n=a}var q=k.data(\"$classCounts\"),n=!0,s;q||(q=S(),k.data(\"$classCounts\",q));\"ngClass\"!==a&&(e||(e=f(\"$index\",function(a){return a&1})),g.$watch(e,m));\ng.$watch(f(h[a],c),function(a){if(n===b){var c=s&&s.split(\" \"),e=a&&a.split(\" \"),f=d(c,e),c=d(e,c),f=l(f,-1),c=l(c,1);h.$addClass(c);h.$removeClass(f)}s=a})}}}]}function pd(a,b,d,c,e,f){return{restrict:\"A\",compile:function(g,k){var h=a(k[c]);return function(a,c){c.on(e,function(c){var e=function(){h(a,{$event:c})};if(b.$$phase)if(f)a.$evalAsync(e);else try{e()}catch(g){d(g)}else a.$apply(e)})}}}}function Rb(a,b,d,c,e,f,g,k,h){this.$modelValue=this.$viewValue=Number.NaN;this.$$rawModelValue=void 0;\nthis.$validators={};this.$asyncValidators={};this.$parsers=[];this.$formatters=[];this.$viewChangeListeners=[];this.$untouched=!0;this.$touched=!1;this.$pristine=!0;this.$dirty=!1;this.$valid=!0;this.$invalid=!1;this.$error={};this.$$success={};this.$pending=void 0;this.$name=h(d.name||\"\",!1)(a);this.$$parentForm=lb;this.$options=Sb;this.$$updateEvents=\"\";this.$$updateEventHandler=this.$$updateEventHandler.bind(this);this.$$parsedNgModel=e(d.ngModel);this.$$parsedNgModelAssign=this.$$parsedNgModel.assign;\nthis.$$ngModelGet=this.$$parsedNgModel;this.$$ngModelSet=this.$$parsedNgModelAssign;this.$$pendingDebounce=null;this.$$parserValid=void 0;this.$$parserName=\"parse\";this.$$currentValidationRunId=0;this.$$scope=a;this.$$rootScope=a.$root;this.$$attr=d;this.$$element=c;this.$$animate=f;this.$$timeout=g;this.$$parse=e;this.$$q=k;this.$$exceptionHandler=b;Yd(this);eh(this)}function eh(a){a.$$scope.$watch(function(b){b=a.$$ngModelGet(b);b===a.$modelValue||a.$modelValue!==a.$modelValue&&b!==b||a.$$setModelValue(b);\nreturn b})}function Kc(a){this.$$options=a}function fe(a,b){r(b,function(b,c){v(a[c])||(a[c]=b)})}function Ea(a,b){a.prop(\"selected\",b);a.attr(\"selected\",b)}var Vb={objectMaxDepth:5,urlErrorParamsEnabled:!0},fh=/^\\/(.+)\\/([a-z]*)$/,sa=Object.prototype.hasOwnProperty,O=function(a){return C(a)?a.toLowerCase():a},ub=function(a){return C(a)?a.toUpperCase():a},Aa,y,rb,Ga=[].slice,Bg=[].splice,gh=[].push,ma=Object.prototype.toString,Oc=Object.getPrototypeOf,Ia=M(\"ng\"),ea=B.angular||(B.angular={}),jc,pb=\n0;Aa=B.document.documentMode;var V=Number.isNaN||function(a){return a!==a};A.$inject=[];Ta.$inject=[];var se=/^\\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/,T=function(a){return C(a)?a.trim():a},Ld=function(a){return a.replace(/([-()[\\]{}+?*.$^|,:#<!\\\\])/g,\"\\\\$1\").replace(/\\x08/g,\"\\\\x08\")},pa=function(){if(!v(pa.rules)){var a=B.document.querySelector(\"[ng-csp]\")||B.document.querySelector(\"[data-ng-csp]\");if(a){var b=a.getAttribute(\"ng-csp\")||a.getAttribute(\"data-ng-csp\");\npa.rules={noUnsafeEval:!b||-1!==b.indexOf(\"no-unsafe-eval\"),noInlineStyle:!b||-1!==b.indexOf(\"no-inline-style\")}}else{a=pa;try{new Function(\"\"),b=!1}catch(d){b=!0}a.rules={noUnsafeEval:b,noInlineStyle:!1}}}return pa.rules},qb=function(){if(v(qb.name_))return qb.name_;var a,b,d=Pa.length,c,e;for(b=0;b<d;++b)if(c=Pa[b],a=B.document.querySelector(\"[\"+c.replace(\":\",\"\\\\:\")+\"jq]\")){e=a.getAttribute(c+\"jq\");break}return qb.name_=e},ue=/:/g,Pa=[\"ng-\",\"data-ng-\",\"ng:\",\"x-ng-\"],ye=function(a){var b=a.currentScript;\nif(!b)return!0;if(!(b instanceof B.HTMLScriptElement||b instanceof B.SVGScriptElement))return!1;b=b.attributes;return[b.getNamedItem(\"src\"),b.getNamedItem(\"href\"),b.getNamedItem(\"xlink:href\")].every(function(b){if(!b)return!0;if(!b.value)return!1;var c=a.createElement(\"a\");c.href=b.value;if(a.location.origin===c.origin)return!0;switch(c.protocol){case \"http:\":case \"https:\":case \"ftp:\":case \"blob:\":case \"file:\":case \"data:\":return!0;default:return!1}})}(B.document),Be=/[A-Z]/g,Vc=!1,Oa=3,He={full:\"1.7.5\",\nmajor:1,minor:7,dot:5,codeName:\"anti-prettification\"};W.expando=\"ng339\";var Ja=W.cache={},lg=1;W._data=function(a){return this.cache[a[this.expando]]||{}};var hg=/-([a-z])/g,hh=/^-ms-/,Ab={mouseleave:\"mouseout\",mouseenter:\"mouseover\"},mc=M(\"jqLite\"),kg=/^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/,lc=/<|&#?\\w+;/,ig=/<([\\w:-]+)/,jg=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,ja={option:[1,'<select multiple=\"multiple\">',\"</select>\"],thead:[1,\"<table>\",\"</table>\"],col:[2,\"<table><colgroup>\",\n\"</colgroup></table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:[0,\"\",\"\"]};ja.optgroup=ja.option;ja.tbody=ja.tfoot=ja.colgroup=ja.caption=ja.thead;ja.th=ja.td;var qg=B.Node.prototype.contains||function(a){return!!(this.compareDocumentPosition(a)&16)},Wa=W.prototype={ready:ed,toString:function(){var a=[];r(this,function(b){a.push(\"\"+b)});return\"[\"+a.join(\", \")+\"]\"},eq:function(a){return 0<=a?y(this[a]):y(this[this.length+a])},length:0,\npush:gh,sort:[].sort,splice:[].splice},Gb={};r(\"multiple selected checked disabled readOnly required open\".split(\" \"),function(a){Gb[O(a)]=a});var ld={};r(\"input select option textarea button form details\".split(\" \"),function(a){ld[a]=!0});var sd={ngMinlength:\"minlength\",ngMaxlength:\"maxlength\",ngMin:\"min\",ngMax:\"max\",ngPattern:\"pattern\",ngStep:\"step\"};r({data:qc,removeData:pc,hasData:function(a){for(var b in Ja[a.ng339])return!0;return!1},cleanData:function(a){for(var b=0,d=a.length;b<d;b++)pc(a[b]),\nhd(a[b])}},function(a,b){W[b]=a});r({data:qc,inheritedData:Eb,scope:function(a){return y.data(a,\"$scope\")||Eb(a.parentNode||a,[\"$isolateScope\",\"$scope\"])},isolateScope:function(a){return y.data(a,\"$isolateScope\")||y.data(a,\"$isolateScopeNoTemplate\")},controller:id,injector:function(a){return Eb(a,\"$injector\")},removeAttr:function(a,b){a.removeAttribute(b)},hasClass:Bb,css:function(a,b,d){b=xb(b.replace(hh,\"ms-\"));if(v(d))a.style[b]=d;else return a.style[b]},attr:function(a,b,d){var c=a.nodeType;if(c!==\nOa&&2!==c&&8!==c&&a.getAttribute){var c=O(b),e=Gb[c];if(v(d))null===d||!1===d&&e?a.removeAttribute(b):a.setAttribute(b,e?c:d);else return a=a.getAttribute(b),e&&null!==a&&(a=c),null===a?void 0:a}},prop:function(a,b,d){if(v(d))a[b]=d;else return a[b]},text:function(){function a(a,d){if(x(d)){var c=a.nodeType;return 1===c||c===Oa?a.textContent:\"\"}a.textContent=d}a.$dv=\"\";return a}(),val:function(a,b){if(x(b)){if(a.multiple&&\"select\"===ta(a)){var d=[];r(a.options,function(a){a.selected&&d.push(a.value||\na.text)});return d}return a.value}a.value=b},html:function(a,b){if(x(b))return a.innerHTML;yb(a,!0);a.innerHTML=b},empty:jd},function(a,b){W.prototype[b]=function(b,c){var e,f,g=this.length;if(a!==jd&&x(2===a.length&&a!==Bb&&a!==id?b:c)){if(F(b)){for(e=0;e<g;e++)if(a===qc)a(this[e],b);else for(f in b)a(this[e],f,b[f]);return this}e=a.$dv;g=x(e)?Math.min(g,1):g;for(f=0;f<g;f++){var k=a(this[f],b,c);e=e?e+k:k}return e}for(e=0;e<g;e++)a(this[e],b,c);return this}});r({removeData:pc,on:function(a,b,d,\nc){if(v(c))throw mc(\"onargs\");if(kc(a)){c=zb(a,!0);var e=c.events,f=c.handle;f||(f=c.handle=ng(a,e));c=0<=b.indexOf(\" \")?b.split(\" \"):[b];for(var g=c.length,k=function(b,c,g){var k=e[b];k||(k=e[b]=[],k.specialHandlerWrapper=c,\"$destroy\"===b||g||a.addEventListener(b,f));k.push(d)};g--;)b=c[g],Ab[b]?(k(Ab[b],pg),k(b,void 0,!0)):k(b)}},off:hd,one:function(a,b,d){a=y(a);a.on(b,function e(){a.off(b,d);a.off(b,e)});a.on(b,d)},replaceWith:function(a,b){var d,c=a.parentNode;yb(a);r(new W(b),function(b){d?\nc.insertBefore(b,d.nextSibling):c.replaceChild(b,a);d=b})},children:function(a){var b=[];r(a.childNodes,function(a){1===a.nodeType&&b.push(a)});return b},contents:function(a){return a.contentDocument||a.childNodes||[]},append:function(a,b){var d=a.nodeType;if(1===d||11===d){b=new W(b);for(var d=0,c=b.length;d<c;d++)a.appendChild(b[d])}},prepend:function(a,b){if(1===a.nodeType){var d=a.firstChild;r(new W(b),function(b){a.insertBefore(b,d)})}},wrap:function(a,b){var d=y(b).eq(0).clone()[0],c=a.parentNode;\nc&&c.replaceChild(d,a);d.appendChild(a)},remove:Fb,detach:function(a){Fb(a,!0)},after:function(a,b){var d=a,c=a.parentNode;if(c){b=new W(b);for(var e=0,f=b.length;e<f;e++){var g=b[e];c.insertBefore(g,d.nextSibling);d=g}}},addClass:Db,removeClass:Cb,toggleClass:function(a,b,d){b&&r(b.split(\" \"),function(b){var e=d;x(e)&&(e=!Bb(a,b));(e?Db:Cb)(a,b)})},parent:function(a){return(a=a.parentNode)&&11!==a.nodeType?a:null},next:function(a){return a.nextElementSibling},find:function(a,b){return a.getElementsByTagName?\na.getElementsByTagName(b):[]},clone:oc,triggerHandler:function(a,b,d){var c,e,f=b.type||b,g=zb(a);if(g=(g=g&&g.events)&&g[f])c={preventDefault:function(){this.defaultPrevented=!0},isDefaultPrevented:function(){return!0===this.defaultPrevented},stopImmediatePropagation:function(){this.immediatePropagationStopped=!0},isImmediatePropagationStopped:function(){return!0===this.immediatePropagationStopped},stopPropagation:A,type:f,target:a},b.type&&(c=R(c,b)),b=oa(g),e=d?[c].concat(d):[c],r(b,function(b){c.isImmediatePropagationStopped()||\nb.apply(a,e)})}},function(a,b){W.prototype[b]=function(b,c,e){for(var f,g=0,k=this.length;g<k;g++)x(f)?(f=a(this[g],b,c,e),v(f)&&(f=y(f))):nc(f,a(this[g],b,c,e));return v(f)?f:this}});W.prototype.bind=W.prototype.on;W.prototype.unbind=W.prototype.off;var ih=Object.create(null);md.prototype={_idx:function(a){a!==this._lastKey&&(this._lastKey=a,this._lastIndex=this._keys.indexOf(a));return this._lastIndex},_transformKey:function(a){return V(a)?ih:a},get:function(a){a=this._transformKey(a);a=this._idx(a);\nif(-1!==a)return this._values[a]},has:function(a){a=this._transformKey(a);return-1!==this._idx(a)},set:function(a,b){a=this._transformKey(a);var d=this._idx(a);-1===d&&(d=this._lastIndex=this._keys.length);this._keys[d]=a;this._values[d]=b},delete:function(a){a=this._transformKey(a);a=this._idx(a);if(-1===a)return!1;this._keys.splice(a,1);this._values.splice(a,1);this._lastKey=NaN;this._lastIndex=-1;return!0}};var Hb=md,fg=[function(){this.$get=[function(){return Hb}]}],sg=/^([^(]+?)=>/,tg=/^[^(]*\\(\\s*([^)]*)\\)/m,\njh=/,/,kh=/^\\s*(_?)(\\S+?)\\1\\s*$/,rg=/((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg,za=M(\"$injector\");fb.$$annotate=function(a,b,d){var c;if(\"function\"===typeof a){if(!(c=a.$inject)){c=[];if(a.length){if(b)throw C(d)&&d||(d=a.name||ug(a)),za(\"strictdi\",d);b=nd(a);r(b[1].split(jh),function(a){a.replace(kh,function(a,b,d){c.push(d)})})}a.$inject=c}}else I(a)?(b=a.length-1,sb(a[b],\"fn\"),c=a.slice(0,b)):sb(a,\"fn\",!0);return c};var ge=M(\"$animate\"),vf=function(){this.$get=A},wf=function(){var a=new Hb,b=[];this.$get=\n[\"$$AnimateRunner\",\"$rootScope\",function(d,c){function e(a,b,c){var d=!1;b&&(b=C(b)?b.split(\" \"):I(b)?b:[],r(b,function(b){b&&(d=!0,a[b]=c)}));return d}function f(){r(b,function(b){var c=a.get(b);if(c){var d=vg(b.attr(\"class\")),e=\"\",f=\"\";r(c,function(a,b){a!==!!d[b]&&(a?e+=(e.length?\" \":\"\")+b:f+=(f.length?\" \":\"\")+b)});r(b,function(a){e&&Db(a,e);f&&Cb(a,f)});a.delete(b)}});b.length=0}return{enabled:A,on:A,off:A,pin:A,push:function(g,k,h,l){l&&l();h=h||{};h.from&&g.css(h.from);h.to&&g.css(h.to);if(h.addClass||\nh.removeClass)if(k=h.addClass,l=h.removeClass,h=a.get(g)||{},k=e(h,k,!0),l=e(h,l,!1),k||l)a.set(g,h),b.push(g),1===b.length&&c.$$postDigest(f);g=new d;g.complete();return g}}}]},tf=[\"$provide\",function(a){var b=this,d=null,c=null;this.$$registeredAnimations=Object.create(null);this.register=function(c,d){if(c&&\".\"!==c.charAt(0))throw ge(\"notcsel\",c);var g=c+\"-animation\";b.$$registeredAnimations[c.substr(1)]=g;a.factory(g,d)};this.customFilter=function(a){1===arguments.length&&(c=z(a)?a:null);return c};\nthis.classNameFilter=function(a){if(1===arguments.length&&(d=a instanceof RegExp?a:null)&&/[(\\s|\\/)]ng-animate[(\\s|\\/)]/.test(d.toString()))throw d=null,ge(\"nongcls\",\"ng-animate\");return d};this.$get=[\"$$animateQueue\",function(a){function b(a,c,d){if(d){var e;a:{for(e=0;e<d.length;e++){var f=d[e];if(1===f.nodeType){e=f;break a}}e=void 0}!e||e.parentNode||e.previousElementSibling||(d=null)}d?d.after(a):c.prepend(a)}return{on:a.on,off:a.off,pin:a.pin,enabled:a.enabled,cancel:function(a){a.cancel&&a.cancel()},\nenter:function(c,d,h,l){d=d&&y(d);h=h&&y(h);d=d||h.parent();b(c,d,h);return a.push(c,\"enter\",Ba(l))},move:function(c,d,h,l){d=d&&y(d);h=h&&y(h);d=d||h.parent();b(c,d,h);return a.push(c,\"move\",Ba(l))},leave:function(b,c){return a.push(b,\"leave\",Ba(c),function(){b.remove()})},addClass:function(b,c,d){d=Ba(d);d.addClass=hb(d.addclass,c);return a.push(b,\"addClass\",d)},removeClass:function(b,c,d){d=Ba(d);d.removeClass=hb(d.removeClass,c);return a.push(b,\"removeClass\",d)},setClass:function(b,c,d,f){f=Ba(f);\nf.addClass=hb(f.addClass,c);f.removeClass=hb(f.removeClass,d);return a.push(b,\"setClass\",f)},animate:function(b,c,d,f,m){m=Ba(m);m.from=m.from?R(m.from,c):c;m.to=m.to?R(m.to,d):d;m.tempClasses=hb(m.tempClasses,f||\"ng-inline-animate\");return a.push(b,\"animate\",m)}}}]}],yf=function(){this.$get=[\"$$rAF\",function(a){function b(b){d.push(b);1<d.length||a(function(){for(var a=0;a<d.length;a++)d[a]();d=[]})}var d=[];return function(){var a=!1;b(function(){a=!0});return function(d){a?d():b(d)}}}]},xf=function(){this.$get=\n[\"$q\",\"$sniffer\",\"$$animateAsyncRun\",\"$$isDocumentHidden\",\"$timeout\",function(a,b,d,c,e){function f(a){this.setHost(a);var b=d();this._doneCallbacks=[];this._tick=function(a){c()?e(a,0,!1):b(a)};this._state=0}f.chain=function(a,b){function c(){if(d===a.length)b(!0);else a[d](function(a){!1===a?b(!1):(d++,c())})}var d=0;c()};f.all=function(a,b){function c(f){e=e&&f;++d===a.length&&b(e)}var d=0,e=!0;r(a,function(a){a.done(c)})};f.prototype={setHost:function(a){this.host=a||{}},done:function(a){2===\nthis._state?a():this._doneCallbacks.push(a)},progress:A,getPromise:function(){if(!this.promise){var b=this;this.promise=a(function(a,c){b.done(function(b){!1===b?c():a()})})}return this.promise},then:function(a,b){return this.getPromise().then(a,b)},\"catch\":function(a){return this.getPromise()[\"catch\"](a)},\"finally\":function(a){return this.getPromise()[\"finally\"](a)},pause:function(){this.host.pause&&this.host.pause()},resume:function(){this.host.resume&&this.host.resume()},end:function(){this.host.end&&\nthis.host.end();this._resolve(!0)},cancel:function(){this.host.cancel&&this.host.cancel();this._resolve(!1)},complete:function(a){var b=this;0===b._state&&(b._state=1,b._tick(function(){b._resolve(a)}))},_resolve:function(a){2!==this._state&&(r(this._doneCallbacks,function(b){b(a)}),this._doneCallbacks.length=0,this._state=2)}};return f}]},uf=function(){this.$get=[\"$$rAF\",\"$q\",\"$$AnimateRunner\",function(a,b,d){return function(b,e){function f(){a(function(){g.addClass&&(b.addClass(g.addClass),g.addClass=\nnull);g.removeClass&&(b.removeClass(g.removeClass),g.removeClass=null);g.to&&(b.css(g.to),g.to=null);k||h.complete();k=!0});return h}var g=e||{};g.$$prepared||(g=Ha(g));g.cleanupStyles&&(g.from=g.to=null);g.from&&(b.css(g.from),g.from=null);var k,h=new d;return{start:f,end:f}}}]},aa=M(\"$compile\"),sc=new function(){};Wc.$inject=[\"$provide\",\"$$sanitizeUriProvider\"];Jb.prototype.isFirstChange=function(){return this.previousValue===sc};var od=/^((?:x|data)[:\\-_])/i,Ag=/[:\\-_]+(.)/g,ud=M(\"$controller\"),\ntd=/^(\\S+)(\\s+as\\s+([\\w$]+))?$/,Ff=function(){this.$get=[\"$document\",function(a){return function(b){b?!b.nodeType&&b instanceof y&&(b=b[0]):b=a[0].body;return b.offsetWidth+1}}]},vd=\"application/json\",vc={\"Content-Type\":vd+\";charset=utf-8\"},Dg=/^\\[|^\\{(?!\\{)/,Eg={\"[\":/]$/,\"{\":/}$/},Cg=/^\\)]\\}',?\\n/,Kb=M(\"$http\"),Ca=ea.$interpolateMinErr=M(\"$interpolate\");Ca.throwNoconcat=function(a){throw Ca(\"noconcat\",a);};Ca.interr=function(a,b){return Ca(\"interr\",a,b.toString())};var Hg=M(\"$interval\"),Of=function(){this.$get=\nfunction(){function a(a){var b=function(a){b.data=a;b.called=!0};b.id=a;return b}var b=ea.callbacks,d={};return{createCallback:function(c){c=\"_\"+(b.$$counter++).toString(36);var e=\"angular.callbacks.\"+c,f=a(c);d[e]=b[c]=f;return e},wasCalled:function(a){return d[a].called},getResponse:function(a){return d[a].data},removeCallback:function(a){delete b[d[a].id];delete d[a]}}}},lh=/^([^?#]*)(\\?([^#]*))?(#(.*))?$/,Ig={http:80,https:443,ftp:21},jb=M(\"$location\"),Jg=/^\\s*[\\\\/]{2,}/,mh={$$absUrl:\"\",$$html5:!1,\n$$replace:!1,$$compose:function(){for(var a=this.$$path,b=this.$$hash,d=ve(this.$$search),b=b?\"#\"+gc(b):\"\",a=a.split(\"/\"),c=a.length;c--;)a[c]=gc(a[c].replace(/%2F/g,\"/\"));this.$$url=a.join(\"/\")+(d?\"?\"+d:\"\")+b;this.$$absUrl=this.$$normalizeUrl(this.$$url);this.$$urlUpdatedByLocation=!0},absUrl:Lb(\"$$absUrl\"),url:function(a){if(x(a))return this.$$url;var b=lh.exec(a);(b[1]||\"\"===a)&&this.path(decodeURIComponent(b[1]));(b[2]||b[1]||\"\"===a)&&this.search(b[3]||\"\");this.hash(b[5]||\"\");return this},protocol:Lb(\"$$protocol\"),\nhost:Lb(\"$$host\"),port:Lb(\"$$port\"),path:Cd(\"$$path\",function(a){a=null!==a?a.toString():\"\";return\"/\"===a.charAt(0)?a:\"/\"+a}),search:function(a,b){switch(arguments.length){case 0:return this.$$search;case 1:if(C(a)||ba(a))a=a.toString(),this.$$search=fc(a);else if(F(a))a=Ha(a,{}),r(a,function(b,c){null==b&&delete a[c]}),this.$$search=a;else throw jb(\"isrcharg\");break;default:x(b)||null===b?delete this.$$search[a]:this.$$search[a]=b}this.$$compose();return this},hash:Cd(\"$$hash\",function(a){return null!==\na?a.toString():\"\"}),replace:function(){this.$$replace=!0;return this}};r([Bd,yc,xc],function(a){a.prototype=Object.create(mh);a.prototype.state=function(b){if(!arguments.length)return this.$$state;if(a!==xc||!this.$$html5)throw jb(\"nostate\");this.$$state=x(b)?null:b;this.$$urlUpdatedByLocation=!0;return this}});var Ya=M(\"$parse\"),Ng={}.constructor.prototype.valueOf,Tb=S();r(\"+ - * / % === !== == != < > <= >= && || ! = |\".split(\" \"),function(a){Tb[a]=!0});var nh={n:\"\\n\",f:\"\\f\",r:\"\\r\",t:\"\\t\",v:\"\\v\",\n\"'\":\"'\",'\"':'\"'},Nb=function(a){this.options=a};Nb.prototype={constructor:Nb,lex:function(a){this.text=a;this.index=0;for(this.tokens=[];this.index<this.text.length;)if(a=this.text.charAt(this.index),'\"'===a||\"'\"===a)this.readString(a);else if(this.isNumber(a)||\".\"===a&&this.isNumber(this.peek()))this.readNumber();else if(this.isIdentifierStart(this.peekMultichar()))this.readIdent();else if(this.is(a,\"(){}[].,;:?\"))this.tokens.push({index:this.index,text:a}),this.index++;else if(this.isWhitespace(a))this.index++;\nelse{var b=a+this.peek(),d=b+this.peek(2),c=Tb[b],e=Tb[d];Tb[a]||c||e?(a=e?d:c?b:a,this.tokens.push({index:this.index,text:a,operator:!0}),this.index+=a.length):this.throwError(\"Unexpected next character \",this.index,this.index+1)}return this.tokens},is:function(a,b){return-1!==b.indexOf(a)},peek:function(a){a=a||1;return this.index+a<this.text.length?this.text.charAt(this.index+a):!1},isNumber:function(a){return\"0\"<=a&&\"9\">=a&&\"string\"===typeof a},isWhitespace:function(a){return\" \"===a||\"\\r\"===a||\n\"\\t\"===a||\"\\n\"===a||\"\\v\"===a||\"\\u00a0\"===a},isIdentifierStart:function(a){return this.options.isIdentifierStart?this.options.isIdentifierStart(a,this.codePointAt(a)):this.isValidIdentifierStart(a)},isValidIdentifierStart:function(a){return\"a\"<=a&&\"z\">=a||\"A\"<=a&&\"Z\">=a||\"_\"===a||\"$\"===a},isIdentifierContinue:function(a){return this.options.isIdentifierContinue?this.options.isIdentifierContinue(a,this.codePointAt(a)):this.isValidIdentifierContinue(a)},isValidIdentifierContinue:function(a,b){return this.isValidIdentifierStart(a,\nb)||this.isNumber(a)},codePointAt:function(a){return 1===a.length?a.charCodeAt(0):(a.charCodeAt(0)<<10)+a.charCodeAt(1)-56613888},peekMultichar:function(){var a=this.text.charAt(this.index),b=this.peek();if(!b)return a;var d=a.charCodeAt(0),c=b.charCodeAt(0);return 55296<=d&&56319>=d&&56320<=c&&57343>=c?a+b:a},isExpOperator:function(a){return\"-\"===a||\"+\"===a||this.isNumber(a)},throwError:function(a,b,d){d=d||this.index;b=v(b)?\"s \"+b+\"-\"+this.index+\" [\"+this.text.substring(b,d)+\"]\":\" \"+d;throw Ya(\"lexerr\",\na,b,this.text);},readNumber:function(){for(var a=\"\",b=this.index;this.index<this.text.length;){var d=O(this.text.charAt(this.index));if(\".\"===d||this.isNumber(d))a+=d;else{var c=this.peek();if(\"e\"===d&&this.isExpOperator(c))a+=d;else if(this.isExpOperator(d)&&c&&this.isNumber(c)&&\"e\"===a.charAt(a.length-1))a+=d;else if(!this.isExpOperator(d)||c&&this.isNumber(c)||\"e\"!==a.charAt(a.length-1))break;else this.throwError(\"Invalid exponent\")}this.index++}this.tokens.push({index:b,text:a,constant:!0,value:Number(a)})},\nreadIdent:function(){var a=this.index;for(this.index+=this.peekMultichar().length;this.index<this.text.length;){var b=this.peekMultichar();if(!this.isIdentifierContinue(b))break;this.index+=b.length}this.tokens.push({index:a,text:this.text.slice(a,this.index),identifier:!0})},readString:function(a){var b=this.index;this.index++;for(var d=\"\",c=a,e=!1;this.index<this.text.length;){var f=this.text.charAt(this.index),c=c+f;if(e)\"u\"===f?(e=this.text.substring(this.index+1,this.index+5),e.match(/[\\da-f]{4}/i)||\nthis.throwError(\"Invalid unicode escape [\\\\u\"+e+\"]\"),this.index+=4,d+=String.fromCharCode(parseInt(e,16))):d+=nh[f]||f,e=!1;else if(\"\\\\\"===f)e=!0;else{if(f===a){this.index++;this.tokens.push({index:b,text:c,constant:!0,value:d});return}d+=f}this.index++}this.throwError(\"Unterminated quote\",b)}};var p=function(a,b){this.lexer=a;this.options=b};p.Program=\"Program\";p.ExpressionStatement=\"ExpressionStatement\";p.AssignmentExpression=\"AssignmentExpression\";p.ConditionalExpression=\"ConditionalExpression\";\np.LogicalExpression=\"LogicalExpression\";p.BinaryExpression=\"BinaryExpression\";p.UnaryExpression=\"UnaryExpression\";p.CallExpression=\"CallExpression\";p.MemberExpression=\"MemberExpression\";p.Identifier=\"Identifier\";p.Literal=\"Literal\";p.ArrayExpression=\"ArrayExpression\";p.Property=\"Property\";p.ObjectExpression=\"ObjectExpression\";p.ThisExpression=\"ThisExpression\";p.LocalsExpression=\"LocalsExpression\";p.NGValueParameter=\"NGValueParameter\";p.prototype={ast:function(a){this.text=a;this.tokens=this.lexer.lex(a);\na=this.program();0!==this.tokens.length&&this.throwError(\"is an unexpected token\",this.tokens[0]);return a},program:function(){for(var a=[];;)if(0<this.tokens.length&&!this.peek(\"}\",\")\",\";\",\"]\")&&a.push(this.expressionStatement()),!this.expect(\";\"))return{type:p.Program,body:a}},expressionStatement:function(){return{type:p.ExpressionStatement,expression:this.filterChain()}},filterChain:function(){for(var a=this.expression();this.expect(\"|\");)a=this.filter(a);return a},expression:function(){return this.assignment()},\nassignment:function(){var a=this.ternary();if(this.expect(\"=\")){if(!Gd(a))throw Ya(\"lval\");a={type:p.AssignmentExpression,left:a,right:this.assignment(),operator:\"=\"}}return a},ternary:function(){var a=this.logicalOR(),b,d;return this.expect(\"?\")&&(b=this.expression(),this.consume(\":\"))?(d=this.expression(),{type:p.ConditionalExpression,test:a,alternate:b,consequent:d}):a},logicalOR:function(){for(var a=this.logicalAND();this.expect(\"||\");)a={type:p.LogicalExpression,operator:\"||\",left:a,right:this.logicalAND()};\nreturn a},logicalAND:function(){for(var a=this.equality();this.expect(\"&&\");)a={type:p.LogicalExpression,operator:\"&&\",left:a,right:this.equality()};return a},equality:function(){for(var a=this.relational(),b;b=this.expect(\"==\",\"!=\",\"===\",\"!==\");)a={type:p.BinaryExpression,operator:b.text,left:a,right:this.relational()};return a},relational:function(){for(var a=this.additive(),b;b=this.expect(\"<\",\">\",\"<=\",\">=\");)a={type:p.BinaryExpression,operator:b.text,left:a,right:this.additive()};return a},additive:function(){for(var a=\nthis.multiplicative(),b;b=this.expect(\"+\",\"-\");)a={type:p.BinaryExpression,operator:b.text,left:a,right:this.multiplicative()};return a},multiplicative:function(){for(var a=this.unary(),b;b=this.expect(\"*\",\"/\",\"%\");)a={type:p.BinaryExpression,operator:b.text,left:a,right:this.unary()};return a},unary:function(){var a;return(a=this.expect(\"+\",\"-\",\"!\"))?{type:p.UnaryExpression,operator:a.text,prefix:!0,argument:this.unary()}:this.primary()},primary:function(){var a;this.expect(\"(\")?(a=this.filterChain(),\nthis.consume(\")\")):this.expect(\"[\")?a=this.arrayDeclaration():this.expect(\"{\")?a=this.object():this.selfReferential.hasOwnProperty(this.peek().text)?a=Ha(this.selfReferential[this.consume().text]):this.options.literals.hasOwnProperty(this.peek().text)?a={type:p.Literal,value:this.options.literals[this.consume().text]}:this.peek().identifier?a=this.identifier():this.peek().constant?a=this.constant():this.throwError(\"not a primary expression\",this.peek());for(var b;b=this.expect(\"(\",\"[\",\".\");)\"(\"===\nb.text?(a={type:p.CallExpression,callee:a,arguments:this.parseArguments()},this.consume(\")\")):\"[\"===b.text?(a={type:p.MemberExpression,object:a,property:this.expression(),computed:!0},this.consume(\"]\")):\".\"===b.text?a={type:p.MemberExpression,object:a,property:this.identifier(),computed:!1}:this.throwError(\"IMPOSSIBLE\");return a},filter:function(a){a=[a];for(var b={type:p.CallExpression,callee:this.identifier(),arguments:a,filter:!0};this.expect(\":\");)a.push(this.expression());return b},parseArguments:function(){var a=\n[];if(\")\"!==this.peekToken().text){do a.push(this.filterChain());while(this.expect(\",\"))}return a},identifier:function(){var a=this.consume();a.identifier||this.throwError(\"is not a valid identifier\",a);return{type:p.Identifier,name:a.text}},constant:function(){return{type:p.Literal,value:this.consume().value}},arrayDeclaration:function(){var a=[];if(\"]\"!==this.peekToken().text){do{if(this.peek(\"]\"))break;a.push(this.expression())}while(this.expect(\",\"))}this.consume(\"]\");return{type:p.ArrayExpression,\nelements:a}},object:function(){var a=[],b;if(\"}\"!==this.peekToken().text){do{if(this.peek(\"}\"))break;b={type:p.Property,kind:\"init\"};this.peek().constant?(b.key=this.constant(),b.computed=!1,this.consume(\":\"),b.value=this.expression()):this.peek().identifier?(b.key=this.identifier(),b.computed=!1,this.peek(\":\")?(this.consume(\":\"),b.value=this.expression()):b.value=b.key):this.peek(\"[\")?(this.consume(\"[\"),b.key=this.expression(),this.consume(\"]\"),b.computed=!0,this.consume(\":\"),b.value=this.expression()):\nthis.throwError(\"invalid key\",this.peek());a.push(b)}while(this.expect(\",\"))}this.consume(\"}\");return{type:p.ObjectExpression,properties:a}},throwError:function(a,b){throw Ya(\"syntax\",b.text,a,b.index+1,this.text,this.text.substring(b.index));},consume:function(a){if(0===this.tokens.length)throw Ya(\"ueoe\",this.text);var b=this.expect(a);b||this.throwError(\"is unexpected, expecting [\"+a+\"]\",this.peek());return b},peekToken:function(){if(0===this.tokens.length)throw Ya(\"ueoe\",this.text);return this.tokens[0]},\npeek:function(a,b,d,c){return this.peekAhead(0,a,b,d,c)},peekAhead:function(a,b,d,c,e){if(this.tokens.length>a){a=this.tokens[a];var f=a.text;if(f===b||f===d||f===c||f===e||!(b||d||c||e))return a}return!1},expect:function(a,b,d,c){return(a=this.peek(a,b,d,c))?(this.tokens.shift(),a):!1},selfReferential:{\"this\":{type:p.ThisExpression},$locals:{type:p.LocalsExpression}}};var Ed=2;Id.prototype={compile:function(a){var b=this;this.state={nextId:0,filters:{},fn:{vars:[],body:[],own:{}},assign:{vars:[],\nbody:[],own:{}},inputs:[]};Y(a,b.$filter);var d=\"\",c;this.stage=\"assign\";if(c=Hd(a))this.state.computing=\"assign\",d=this.nextId(),this.recurse(c,d),this.return_(d),d=\"fn.assign=\"+this.generateFunction(\"assign\",\"s,v,l\");c=Fd(a.body);b.stage=\"inputs\";r(c,function(a,c){var d=\"fn\"+c;b.state[d]={vars:[],body:[],own:{}};b.state.computing=d;var k=b.nextId();b.recurse(a,k);b.return_(k);b.state.inputs.push({name:d,isPure:a.isPure});a.watchId=c});this.state.computing=\"fn\";this.stage=\"main\";this.recurse(a);\na='\"'+this.USE+\" \"+this.STRICT+'\";\\n'+this.filterPrefix()+\"var fn=\"+this.generateFunction(\"fn\",\"s,l,a,i\")+d+this.watchFns()+\"return fn;\";a=(new Function(\"$filter\",\"getStringValue\",\"ifDefined\",\"plus\",a))(this.$filter,Kg,Lg,Dd);this.state=this.stage=void 0;return a},USE:\"use\",STRICT:\"strict\",watchFns:function(){var a=[],b=this.state.inputs,d=this;r(b,function(b){a.push(\"var \"+b.name+\"=\"+d.generateFunction(b.name,\"s\"));b.isPure&&a.push(b.name,\".isPure=\"+JSON.stringify(b.isPure)+\";\")});b.length&&a.push(\"fn.inputs=[\"+\nb.map(function(a){return a.name}).join(\",\")+\"];\");return a.join(\"\")},generateFunction:function(a,b){return\"function(\"+b+\"){\"+this.varsPrefix(a)+this.body(a)+\"};\"},filterPrefix:function(){var a=[],b=this;r(this.state.filters,function(d,c){a.push(d+\"=$filter(\"+b.escape(c)+\")\")});return a.length?\"var \"+a.join(\",\")+\";\":\"\"},varsPrefix:function(a){return this.state[a].vars.length?\"var \"+this.state[a].vars.join(\",\")+\";\":\"\"},body:function(a){return this.state[a].body.join(\"\")},recurse:function(a,b,d,c,e,\nf){var g,k,h=this,l,m,q;c=c||A;if(!f&&v(a.watchId))b=b||this.nextId(),this.if_(\"i\",this.lazyAssign(b,this.computedMember(\"i\",a.watchId)),this.lazyRecurse(a,b,d,c,e,!0));else switch(a.type){case p.Program:r(a.body,function(b,c){h.recurse(b.expression,void 0,void 0,function(a){k=a});c!==a.body.length-1?h.current().body.push(k,\";\"):h.return_(k)});break;case p.Literal:m=this.escape(a.value);this.assign(b,m);c(b||m);break;case p.UnaryExpression:this.recurse(a.argument,void 0,void 0,function(a){k=a});m=\na.operator+\"(\"+this.ifDefined(k,0)+\")\";this.assign(b,m);c(m);break;case p.BinaryExpression:this.recurse(a.left,void 0,void 0,function(a){g=a});this.recurse(a.right,void 0,void 0,function(a){k=a});m=\"+\"===a.operator?this.plus(g,k):\"-\"===a.operator?this.ifDefined(g,0)+a.operator+this.ifDefined(k,0):\"(\"+g+\")\"+a.operator+\"(\"+k+\")\";this.assign(b,m);c(m);break;case p.LogicalExpression:b=b||this.nextId();h.recurse(a.left,b);h.if_(\"&&\"===a.operator?b:h.not(b),h.lazyRecurse(a.right,b));c(b);break;case p.ConditionalExpression:b=\nb||this.nextId();h.recurse(a.test,b);h.if_(b,h.lazyRecurse(a.alternate,b),h.lazyRecurse(a.consequent,b));c(b);break;case p.Identifier:b=b||this.nextId();d&&(d.context=\"inputs\"===h.stage?\"s\":this.assign(this.nextId(),this.getHasOwnProperty(\"l\",a.name)+\"?l:s\"),d.computed=!1,d.name=a.name);h.if_(\"inputs\"===h.stage||h.not(h.getHasOwnProperty(\"l\",a.name)),function(){h.if_(\"inputs\"===h.stage||\"s\",function(){e&&1!==e&&h.if_(h.isNull(h.nonComputedMember(\"s\",a.name)),h.lazyAssign(h.nonComputedMember(\"s\",a.name),\n\"{}\"));h.assign(b,h.nonComputedMember(\"s\",a.name))})},b&&h.lazyAssign(b,h.nonComputedMember(\"l\",a.name)));c(b);break;case p.MemberExpression:g=d&&(d.context=this.nextId())||this.nextId();b=b||this.nextId();h.recurse(a.object,g,void 0,function(){h.if_(h.notNull(g),function(){a.computed?(k=h.nextId(),h.recurse(a.property,k),h.getStringValue(k),e&&1!==e&&h.if_(h.not(h.computedMember(g,k)),h.lazyAssign(h.computedMember(g,k),\"{}\")),m=h.computedMember(g,k),h.assign(b,m),d&&(d.computed=!0,d.name=k)):(e&&\n1!==e&&h.if_(h.isNull(h.nonComputedMember(g,a.property.name)),h.lazyAssign(h.nonComputedMember(g,a.property.name),\"{}\")),m=h.nonComputedMember(g,a.property.name),h.assign(b,m),d&&(d.computed=!1,d.name=a.property.name))},function(){h.assign(b,\"undefined\")});c(b)},!!e);break;case p.CallExpression:b=b||this.nextId();a.filter?(k=h.filter(a.callee.name),l=[],r(a.arguments,function(a){var b=h.nextId();h.recurse(a,b);l.push(b)}),m=k+\"(\"+l.join(\",\")+\")\",h.assign(b,m),c(b)):(k=h.nextId(),g={},l=[],h.recurse(a.callee,\nk,g,function(){h.if_(h.notNull(k),function(){r(a.arguments,function(b){h.recurse(b,a.constant?void 0:h.nextId(),void 0,function(a){l.push(a)})});m=g.name?h.member(g.context,g.name,g.computed)+\"(\"+l.join(\",\")+\")\":k+\"(\"+l.join(\",\")+\")\";h.assign(b,m)},function(){h.assign(b,\"undefined\")});c(b)}));break;case p.AssignmentExpression:k=this.nextId();g={};this.recurse(a.left,void 0,g,function(){h.if_(h.notNull(g.context),function(){h.recurse(a.right,k);m=h.member(g.context,g.name,g.computed)+a.operator+k;\nh.assign(b,m);c(b||m)})},1);break;case p.ArrayExpression:l=[];r(a.elements,function(b){h.recurse(b,a.constant?void 0:h.nextId(),void 0,function(a){l.push(a)})});m=\"[\"+l.join(\",\")+\"]\";this.assign(b,m);c(b||m);break;case p.ObjectExpression:l=[];q=!1;r(a.properties,function(a){a.computed&&(q=!0)});q?(b=b||this.nextId(),this.assign(b,\"{}\"),r(a.properties,function(a){a.computed?(g=h.nextId(),h.recurse(a.key,g)):g=a.key.type===p.Identifier?a.key.name:\"\"+a.key.value;k=h.nextId();h.recurse(a.value,k);h.assign(h.member(b,\ng,a.computed),k)})):(r(a.properties,function(b){h.recurse(b.value,a.constant?void 0:h.nextId(),void 0,function(a){l.push(h.escape(b.key.type===p.Identifier?b.key.name:\"\"+b.key.value)+\":\"+a)})}),m=\"{\"+l.join(\",\")+\"}\",this.assign(b,m));c(b||m);break;case p.ThisExpression:this.assign(b,\"s\");c(b||\"s\");break;case p.LocalsExpression:this.assign(b,\"l\");c(b||\"l\");break;case p.NGValueParameter:this.assign(b,\"v\"),c(b||\"v\")}},getHasOwnProperty:function(a,b){var d=a+\".\"+b,c=this.current().own;c.hasOwnProperty(d)||\n(c[d]=this.nextId(!1,a+\"&&(\"+this.escape(b)+\" in \"+a+\")\"));return c[d]},assign:function(a,b){if(a)return this.current().body.push(a,\"=\",b,\";\"),a},filter:function(a){this.state.filters.hasOwnProperty(a)||(this.state.filters[a]=this.nextId(!0));return this.state.filters[a]},ifDefined:function(a,b){return\"ifDefined(\"+a+\",\"+this.escape(b)+\")\"},plus:function(a,b){return\"plus(\"+a+\",\"+b+\")\"},return_:function(a){this.current().body.push(\"return \",a,\";\")},if_:function(a,b,d){if(!0===a)b();else{var c=this.current().body;\nc.push(\"if(\",a,\"){\");b();c.push(\"}\");d&&(c.push(\"else{\"),d(),c.push(\"}\"))}},not:function(a){return\"!(\"+a+\")\"},isNull:function(a){return a+\"==null\"},notNull:function(a){return a+\"!=null\"},nonComputedMember:function(a,b){var d=/[^$_a-zA-Z0-9]/g;return/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(b)?a+\".\"+b:a+'[\"'+b.replace(d,this.stringEscapeFn)+'\"]'},computedMember:function(a,b){return a+\"[\"+b+\"]\"},member:function(a,b,d){return d?this.computedMember(a,b):this.nonComputedMember(a,b)},getStringValue:function(a){this.assign(a,\n\"getStringValue(\"+a+\")\")},lazyRecurse:function(a,b,d,c,e,f){var g=this;return function(){g.recurse(a,b,d,c,e,f)}},lazyAssign:function(a,b){var d=this;return function(){d.assign(a,b)}},stringEscapeRegex:/[^ a-zA-Z0-9]/g,stringEscapeFn:function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)},escape:function(a){if(C(a))return\"'\"+a.replace(this.stringEscapeRegex,this.stringEscapeFn)+\"'\";if(ba(a))return a.toString();if(!0===a)return\"true\";if(!1===a)return\"false\";if(null===a)return\"null\";\nif(\"undefined\"===typeof a)return\"undefined\";throw Ya(\"esc\");},nextId:function(a,b){var d=\"v\"+this.state.nextId++;a||this.current().vars.push(d+(b?\"=\"+b:\"\"));return d},current:function(){return this.state[this.state.computing]}};Jd.prototype={compile:function(a){var b=this;Y(a,b.$filter);var d,c;if(d=Hd(a))c=this.recurse(d);d=Fd(a.body);var e;d&&(e=[],r(d,function(a,c){var d=b.recurse(a);d.isPure=a.isPure;a.input=d;e.push(d);a.watchId=c}));var f=[];r(a.body,function(a){f.push(b.recurse(a.expression))});\na=0===a.body.length?A:1===a.body.length?f[0]:function(a,b){var c;r(f,function(d){c=d(a,b)});return c};c&&(a.assign=function(a,b,d){return c(a,d,b)});e&&(a.inputs=e);return a},recurse:function(a,b,d){var c,e,f=this,g;if(a.input)return this.inputs(a.input,a.watchId);switch(a.type){case p.Literal:return this.value(a.value,b);case p.UnaryExpression:return e=this.recurse(a.argument),this[\"unary\"+a.operator](e,b);case p.BinaryExpression:return c=this.recurse(a.left),e=this.recurse(a.right),this[\"binary\"+\na.operator](c,e,b);case p.LogicalExpression:return c=this.recurse(a.left),e=this.recurse(a.right),this[\"binary\"+a.operator](c,e,b);case p.ConditionalExpression:return this[\"ternary?:\"](this.recurse(a.test),this.recurse(a.alternate),this.recurse(a.consequent),b);case p.Identifier:return f.identifier(a.name,b,d);case p.MemberExpression:return c=this.recurse(a.object,!1,!!d),a.computed||(e=a.property.name),a.computed&&(e=this.recurse(a.property)),a.computed?this.computedMember(c,e,b,d):this.nonComputedMember(c,\ne,b,d);case p.CallExpression:return g=[],r(a.arguments,function(a){g.push(f.recurse(a))}),a.filter&&(e=this.$filter(a.callee.name)),a.filter||(e=this.recurse(a.callee,!0)),a.filter?function(a,c,d,f){for(var q=[],n=0;n<g.length;++n)q.push(g[n](a,c,d,f));a=e.apply(void 0,q,f);return b?{context:void 0,name:void 0,value:a}:a}:function(a,c,d,f){var q=e(a,c,d,f),n;if(null!=q.value){n=[];for(var s=0;s<g.length;++s)n.push(g[s](a,c,d,f));n=q.value.apply(q.context,n)}return b?{value:n}:n};case p.AssignmentExpression:return c=\nthis.recurse(a.left,!0,1),e=this.recurse(a.right),function(a,d,f,g){var q=c(a,d,f,g);a=e(a,d,f,g);q.context[q.name]=a;return b?{value:a}:a};case p.ArrayExpression:return g=[],r(a.elements,function(a){g.push(f.recurse(a))}),function(a,c,d,e){for(var f=[],n=0;n<g.length;++n)f.push(g[n](a,c,d,e));return b?{value:f}:f};case p.ObjectExpression:return g=[],r(a.properties,function(a){a.computed?g.push({key:f.recurse(a.key),computed:!0,value:f.recurse(a.value)}):g.push({key:a.key.type===p.Identifier?a.key.name:\n\"\"+a.key.value,computed:!1,value:f.recurse(a.value)})}),function(a,c,d,e){for(var f={},n=0;n<g.length;++n)g[n].computed?f[g[n].key(a,c,d,e)]=g[n].value(a,c,d,e):f[g[n].key]=g[n].value(a,c,d,e);return b?{value:f}:f};case p.ThisExpression:return function(a){return b?{value:a}:a};case p.LocalsExpression:return function(a,c){return b?{value:c}:c};case p.NGValueParameter:return function(a,c,d){return b?{value:d}:d}}},\"unary+\":function(a,b){return function(d,c,e,f){d=a(d,c,e,f);d=v(d)?+d:0;return b?{value:d}:\nd}},\"unary-\":function(a,b){return function(d,c,e,f){d=a(d,c,e,f);d=v(d)?-d:-0;return b?{value:d}:d}},\"unary!\":function(a,b){return function(d,c,e,f){d=!a(d,c,e,f);return b?{value:d}:d}},\"binary+\":function(a,b,d){return function(c,e,f,g){var k=a(c,e,f,g);c=b(c,e,f,g);k=Dd(k,c);return d?{value:k}:k}},\"binary-\":function(a,b,d){return function(c,e,f,g){var k=a(c,e,f,g);c=b(c,e,f,g);k=(v(k)?k:0)-(v(c)?c:0);return d?{value:k}:k}},\"binary*\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)*b(c,e,f,g);\nreturn d?{value:c}:c}},\"binary/\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)/b(c,e,f,g);return d?{value:c}:c}},\"binary%\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)%b(c,e,f,g);return d?{value:c}:c}},\"binary===\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)===b(c,e,f,g);return d?{value:c}:c}},\"binary!==\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)!==b(c,e,f,g);return d?{value:c}:c}},\"binary==\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)==b(c,e,f,g);return d?\n{value:c}:c}},\"binary!=\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)!=b(c,e,f,g);return d?{value:c}:c}},\"binary<\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)<b(c,e,f,g);return d?{value:c}:c}},\"binary>\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)>b(c,e,f,g);return d?{value:c}:c}},\"binary<=\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)<=b(c,e,f,g);return d?{value:c}:c}},\"binary>=\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)>=b(c,e,f,g);return d?{value:c}:\nc}},\"binary&&\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)&&b(c,e,f,g);return d?{value:c}:c}},\"binary||\":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)||b(c,e,f,g);return d?{value:c}:c}},\"ternary?:\":function(a,b,d,c){return function(e,f,g,k){e=a(e,f,g,k)?b(e,f,g,k):d(e,f,g,k);return c?{value:e}:e}},value:function(a,b){return function(){return b?{context:void 0,name:void 0,value:a}:a}},identifier:function(a,b,d){return function(c,e,f,g){c=e&&a in e?e:c;d&&1!==d&&c&&null==c[a]&&(c[a]=\n{});e=c?c[a]:void 0;return b?{context:c,name:a,value:e}:e}},computedMember:function(a,b,d,c){return function(e,f,g,k){var h=a(e,f,g,k),l,m;null!=h&&(l=b(e,f,g,k),l+=\"\",c&&1!==c&&h&&!h[l]&&(h[l]={}),m=h[l]);return d?{context:h,name:l,value:m}:m}},nonComputedMember:function(a,b,d,c){return function(e,f,g,k){e=a(e,f,g,k);c&&1!==c&&e&&null==e[b]&&(e[b]={});f=null!=e?e[b]:void 0;return d?{context:e,name:b,value:f}:f}},inputs:function(a,b){return function(d,c,e,f){return f?f[b]:a(d,c,e)}}};Mb.prototype=\n{constructor:Mb,parse:function(a){a=this.getAst(a);var b=this.astCompiler.compile(a.ast),d=a.ast;b.literal=0===d.body.length||1===d.body.length&&(d.body[0].expression.type===p.Literal||d.body[0].expression.type===p.ArrayExpression||d.body[0].expression.type===p.ObjectExpression);b.constant=a.ast.constant;b.oneTime=a.oneTime;return b},getAst:function(a){var b=!1;a=a.trim();\":\"===a.charAt(0)&&\":\"===a.charAt(1)&&(b=!0,a=a.substring(2));return{ast:this.ast.ast(a),oneTime:b}}};var Da=M(\"$sce\"),U={HTML:\"html\",\nCSS:\"css\",MEDIA_URL:\"mediaUrl\",URL:\"url\",RESOURCE_URL:\"resourceUrl\",JS:\"js\"},Bc=/_([a-z])/g,Qg=M(\"$templateRequest\"),Rg=M(\"$timeout\"),$=B.document.createElement(\"a\"),Nd=la(B.location.href),La;Od.$inject=[\"$document\"];cd.$inject=[\"$provide\"];var Vd=22,Ud=\".\",Dc=\"0\";Pd.$inject=[\"$locale\"];Rd.$inject=[\"$locale\"];var bh={yyyy:ga(\"FullYear\",4,0,!1,!0),yy:ga(\"FullYear\",2,0,!0,!0),y:ga(\"FullYear\",1,0,!1,!0),MMMM:kb(\"Month\"),MMM:kb(\"Month\",!0),MM:ga(\"Month\",2,1),M:ga(\"Month\",1,1),LLLL:kb(\"Month\",!1,!0),dd:ga(\"Date\",\n2),d:ga(\"Date\",1),HH:ga(\"Hours\",2),H:ga(\"Hours\",1),hh:ga(\"Hours\",2,-12),h:ga(\"Hours\",1,-12),mm:ga(\"Minutes\",2),m:ga(\"Minutes\",1),ss:ga(\"Seconds\",2),s:ga(\"Seconds\",1),sss:ga(\"Milliseconds\",3),EEEE:kb(\"Day\"),EEE:kb(\"Day\",!0),a:function(a,b){return 12>a.getHours()?b.AMPMS[0]:b.AMPMS[1]},Z:function(a,b,d){a=-1*d;return a=(0<=a?\"+\":\"\")+(Ob(Math[0<a?\"floor\":\"ceil\"](a/60),2)+Ob(Math.abs(a%60),2))},ww:Xd(2),w:Xd(1),G:Ec,GG:Ec,GGG:Ec,GGGG:function(a,b){return 0>=a.getFullYear()?b.ERANAMES[0]:b.ERANAMES[1]}},\nah=/((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\\s\\S]*)/,$g=/^-?\\d+$/;Qd.$inject=[\"$locale\"];var Vg=ia(O),Wg=ia(ub);Sd.$inject=[\"$parse\"];var Je=ia({restrict:\"E\",compile:function(a,b){if(!b.href&&!b.xlinkHref)return function(a,b){if(\"a\"===b[0].nodeName.toLowerCase()){var e=\"[object SVGAnimatedString]\"===ma.call(b.prop(\"href\"))?\"xlink:href\":\"href\";b.on(\"click\",function(a){b.attr(e)||a.preventDefault()})}}}}),vb={};r(Gb,function(a,b){function d(a,d,e){a.$watch(e[c],\nfunction(a){e.$set(b,!!a)})}if(\"multiple\"!==a){var c=va(\"ng-\"+b),e=d;\"checked\"===a&&(e=function(a,b,e){e.ngModel!==e[c]&&d(a,b,e)});vb[c]=function(){return{restrict:\"A\",priority:100,link:e}}}});r(sd,function(a,b){vb[b]=function(){return{priority:100,link:function(a,c,e){if(\"ngPattern\"===b&&\"/\"===e.ngPattern.charAt(0)&&(c=e.ngPattern.match(fh))){e.$set(\"ngPattern\",new RegExp(c[1],c[2]));return}a.$watch(e[b],function(a){e.$set(b,a)})}}}});r([\"src\",\"srcset\",\"href\"],function(a){var b=va(\"ng-\"+a);vb[b]=\nfunction(){return{priority:99,link:function(d,c,e){var f=a,g=a;\"href\"===a&&\"[object SVGAnimatedString]\"===ma.call(c.prop(\"href\"))&&(g=\"xlinkHref\",e.$attr[g]=\"xlink:href\",f=null);e.$observe(b,function(b){b?(e.$set(g,b),Aa&&f&&c.prop(f,e[g])):\"href\"===a&&e.$set(g,null)})}}}});var lb={$addControl:A,$getControls:ia([]),$$renameControl:function(a,b){a.$name=b},$removeControl:A,$setValidity:A,$setDirty:A,$setPristine:A,$setSubmitted:A,$$setSubmitted:A};Pb.$inject=[\"$element\",\"$attrs\",\"$scope\",\"$animate\",\n\"$interpolate\"];Pb.prototype={$rollbackViewValue:function(){r(this.$$controls,function(a){a.$rollbackViewValue()})},$commitViewValue:function(){r(this.$$controls,function(a){a.$commitViewValue()})},$addControl:function(a){Qa(a.$name,\"input\");this.$$controls.push(a);a.$name&&(this[a.$name]=a);a.$$parentForm=this},$getControls:function(){return oa(this.$$controls)},$$renameControl:function(a,b){var d=a.$name;this[d]===a&&delete this[d];this[b]=a;a.$name=b},$removeControl:function(a){a.$name&&this[a.$name]===\na&&delete this[a.$name];r(this.$pending,function(b,d){this.$setValidity(d,null,a)},this);r(this.$error,function(b,d){this.$setValidity(d,null,a)},this);r(this.$$success,function(b,d){this.$setValidity(d,null,a)},this);cb(this.$$controls,a);a.$$parentForm=lb},$setDirty:function(){this.$$animate.removeClass(this.$$element,Za);this.$$animate.addClass(this.$$element,Ub);this.$dirty=!0;this.$pristine=!1;this.$$parentForm.$setDirty()},$setPristine:function(){this.$$animate.setClass(this.$$element,Za,Ub+\n\" ng-submitted\");this.$dirty=!1;this.$pristine=!0;this.$submitted=!1;r(this.$$controls,function(a){a.$setPristine()})},$setUntouched:function(){r(this.$$controls,function(a){a.$setUntouched()})},$setSubmitted:function(){for(var a=this;a.$$parentForm&&a.$$parentForm!==lb;)a=a.$$parentForm;a.$$setSubmitted()},$$setSubmitted:function(){this.$$animate.addClass(this.$$element,\"ng-submitted\");this.$submitted=!0;r(this.$$controls,function(a){a.$$setSubmitted&&a.$$setSubmitted()})}};$d({clazz:Pb,set:function(a,\nb,d){var c=a[b];c?-1===c.indexOf(d)&&c.push(d):a[b]=[d]},unset:function(a,b,d){var c=a[b];c&&(cb(c,d),0===c.length&&delete a[b])}});var he=function(a){return[\"$timeout\",\"$parse\",function(b,d){function c(a){return\"\"===a?d('this[\"\"]').assign:d(a).assign||A}return{name:\"form\",restrict:a?\"EAC\":\"E\",require:[\"form\",\"^^?form\"],controller:Pb,compile:function(d,f){d.addClass(Za).addClass(mb);var g=f.name?\"name\":a&&f.ngForm?\"ngForm\":!1;return{pre:function(a,d,e,f){var q=f[0];if(!(\"action\"in e)){var n=function(b){a.$apply(function(){q.$commitViewValue();\nq.$setSubmitted()});b.preventDefault()};d[0].addEventListener(\"submit\",n);d.on(\"$destroy\",function(){b(function(){d[0].removeEventListener(\"submit\",n)},0,!1)})}(f[1]||q.$$parentForm).$addControl(q);var s=g?c(q.$name):A;g&&(s(a,q),e.$observe(g,function(b){q.$name!==b&&(s(a,void 0),q.$$parentForm.$$renameControl(q,b),s=c(q.$name),s(a,q))}));d.on(\"$destroy\",function(){q.$$parentForm.$removeControl(q);s(a,void 0);R(q,lb)})}}}}}]},Ke=he(),We=he(!0),ch=/^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/,\noh=/^[a-z][a-z\\d.+-]*:\\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\\s:/?#]+|\\[[a-f\\d:]+])(?::\\d+)?(?:\\/[^?#]*)?(?:\\?[^#]*)?(?:#.*)?$/i,ph=/^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/,dh=/^\\s*(-|\\+)?(\\d+|(\\d*(\\.\\d*)))([eE][+-]?\\d+)?\\s*$/,ie=/^(\\d{4,})-(\\d{2})-(\\d{2})$/,je=/^(\\d{4,})-(\\d\\d)-(\\d\\d)T(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/,Lc=/^(\\d{4,})-W(\\d\\d)$/,ke=/^(\\d{4,})-(\\d\\d)$/,\nle=/^(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/,be=S();r([\"date\",\"datetime-local\",\"month\",\"time\",\"week\"],function(a){be[a]=!0});var me={text:function(a,b,d,c,e,f){Ra(a,b,d,c,e,f);Gc(c)},date:nb(\"date\",ie,Qb(ie,[\"yyyy\",\"MM\",\"dd\"]),\"yyyy-MM-dd\"),\"datetime-local\":nb(\"datetimelocal\",je,Qb(je,\"yyyy MM dd HH mm ss sss\".split(\" \")),\"yyyy-MM-ddTHH:mm:ss.sss\"),time:nb(\"time\",le,Qb(le,[\"HH\",\"mm\",\"ss\",\"sss\"]),\"HH:mm:ss.sss\"),week:nb(\"week\",Lc,function(a,b){if(ha(a))return a;if(C(a)){Lc.lastIndex=0;var d=Lc.exec(a);\nif(d){var c=+d[1],e=+d[2],f=d=0,g=0,k=0,h=Wd(c),e=7*(e-1);b&&(d=b.getHours(),f=b.getMinutes(),g=b.getSeconds(),k=b.getMilliseconds());return new Date(c,0,h.getDate()+e,d,f,g,k)}}return NaN},\"yyyy-Www\"),month:nb(\"month\",ke,Qb(ke,[\"yyyy\",\"MM\"]),\"yyyy-MM\"),number:function(a,b,d,c,e,f){Hc(a,b,d,c,\"number\");ce(c);Ra(a,b,d,c,e,f);var g,k;if(v(d.min)||d.ngMin)c.$validators.min=function(a,b){return c.$isEmpty(b)||x(g)||b>=g},d.$observe(\"min\",function(a){g=Sa(a);c.$validate()});if(v(d.max)||d.ngMax)c.$validators.max=\nfunction(a,b){return c.$isEmpty(b)||x(k)||b<=k},d.$observe(\"max\",function(a){k=Sa(a);c.$validate()});if(v(d.step)||d.ngStep){var h;c.$validators.step=function(a,b){return c.$isEmpty(b)||x(h)||de(b,g||0,h)};d.$observe(\"step\",function(a){h=Sa(a);c.$validate()})}},url:function(a,b,d,c,e,f){Ra(a,b,d,c,e,f);Gc(c);c.$validators.url=function(a,b){var d=a||b;return c.$isEmpty(d)||oh.test(d)}},email:function(a,b,d,c,e,f){Ra(a,b,d,c,e,f);Gc(c);c.$validators.email=function(a,b){var d=a||b;return c.$isEmpty(d)||\nph.test(d)}},radio:function(a,b,d,c){var e=!d.ngTrim||\"false\"!==T(d.ngTrim);x(d.name)&&b.attr(\"name\",++pb);b.on(\"change\",function(a){var g;b[0].checked&&(g=d.value,e&&(g=T(g)),c.$setViewValue(g,a&&a.type))});c.$render=function(){var a=d.value;e&&(a=T(a));b[0].checked=a===c.$viewValue};d.$observe(\"value\",c.$render)},range:function(a,b,d,c,e,f){function g(a,c){b.attr(a,d[a]);d.$observe(a,c)}function k(a){q=Sa(a);V(c.$modelValue)||(m?(a=b.val(),q>a&&(a=q,b.val(a)),c.$setViewValue(a)):c.$validate())}\nfunction h(a){n=Sa(a);V(c.$modelValue)||(m?(a=b.val(),n<a&&(b.val(n),a=n<q?q:n),c.$setViewValue(a)):c.$validate())}function l(a){s=Sa(a);V(c.$modelValue)||(m&&c.$viewValue!==b.val()?c.$setViewValue(b.val()):c.$validate())}Hc(a,b,d,c,\"range\");ce(c);Ra(a,b,d,c,e,f);var m=c.$$hasNativeValidators&&\"range\"===b[0].type,q=m?0:void 0,n=m?100:void 0,s=m?1:void 0,p=b[0].validity;a=v(d.min);e=v(d.max);f=v(d.step);var r=c.$render;c.$render=m&&v(p.rangeUnderflow)&&v(p.rangeOverflow)?function(){r();c.$setViewValue(b.val())}:\nr;a&&(c.$validators.min=m?function(){return!0}:function(a,b){return c.$isEmpty(b)||x(q)||b>=q},g(\"min\",k));e&&(c.$validators.max=m?function(){return!0}:function(a,b){return c.$isEmpty(b)||x(n)||b<=n},g(\"max\",h));f&&(c.$validators.step=m?function(){return!p.stepMismatch}:function(a,b){return c.$isEmpty(b)||x(s)||de(b,q||0,s)},g(\"step\",l))},checkbox:function(a,b,d,c,e,f,g,k){var h=ee(k,a,\"ngTrueValue\",d.ngTrueValue,!0),l=ee(k,a,\"ngFalseValue\",d.ngFalseValue,!1);b.on(\"change\",function(a){c.$setViewValue(b[0].checked,\na&&a.type)});c.$render=function(){b[0].checked=c.$viewValue};c.$isEmpty=function(a){return!1===a};c.$formatters.push(function(a){return ua(a,h)});c.$parsers.push(function(a){return a?h:l})},hidden:A,button:A,submit:A,reset:A,file:A},Xc=[\"$browser\",\"$sniffer\",\"$filter\",\"$parse\",function(a,b,d,c){return{restrict:\"E\",require:[\"?ngModel\"],link:{pre:function(e,f,g,k){k[0]&&(me[O(g.type)]||me.text)(e,f,g,k[0],b,a,d,c)}}}}],qh=/^(true|false|\\d+)$/,pf=function(){function a(a,d,c){var e=v(c)?c:9===Aa?\"\":null;\na.prop(\"value\",e);d.$set(\"value\",c)}return{restrict:\"A\",priority:100,compile:function(b,d){return qh.test(d.ngValue)?function(b,d,f){b=b.$eval(f.ngValue);a(d,f,b)}:function(b,d,f){b.$watch(f.ngValue,function(b){a(d,f,b)})}}}},Oe=[\"$compile\",function(a){return{restrict:\"AC\",compile:function(b){a.$$addBindingClass(b);return function(b,c,e){a.$$addBindingInfo(c,e.ngBind);c=c[0];b.$watch(e.ngBind,function(a){c.textContent=hc(a)})}}}}],Qe=[\"$interpolate\",\"$compile\",function(a,b){return{compile:function(d){b.$$addBindingClass(d);\nreturn function(c,d,f){c=a(d.attr(f.$attr.ngBindTemplate));b.$$addBindingInfo(d,c.expressions);d=d[0];f.$observe(\"ngBindTemplate\",function(a){d.textContent=x(a)?\"\":a})}}}}],Pe=[\"$sce\",\"$parse\",\"$compile\",function(a,b,d){return{restrict:\"A\",compile:function(c,e){var f=b(e.ngBindHtml),g=b(e.ngBindHtml,function(b){return a.valueOf(b)});d.$$addBindingClass(c);return function(b,c,e){d.$$addBindingInfo(c,e.ngBindHtml);b.$watch(g,function(){var d=f(b);c.html(a.getTrustedHtml(d)||\"\")})}}}}],of=ia({restrict:\"A\",\nrequire:\"ngModel\",link:function(a,b,d,c){c.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),Re=Jc(\"\",!0),Te=Jc(\"Odd\",0),Se=Jc(\"Even\",1),Ue=Na({compile:function(a,b){b.$set(\"ngCloak\",void 0);a.removeClass(\"ng-cloak\")}}),Ve=[function(){return{restrict:\"A\",scope:!0,controller:\"@\",priority:500}}],bd={},rh={blur:!0,focus:!0};r(\"click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste\".split(\" \"),function(a){var b=\nva(\"ng-\"+a);bd[b]=[\"$parse\",\"$rootScope\",\"$exceptionHandler\",function(d,c,e){return pd(d,c,e,b,a,rh[a])}]});var Ye=[\"$animate\",\"$compile\",function(a,b){return{multiElement:!0,transclude:\"element\",priority:600,terminal:!0,restrict:\"A\",$$tlb:!0,link:function(d,c,e,f,g){var k,h,l;d.$watch(e.ngIf,function(d){d?h||g(function(d,f){h=f;d[d.length++]=b.$$createComment(\"end ngIf\",e.ngIf);k={clone:d};a.enter(d,c.parent(),c)}):(l&&(l.remove(),l=null),h&&(h.$destroy(),h=null),k&&(l=tb(k.clone),a.leave(l).done(function(a){!1!==\na&&(l=null)}),k=null))})}}}],Ze=[\"$templateRequest\",\"$anchorScroll\",\"$animate\",function(a,b,d){return{restrict:\"ECA\",priority:400,terminal:!0,transclude:\"element\",controller:ea.noop,compile:function(c,e){var f=e.ngInclude||e.src,g=e.onload||\"\",k=e.autoscroll;return function(c,e,m,q,n){var s=0,p,r,D,w=function(){r&&(r.remove(),r=null);p&&(p.$destroy(),p=null);D&&(d.leave(D).done(function(a){!1!==a&&(r=null)}),r=D,D=null)};c.$watch(f,function(f){var m=function(a){!1===a||!v(k)||k&&!c.$eval(k)||b()},\nr=++s;f?(a(f,!0).then(function(a){if(!c.$$destroyed&&r===s){var b=c.$new();q.template=a;a=n(b,function(a){w();d.enter(a,null,e).done(m)});p=b;D=a;p.$emit(\"$includeContentLoaded\",f);c.$eval(g)}},function(){c.$$destroyed||r!==s||(w(),c.$emit(\"$includeContentError\",f))}),c.$emit(\"$includeContentRequested\",f)):(w(),q.template=null)})}}}}],rf=[\"$compile\",function(a){return{restrict:\"ECA\",priority:-400,require:\"ngInclude\",link:function(b,d,c,e){ma.call(d[0]).match(/SVG/)?(d.empty(),a(dd(e.template,B.document).childNodes)(b,\nfunction(a){d.append(a)},{futureParentElement:d})):(d.html(e.template),a(d.contents())(b))}}}],$e=Na({priority:450,compile:function(){return{pre:function(a,b,d){a.$eval(d.ngInit)}}}}),nf=function(){return{restrict:\"A\",priority:100,require:\"ngModel\",link:function(a,b,d,c){var e=d.ngList||\", \",f=\"false\"!==d.ngTrim,g=f?T(e):e;c.$parsers.push(function(a){if(!x(a)){var b=[];a&&r(a.split(g),function(a){a&&b.push(f?T(a):a)});return b}});c.$formatters.push(function(a){if(I(a))return a.join(e)});c.$isEmpty=\nfunction(a){return!a||!a.length}}}},mb=\"ng-valid\",Zd=\"ng-invalid\",Za=\"ng-pristine\",Ub=\"ng-dirty\",ob=M(\"ngModel\");Rb.$inject=\"$scope $exceptionHandler $attrs $element $parse $animate $timeout $q $interpolate\".split(\" \");Rb.prototype={$$initGetterSetters:function(){if(this.$options.getOption(\"getterSetter\")){var a=this.$$parse(this.$$attr.ngModel+\"()\"),b=this.$$parse(this.$$attr.ngModel+\"($$$p)\");this.$$ngModelGet=function(b){var c=this.$$parsedNgModel(b);z(c)&&(c=a(b));return c};this.$$ngModelSet=\nfunction(a,c){z(this.$$parsedNgModel(a))?b(a,{$$$p:c}):this.$$parsedNgModelAssign(a,c)}}else if(!this.$$parsedNgModel.assign)throw ob(\"nonassign\",this.$$attr.ngModel,ya(this.$$element));},$render:A,$isEmpty:function(a){return x(a)||\"\"===a||null===a||a!==a},$$updateEmptyClasses:function(a){this.$isEmpty(a)?(this.$$animate.removeClass(this.$$element,\"ng-not-empty\"),this.$$animate.addClass(this.$$element,\"ng-empty\")):(this.$$animate.removeClass(this.$$element,\"ng-empty\"),this.$$animate.addClass(this.$$element,\n\"ng-not-empty\"))},$setPristine:function(){this.$dirty=!1;this.$pristine=!0;this.$$animate.removeClass(this.$$element,Ub);this.$$animate.addClass(this.$$element,Za)},$setDirty:function(){this.$dirty=!0;this.$pristine=!1;this.$$animate.removeClass(this.$$element,Za);this.$$animate.addClass(this.$$element,Ub);this.$$parentForm.$setDirty()},$setUntouched:function(){this.$touched=!1;this.$untouched=!0;this.$$animate.setClass(this.$$element,\"ng-untouched\",\"ng-touched\")},$setTouched:function(){this.$touched=\n!0;this.$untouched=!1;this.$$animate.setClass(this.$$element,\"ng-touched\",\"ng-untouched\")},$rollbackViewValue:function(){this.$$timeout.cancel(this.$$pendingDebounce);this.$viewValue=this.$$lastCommittedViewValue;this.$render()},$validate:function(){if(!V(this.$modelValue)){var a=this.$$lastCommittedViewValue,b=this.$$rawModelValue,d=this.$valid,c=this.$modelValue,e=this.$options.getOption(\"allowInvalid\"),f=this;this.$$runValidators(b,a,function(a){e||d===a||(f.$modelValue=a?b:void 0,f.$modelValue!==\nc&&f.$$writeModelToScope())})}},$$runValidators:function(a,b,d){function c(){var c=!0;r(h.$validators,function(d,e){var g=Boolean(d(a,b));c=c&&g;f(e,g)});return c?!0:(r(h.$asyncValidators,function(a,b){f(b,null)}),!1)}function e(){var c=[],d=!0;r(h.$asyncValidators,function(e,g){var h=e(a,b);if(!h||!z(h.then))throw ob(\"nopromise\",h);f(g,void 0);c.push(h.then(function(){f(g,!0)},function(){d=!1;f(g,!1)}))});c.length?h.$$q.all(c).then(function(){g(d)},A):g(!0)}function f(a,b){k===h.$$currentValidationRunId&&\nh.$setValidity(a,b)}function g(a){k===h.$$currentValidationRunId&&d(a)}this.$$currentValidationRunId++;var k=this.$$currentValidationRunId,h=this;(function(){var a=h.$$parserName;if(x(h.$$parserValid))f(a,null);else return h.$$parserValid||(r(h.$validators,function(a,b){f(b,null)}),r(h.$asyncValidators,function(a,b){f(b,null)})),f(a,h.$$parserValid),h.$$parserValid;return!0})()?c()?e():g(!1):g(!1)},$commitViewValue:function(){var a=this.$viewValue;this.$$timeout.cancel(this.$$pendingDebounce);if(this.$$lastCommittedViewValue!==\na||\"\"===a&&this.$$hasNativeValidators)this.$$updateEmptyClasses(a),this.$$lastCommittedViewValue=a,this.$pristine&&this.$setDirty(),this.$$parseAndValidate()},$$parseAndValidate:function(){var a=this.$$lastCommittedViewValue,b=this;this.$$parserValid=x(a)?void 0:!0;this.$setValidity(this.$$parserName,null);this.$$parserName=\"parse\";if(this.$$parserValid)for(var d=0;d<this.$parsers.length;d++)if(a=this.$parsers[d](a),x(a)){this.$$parserValid=!1;break}V(this.$modelValue)&&(this.$modelValue=this.$$ngModelGet(this.$$scope));\nvar c=this.$modelValue,e=this.$options.getOption(\"allowInvalid\");this.$$rawModelValue=a;e&&(this.$modelValue=a,b.$modelValue!==c&&b.$$writeModelToScope());this.$$runValidators(a,this.$$lastCommittedViewValue,function(d){e||(b.$modelValue=d?a:void 0,b.$modelValue!==c&&b.$$writeModelToScope())})},$$writeModelToScope:function(){this.$$ngModelSet(this.$$scope,this.$modelValue);r(this.$viewChangeListeners,function(a){try{a()}catch(b){this.$$exceptionHandler(b)}},this)},$setViewValue:function(a,b){this.$viewValue=\na;this.$options.getOption(\"updateOnDefault\")&&this.$$debounceViewValueCommit(b)},$$debounceViewValueCommit:function(a){var b=this.$options.getOption(\"debounce\");ba(b[a])?b=b[a]:ba(b[\"default\"])&&-1===this.$options.getOption(\"updateOn\").indexOf(a)?b=b[\"default\"]:ba(b[\"*\"])&&(b=b[\"*\"]);this.$$timeout.cancel(this.$$pendingDebounce);var d=this;0<b?this.$$pendingDebounce=this.$$timeout(function(){d.$commitViewValue()},b):this.$$rootScope.$$phase?this.$commitViewValue():this.$$scope.$apply(function(){d.$commitViewValue()})},\n$overrideModelOptions:function(a){this.$options=this.$options.createChild(a);this.$$setUpdateOnEvents()},$processModelValue:function(){var a=this.$$format();this.$viewValue!==a&&(this.$$updateEmptyClasses(a),this.$viewValue=this.$$lastCommittedViewValue=a,this.$render(),this.$$runValidators(this.$modelValue,this.$viewValue,A))},$$format:function(){for(var a=this.$formatters,b=a.length,d=this.$modelValue;b--;)d=a[b](d);return d},$$setModelValue:function(a){this.$modelValue=this.$$rawModelValue=a;this.$$parserValid=\nvoid 0;this.$processModelValue()},$$setUpdateOnEvents:function(){this.$$updateEvents&&this.$$element.off(this.$$updateEvents,this.$$updateEventHandler);if(this.$$updateEvents=this.$options.getOption(\"updateOn\"))this.$$element.on(this.$$updateEvents,this.$$updateEventHandler)},$$updateEventHandler:function(a){this.$$debounceViewValueCommit(a&&a.type)}};$d({clazz:Rb,set:function(a,b){a[b]=!0},unset:function(a,b){delete a[b]}});var mf=[\"$rootScope\",function(a){return{restrict:\"A\",require:[\"ngModel\",\n\"^?form\",\"^?ngModelOptions\"],controller:Rb,priority:1,compile:function(b){b.addClass(Za).addClass(\"ng-untouched\").addClass(mb);return{pre:function(a,b,e,f){var g=f[0];b=f[1]||g.$$parentForm;if(f=f[2])g.$options=f.$options;g.$$initGetterSetters();b.$addControl(g);e.$observe(\"name\",function(a){g.$name!==a&&g.$$parentForm.$$renameControl(g,a)});a.$on(\"$destroy\",function(){g.$$parentForm.$removeControl(g)})},post:function(b,c,e,f){function g(){k.$setTouched()}var k=f[0];k.$$setUpdateOnEvents();c.on(\"blur\",\nfunction(){k.$touched||(a.$$phase?b.$evalAsync(g):b.$apply(g))})}}}}}],Sb,sh=/(\\s+|^)default(\\s+|$)/;Kc.prototype={getOption:function(a){return this.$$options[a]},createChild:function(a){var b=!1;a=R({},a);r(a,function(d,c){\"$inherit\"===d?\"*\"===c?b=!0:(a[c]=this.$$options[c],\"updateOn\"===c&&(a.updateOnDefault=this.$$options.updateOnDefault)):\"updateOn\"===c&&(a.updateOnDefault=!1,a[c]=T(d.replace(sh,function(){a.updateOnDefault=!0;return\" \"})))},this);b&&(delete a[\"*\"],fe(a,this.$$options));fe(a,Sb.$$options);\nreturn new Kc(a)}};Sb=new Kc({updateOn:\"\",updateOnDefault:!0,debounce:0,getterSetter:!1,allowInvalid:!1,timezone:null});var qf=function(){function a(a,d){this.$$attrs=a;this.$$scope=d}a.$inject=[\"$attrs\",\"$scope\"];a.prototype={$onInit:function(){var a=this.parentCtrl?this.parentCtrl.$options:Sb,d=this.$$scope.$eval(this.$$attrs.ngModelOptions);this.$options=a.createChild(d)}};return{restrict:\"A\",priority:10,require:{parentCtrl:\"?^^ngModelOptions\"},bindToController:!0,controller:a}},af=Na({terminal:!0,\npriority:1E3}),th=M(\"ngOptions\"),uh=/^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+group\\s+by\\s+([\\s\\S]+?))?(?:\\s+disable\\s+when\\s+([\\s\\S]+?))?\\s+for\\s+(?:([$\\w][$\\w]*)|(?:\\(\\s*([$\\w][$\\w]*)\\s*,\\s*([$\\w][$\\w]*)\\s*\\)))\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?$/,kf=[\"$compile\",\"$document\",\"$parse\",function(a,b,d){function c(a,b,c){function e(a,b,c,d,f){this.selectValue=a;this.viewValue=b;this.label=c;this.group=d;this.disabled=f}function f(a){var b;if(!p&&xa(a))b=a;else{b=[];for(var c in a)a.hasOwnProperty(c)&&\n\"$\"!==c.charAt(0)&&b.push(c)}return b}var q=a.match(uh);if(!q)throw th(\"iexp\",a,ya(b));var n=q[5]||q[7],p=q[6];a=/ as /.test(q[0])&&q[1];var r=q[9];b=d(q[2]?q[1]:n);var u=a&&d(a)||b,v=r&&d(r),w=r?function(a,b){return v(c,b)}:function(a){return Ka(a)},y=function(a,b){return w(a,C(a,b))},x=d(q[2]||q[1]),E=d(q[3]||\"\"),G=d(q[4]||\"\"),J=d(q[8]),z={},C=p?function(a,b){z[p]=b;z[n]=a;return z}:function(a){z[n]=a;return z};return{trackBy:r,getTrackByValue:y,getWatchables:d(J,function(a){var b=[];a=a||[];for(var d=\nf(a),e=d.length,g=0;g<e;g++){var k=a===d?g:d[g],l=a[k],k=C(l,k),l=w(l,k);b.push(l);if(q[2]||q[1])l=x(c,k),b.push(l);q[4]&&(k=G(c,k),b.push(k))}return b}),getOptions:function(){for(var a=[],b={},d=J(c)||[],g=f(d),k=g.length,n=0;n<k;n++){var q=d===g?n:g[n],p=C(d[q],q),s=u(c,p),q=w(s,p),v=x(c,p),D=E(c,p),p=G(c,p),s=new e(q,s,v,D,p);a.push(s);b[q]=s}return{items:a,selectValueMap:b,getOptionFromViewValue:function(a){return b[y(a)]},getViewValueFromOption:function(a){return r?Ha(a.viewValue):a.viewValue}}}}}\nvar e=B.document.createElement(\"option\"),f=B.document.createElement(\"optgroup\");return{restrict:\"A\",terminal:!0,require:[\"select\",\"ngModel\"],link:{pre:function(a,b,c,d){d[0].registerOption=A},post:function(d,k,h,l){function m(a){var b=(a=w.getOptionFromViewValue(a))&&a.element;b&&!b.selected&&(b.selected=!0);return a}function q(a,b){a.element=b;b.disabled=a.disabled;a.label!==b.label&&(b.label=a.label,b.textContent=a.label);b.value=a.selectValue}var n=l[0],p=l[1],t=h.multiple;l=0;for(var u=k.children(),\nD=u.length;l<D;l++)if(\"\"===u[l].value){n.hasEmptyOption=!0;n.emptyOption=u.eq(l);break}k.empty();l=!!n.emptyOption;y(e.cloneNode(!1)).val(\"?\");var w,x=c(h.ngOptions,k,d),z=b[0].createDocumentFragment();n.generateUnknownOptionValue=function(a){return\"?\"};t?(n.writeValue=function(a){if(w){var b=a&&a.map(m)||[];w.items.forEach(function(a){a.element.selected&&-1===Array.prototype.indexOf.call(b,a)&&(a.element.selected=!1)})}},n.readValue=function(){var a=k.val()||[],b=[];r(a,function(a){(a=w.selectValueMap[a])&&\n!a.disabled&&b.push(w.getViewValueFromOption(a))});return b},x.trackBy&&d.$watchCollection(function(){if(I(p.$viewValue))return p.$viewValue.map(function(a){return x.getTrackByValue(a)})},function(){p.$render()})):(n.writeValue=function(a){if(w){var b=k[0].options[k[0].selectedIndex],c=w.getOptionFromViewValue(a);b&&b.removeAttribute(\"selected\");c?(k[0].value!==c.selectValue&&(n.removeUnknownOption(),k[0].value=c.selectValue,c.element.selected=!0),c.element.setAttribute(\"selected\",\"selected\")):n.selectUnknownOrEmptyOption(a)}},\nn.readValue=function(){var a=w.selectValueMap[k.val()];return a&&!a.disabled?(n.unselectEmptyOption(),n.removeUnknownOption(),w.getViewValueFromOption(a)):null},x.trackBy&&d.$watch(function(){return x.getTrackByValue(p.$viewValue)},function(){p.$render()}));l&&(a(n.emptyOption)(d),k.prepend(n.emptyOption),8===n.emptyOption[0].nodeType?(n.hasEmptyOption=!1,n.registerOption=function(a,b){\"\"===b.val()&&(n.hasEmptyOption=!0,n.emptyOption=b,n.emptyOption.removeClass(\"ng-scope\"),p.$render(),b.on(\"$destroy\",\nfunction(){var a=n.$isEmptyOptionSelected();n.hasEmptyOption=!1;n.emptyOption=void 0;a&&p.$render()}))}):n.emptyOption.removeClass(\"ng-scope\"));d.$watchCollection(x.getWatchables,function(){var a=w&&n.readValue();if(w)for(var b=w.items.length-1;0<=b;b--){var c=w.items[b];v(c.group)?Fb(c.element.parentNode):Fb(c.element)}w=x.getOptions();var d={};w.items.forEach(function(a){var b;if(v(a.group)){b=d[a.group];b||(b=f.cloneNode(!1),z.appendChild(b),b.label=null===a.group?\"null\":a.group,d[a.group]=b);\nvar c=e.cloneNode(!1);b.appendChild(c);q(a,c)}else b=e.cloneNode(!1),z.appendChild(b),q(a,b)});k[0].appendChild(z);p.$render();p.$isEmpty(a)||(b=n.readValue(),(x.trackBy||t?ua(a,b):a===b)||(p.$setViewValue(b),p.$render()))})}}}}],bf=[\"$locale\",\"$interpolate\",\"$log\",function(a,b,d){var c=/{}/g,e=/^when(Minus)?(.+)$/;return{link:function(f,g,k){function h(a){g.text(a||\"\")}var l=k.count,m=k.$attr.when&&g.attr(k.$attr.when),q=k.offset||0,n=f.$eval(m)||{},p={},t=b.startSymbol(),u=b.endSymbol(),v=t+l+\"-\"+\nq+u,w=ea.noop,y;r(k,function(a,b){var c=e.exec(b);c&&(c=(c[1]?\"-\":\"\")+O(c[2]),n[c]=g.attr(k.$attr[b]))});r(n,function(a,d){p[d]=b(a.replace(c,v))});f.$watch(l,function(b){var c=parseFloat(b),e=V(c);e||c in n||(c=a.pluralCat(c-q));c===y||e&&V(y)||(w(),e=p[c],x(e)?(null!=b&&d.debug(\"ngPluralize: no rule defined for '\"+c+\"' in \"+m),w=A,h()):w=f.$watch(e,h),y=c)})}}}],ne=M(\"ngRef\"),cf=[\"$parse\",function(a){return{priority:-1,restrict:\"A\",compile:function(b,d){var c=va(ta(b)),e=a(d.ngRef),f=e.assign||\nfunction(){throw ne(\"nonassign\",d.ngRef);};return function(a,b,h){var l;if(h.hasOwnProperty(\"ngRefRead\"))if(\"$element\"===h.ngRefRead)l=b;else{if(l=b.data(\"$\"+h.ngRefRead+\"Controller\"),!l)throw ne(\"noctrl\",h.ngRefRead,d.ngRef);}else l=b.data(\"$\"+c+\"Controller\");l=l||b;f(a,l);b.on(\"$destroy\",function(){e(a)===l&&f(a,null)})}}}}],df=[\"$parse\",\"$animate\",\"$compile\",function(a,b,d){var c=M(\"ngRepeat\"),e=function(a,b,c,d,e,m,q){a[c]=d;e&&(a[e]=m);a.$index=b;a.$first=0===b;a.$last=b===q-1;a.$middle=!(a.$first||\na.$last);a.$odd=!(a.$even=0===(b&1))};return{restrict:\"A\",multiElement:!0,transclude:\"element\",priority:1E3,terminal:!0,$$tlb:!0,compile:function(f,g){var k=g.ngRepeat,h=d.$$createComment(\"end ngRepeat\",k),l=k.match(/^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/);if(!l)throw c(\"iexp\",k);var m=l[1],q=l[2],n=l[3],p=l[4],l=m.match(/^(?:(\\s*[$\\w]+)|\\(\\s*([$\\w]+)\\s*,\\s*([$\\w]+)\\s*\\))$/);if(!l)throw c(\"iidexp\",m);var t=l[3]||l[1],u=l[2];if(n&&(!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(n)||\n/^(null|undefined|this|\\$index|\\$first|\\$middle|\\$last|\\$even|\\$odd|\\$parent|\\$root|\\$id)$/.test(n)))throw c(\"badident\",n);var v,w,x,y,z={$id:Ka};p?v=a(p):(x=function(a,b){return Ka(b)},y=function(a){return a});return function(a,d,f,g,l){v&&(w=function(b,c,d){u&&(z[u]=b);z[t]=c;z.$index=d;return v(a,z)});var m=S();a.$watchCollection(q,function(f){var g,q,p=d[0],s,v=S(),D,z,C,B,E,A,F;n&&(a[n]=f);if(xa(f))E=f,q=w||x;else for(F in q=w||y,E=[],f)sa.call(f,F)&&\"$\"!==F.charAt(0)&&E.push(F);D=E.length;F=\nArray(D);for(g=0;g<D;g++)if(z=f===E?g:E[g],C=f[z],B=q(z,C,g),m[B])A=m[B],delete m[B],v[B]=A,F[g]=A;else{if(v[B])throw r(F,function(a){a&&a.scope&&(m[a.id]=a)}),c(\"dupes\",k,B,C);F[g]={id:B,scope:void 0,clone:void 0};v[B]=!0}for(s in m){A=m[s];B=tb(A.clone);b.leave(B);if(B[0].parentNode)for(g=0,q=B.length;g<q;g++)B[g].$$NG_REMOVED=!0;A.scope.$destroy()}for(g=0;g<D;g++)if(z=f===E?g:E[g],C=f[z],A=F[g],A.scope){s=p;do s=s.nextSibling;while(s&&s.$$NG_REMOVED);A.clone[0]!==s&&b.move(tb(A.clone),null,p);\np=A.clone[A.clone.length-1];e(A.scope,g,t,C,u,z,D)}else l(function(a,c){A.scope=c;var d=h.cloneNode(!1);a[a.length++]=d;b.enter(a,null,p);p=d;A.clone=a;v[A.id]=A;e(A.scope,g,t,C,u,z,D)});m=v})}}}}],ef=[\"$animate\",function(a){return{restrict:\"A\",multiElement:!0,link:function(b,d,c){b.$watch(c.ngShow,function(b){a[b?\"removeClass\":\"addClass\"](d,\"ng-hide\",{tempClasses:\"ng-hide-animate\"})})}}}],Xe=[\"$animate\",function(a){return{restrict:\"A\",multiElement:!0,link:function(b,d,c){b.$watch(c.ngHide,function(b){a[b?\n\"addClass\":\"removeClass\"](d,\"ng-hide\",{tempClasses:\"ng-hide-animate\"})})}}}],ff=Na(function(a,b,d){a.$watchCollection(d.ngStyle,function(a,d){d&&a!==d&&r(d,function(a,c){b.css(c,\"\")});a&&b.css(a)})}),gf=[\"$animate\",\"$compile\",function(a,b){return{require:\"ngSwitch\",controller:[\"$scope\",function(){this.cases={}}],link:function(d,c,e,f){var g=[],k=[],h=[],l=[],m=function(a,b){return function(c){!1!==c&&a.splice(b,1)}};d.$watch(e.ngSwitch||e.on,function(c){for(var d,e;h.length;)a.cancel(h.pop());d=0;\nfor(e=l.length;d<e;++d){var p=tb(k[d].clone);l[d].$destroy();(h[d]=a.leave(p)).done(m(h,d))}k.length=0;l.length=0;(g=f.cases[\"!\"+c]||f.cases[\"?\"])&&r(g,function(c){c.transclude(function(d,e){l.push(e);var f=c.element;d[d.length++]=b.$$createComment(\"end ngSwitchWhen\");k.push({clone:d});a.enter(d,f.parent(),f)})})})}}}],hf=Na({transclude:\"element\",priority:1200,require:\"^ngSwitch\",multiElement:!0,link:function(a,b,d,c,e){a=d.ngSwitchWhen.split(d.ngSwitchWhenSeparator).sort().filter(function(a,b,c){return c[b-\n1]!==a});r(a,function(a){c.cases[\"!\"+a]=c.cases[\"!\"+a]||[];c.cases[\"!\"+a].push({transclude:e,element:b})})}}),jf=Na({transclude:\"element\",priority:1200,require:\"^ngSwitch\",multiElement:!0,link:function(a,b,d,c,e){c.cases[\"?\"]=c.cases[\"?\"]||[];c.cases[\"?\"].push({transclude:e,element:b})}}),vh=M(\"ngTransclude\"),lf=[\"$compile\",function(a){return{restrict:\"EAC\",compile:function(b){var d=a(b.contents());b.empty();return function(a,b,f,g,k){function h(){d(a,function(a){b.append(a)})}if(!k)throw vh(\"orphan\",\nya(b));f.ngTransclude===f.$attr.ngTransclude&&(f.ngTransclude=\"\");f=f.ngTransclude||f.ngTranscludeSlot;k(function(a,c){var d;if(d=a.length)a:{d=0;for(var f=a.length;d<f;d++){var g=a[d];if(g.nodeType!==Oa||g.nodeValue.trim()){d=!0;break a}}d=void 0}d?b.append(a):(h(),c.$destroy())},null,f);f&&!k.isSlotFilled(f)&&h()}}}}],Le=[\"$templateCache\",function(a){return{restrict:\"E\",terminal:!0,compile:function(b,d){\"text/ng-template\"===d.type&&a.put(d.id,b[0].text)}}}],wh={$setViewValue:A,$render:A},xh=[\"$element\",\n\"$scope\",function(a,b){function d(){g||(g=!0,b.$$postDigest(function(){g=!1;e.ngModelCtrl.$render()}))}function c(a){k||(k=!0,b.$$postDigest(function(){b.$$destroyed||(k=!1,e.ngModelCtrl.$setViewValue(e.readValue()),a&&e.ngModelCtrl.$render())}))}var e=this,f=new Hb;e.selectValueMap={};e.ngModelCtrl=wh;e.multiple=!1;e.unknownOption=y(B.document.createElement(\"option\"));e.hasEmptyOption=!1;e.emptyOption=void 0;e.renderUnknownOption=function(b){b=e.generateUnknownOptionValue(b);e.unknownOption.val(b);\na.prepend(e.unknownOption);Ea(e.unknownOption,!0);a.val(b)};e.updateUnknownOption=function(b){b=e.generateUnknownOptionValue(b);e.unknownOption.val(b);Ea(e.unknownOption,!0);a.val(b)};e.generateUnknownOptionValue=function(a){return\"? \"+Ka(a)+\" ?\"};e.removeUnknownOption=function(){e.unknownOption.parent()&&e.unknownOption.remove()};e.selectEmptyOption=function(){e.emptyOption&&(a.val(\"\"),Ea(e.emptyOption,!0))};e.unselectEmptyOption=function(){e.hasEmptyOption&&Ea(e.emptyOption,!1)};b.$on(\"$destroy\",\nfunction(){e.renderUnknownOption=A});e.readValue=function(){var b=a.val(),b=b in e.selectValueMap?e.selectValueMap[b]:b;return e.hasOption(b)?b:null};e.writeValue=function(b){var c=a[0].options[a[0].selectedIndex];c&&Ea(y(c),!1);e.hasOption(b)?(e.removeUnknownOption(),c=Ka(b),a.val(c in e.selectValueMap?c:b),Ea(y(a[0].options[a[0].selectedIndex]),!0)):e.selectUnknownOrEmptyOption(b)};e.addOption=function(a,b){if(8!==b[0].nodeType){Qa(a,'\"option value\"');\"\"===a&&(e.hasEmptyOption=!0,e.emptyOption=\nb);var c=f.get(a)||0;f.set(a,c+1);d()}};e.removeOption=function(a){var b=f.get(a);b&&(1===b?(f.delete(a),\"\"===a&&(e.hasEmptyOption=!1,e.emptyOption=void 0)):f.set(a,b-1))};e.hasOption=function(a){return!!f.get(a)};e.$hasEmptyOption=function(){return e.hasEmptyOption};e.$isUnknownOptionSelected=function(){return a[0].options[0]===e.unknownOption[0]};e.$isEmptyOptionSelected=function(){return e.hasEmptyOption&&a[0].options[a[0].selectedIndex]===e.emptyOption[0]};e.selectUnknownOrEmptyOption=function(a){null==\na&&e.emptyOption?(e.removeUnknownOption(),e.selectEmptyOption()):e.unknownOption.parent().length?e.updateUnknownOption(a):e.renderUnknownOption(a)};var g=!1,k=!1;e.registerOption=function(a,b,f,g,k){if(f.$attr.ngValue){var p,r;f.$observe(\"value\",function(a){var d,f=b.prop(\"selected\");v(r)&&(e.removeOption(p),delete e.selectValueMap[r],d=!0);r=Ka(a);p=a;e.selectValueMap[r]=a;e.addOption(a,b);b.attr(\"value\",r);d&&f&&c()})}else g?f.$observe(\"value\",function(a){e.readValue();var d,f=b.prop(\"selected\");\nv(p)&&(e.removeOption(p),d=!0);p=a;e.addOption(a,b);d&&f&&c()}):k?a.$watch(k,function(a,d){f.$set(\"value\",a);var g=b.prop(\"selected\");d!==a&&e.removeOption(d);e.addOption(a,b);d&&g&&c()}):e.addOption(f.value,b);f.$observe(\"disabled\",function(a){if(\"true\"===a||a&&b.prop(\"selected\"))e.multiple?c(!0):(e.ngModelCtrl.$setViewValue(null),e.ngModelCtrl.$render())});b.on(\"$destroy\",function(){var a=e.readValue(),b=f.value;e.removeOption(b);d();(e.multiple&&a&&-1!==a.indexOf(b)||a===b)&&c(!0)})}}],Me=function(){return{restrict:\"E\",\nrequire:[\"select\",\"?ngModel\"],controller:xh,priority:1,link:{pre:function(a,b,d,c){var e=c[0],f=c[1];if(f){if(e.ngModelCtrl=f,b.on(\"change\",function(){e.removeUnknownOption();a.$apply(function(){f.$setViewValue(e.readValue())})}),d.multiple){e.multiple=!0;e.readValue=function(){var a=[];r(b.find(\"option\"),function(b){b.selected&&!b.disabled&&(b=b.value,a.push(b in e.selectValueMap?e.selectValueMap[b]:b))});return a};e.writeValue=function(a){r(b.find(\"option\"),function(b){var c=!!a&&(-1!==Array.prototype.indexOf.call(a,\nb.value)||-1!==Array.prototype.indexOf.call(a,e.selectValueMap[b.value]));c!==b.selected&&Ea(y(b),c)})};var g,k=NaN;a.$watch(function(){k!==f.$viewValue||ua(g,f.$viewValue)||(g=oa(f.$viewValue),f.$render());k=f.$viewValue});f.$isEmpty=function(a){return!a||0===a.length}}}else e.registerOption=A},post:function(a,b,d,c){var e=c[1];if(e){var f=c[0];e.$render=function(){f.writeValue(e.$viewValue)}}}}}},Ne=[\"$interpolate\",function(a){return{restrict:\"E\",priority:100,compile:function(b,d){var c,e;v(d.ngValue)||\n(v(d.value)?c=a(d.value,!0):(e=a(b.text(),!0))||d.$set(\"value\",b.text()));return function(a,b,d){var h=b.parent();(h=h.data(\"$selectController\")||h.parent().data(\"$selectController\"))&&h.registerOption(a,b,d,c,e)}}}}],Zc=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,b,d,c){c&&(d.required=!0,c.$validators.required=function(a,b){return!d.required||!c.$isEmpty(b)},d.$observe(\"required\",function(){c.$validate()}))}}},Yc=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,\nb,d,c){if(c){var e,f=d.ngPattern||d.pattern;d.$observe(\"pattern\",function(a){C(a)&&0<a.length&&(a=new RegExp(\"^\"+a+\"$\"));if(a&&!a.test)throw M(\"ngPattern\")(\"noregexp\",f,a,ya(b));e=a||void 0;c.$validate()});c.$validators.pattern=function(a,b){return c.$isEmpty(b)||x(e)||e.test(b)}}}}},ad=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,b,d,c){if(c){var e=-1;d.$observe(\"maxlength\",function(a){a=da(a);e=V(a)?-1:a;c.$validate()});c.$validators.maxlength=function(a,b){return 0>e||c.$isEmpty(b)||\nb.length<=e}}}}},$c=function(){return{restrict:\"A\",require:\"?ngModel\",link:function(a,b,d,c){if(c){var e=0;d.$observe(\"minlength\",function(a){e=da(a)||0;c.$validate()});c.$validators.minlength=function(a,b){return c.$isEmpty(b)||b.length>=e}}}}};B.angular.bootstrap?B.console&&console.log(\"WARNING: Tried to load AngularJS more than once.\"):(Ce(),Ge(ea),ea.module(\"ngLocale\",[],[\"$provide\",function(a){function b(a){a+=\"\";var b=a.indexOf(\".\");return-1==b?0:a.length-b-1}a.value(\"$locale\",{DATETIME_FORMATS:{AMPMS:[\"AM\",\n\"PM\"],DAY:\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),ERANAMES:[\"Before Christ\",\"Anno Domini\"],ERAS:[\"BC\",\"AD\"],FIRSTDAYOFWEEK:6,MONTH:\"January February March April May June July August September October November December\".split(\" \"),SHORTDAY:\"Sun Mon Tue Wed Thu Fri Sat\".split(\" \"),SHORTMONTH:\"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),STANDALONEMONTH:\"January February March April May June July August September October November December\".split(\" \"),WEEKENDRANGE:[5,\n6],fullDate:\"EEEE, MMMM d, y\",longDate:\"MMMM d, y\",medium:\"MMM d, y h:mm:ss a\",mediumDate:\"MMM d, y\",mediumTime:\"h:mm:ss a\",\"short\":\"M/d/yy h:mm a\",shortDate:\"M/d/yy\",shortTime:\"h:mm a\"},NUMBER_FORMATS:{CURRENCY_SYM:\"$\",DECIMAL_SEP:\".\",GROUP_SEP:\",\",PATTERNS:[{gSize:3,lgSize:3,maxFrac:3,minFrac:0,minInt:1,negPre:\"-\",negSuf:\"\",posPre:\"\",posSuf:\"\"},{gSize:3,lgSize:3,maxFrac:2,minFrac:2,minInt:1,negPre:\"-\\u00a4\",negSuf:\"\",posPre:\"\\u00a4\",posSuf:\"\"}]},id:\"en-us\",localeID:\"en_US\",pluralCat:function(a,\nc){var e=a|0,f=c;void 0===f&&(f=Math.min(b(a),3));Math.pow(10,f);return 1==e&&0==f?\"one\":\"other\"}})}]),y(function(){xe(B.document,Tc)}))})(window);!window.angular.$$csp().noInlineStyle&&window.angular.element(document.head).prepend('<style type=\"text/css\">@charset \"UTF-8\";[ng\\\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');","Magezon_Builder/vendor/codemirror/lib/codemirror.js":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n  var android = /Android/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) { presto_version = Number(presto_version[1]); }\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  var rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      { e.removeChild(e.firstChild); }\n    return e\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e)\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) { e.className = className; }\n    if (style) { e.style.cssText = style; }\n    if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n    return e\n  }\n  // wrapper for elt, which removes the elt from the accessibility tree\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e\n  }\n\n  var range;\n  if (document.createRange) { range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r\n  }; }\n  else { range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r\n  }; }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      { child = child.parentNode; }\n    if (parent.contains)\n      { return parent.contains(child) }\n    do {\n      if (child.nodeType == 11) { child = child.host; }\n      if (child == parent) { return true }\n    } while (child = child.parentNode)\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n    try {\n      activeElement = document.activeElement;\n    } catch(e) {\n      activeElement = document.body || null;\n    }\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      { activeElement = activeElement.shadowRoot.activeElement; }\n    return activeElement\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n    return b\n  }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\n  else if (ie) // Suppress mysterious IE10 errors\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args)}\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) { target = {}; }\n    for (var prop in obj)\n      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        { target[prop] = obj[prop]; } }\n    return target\n  }\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) { end = string.length; }\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        { return n + (end - i) }\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function() {this.id = null;};\n  Delayed.prototype.set = function (ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      { if (array[i] == elt) { return i } }\n    return -1\n  }\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) { nextTab = string.length; }\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        { return pos + Math.min(skipped, goal - col) }\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) { return pos }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      { spaceStrs.push(lst(spaceStrs) + \" \"); }\n    return spaceStrs[n]\n  }\n\n  function lst(arr) { return arr[arr.length-1] }\n\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n    return out\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value);\n    while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) { copyObj(props, inst); }\n    return inst\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  }\n  function isWordChar(ch, helper) {\n    if (!helper) { return isWordCharBasic(ch) }\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n    return helper.test(ch)\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n    return true\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n    return pos\n  }\n\n  // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n    for (;;) {\n      if (from == to) { return from }\n      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n      if (mid == from) { return pred(mid) ? from : to }\n      if (pred(mid)) { to = mid; }\n      else { from = mid + dir; }\n    }\n  }\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [lines], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n    if (place) {\n      if (place.appendChild) { place.appendChild(d.wrapper); }\n      else { place(d.wrapper); }\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    input.init(d);\n  }\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n    var chunk = doc;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n]\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) { text = text.slice(0, end.ch); }\n      if (n == start.line) { text = text.slice(start.ch); }\n      out.push(text);\n      ++n;\n    });\n    return out\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n    return out\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) { return null }\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) { break }\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1], ch = child.height;\n        if (h < ch) { chunk = child; continue outer }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n\n    } while (!chunk.lines)\n    var i = 0;\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) { break }\n      h -= lh;\n    }\n    return n + i\n  }\n\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber))\n  }\n\n  // A Pos instance represents a position within the text.\n  function Pos(line, ch, sticky) {\n    if ( sticky === void 0 ) sticky = null;\n\n    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  }\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\n  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\n  function copyPos(x) {return Pos(x.line, x.ch)}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) { return Pos(doc.first, 0) }\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n    return clipToLen(pos, getLine(doc, pos.line).text.length)\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n    else if (ch < 0) { return Pos(pos.line, 0) }\n    else { return pos }\n  }\n  function clipPosArray(doc, array) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n    return out\n  }\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) { return span }\n    } }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    var r;\n    for (var i = 0; i < spans.length; ++i)\n      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n    return r\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    } }\n    return nw\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    } }\n    return nw\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) { return null }\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) { return null }\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) { span.to = startCh; }\n          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n        if (span$1.to != null) { span$1.to += offset; }\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n          if (!found$1) {\n            span$1.from = offset;\n            if (sameLine) { (first || (first = [])).push(span$1); }\n          }\n        } else {\n          span$1.from += offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) { first = clearEmptySpans(first); }\n    if (last && last != first) { last = clearEmptySpans(last); }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        { for (var i$2 = 0; i$2 < first.length; ++i$2)\n          { if (first[i$2].to == null)\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n      for (var i$3 = 0; i$3 < gap; ++i$3)\n        { newMarkers.push(gapMarkers); }\n      newMarkers.push(last);\n    }\n    return newMarkers\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        { spans.splice(i--, 1); }\n    }\n    if (!spans.length) { return null }\n    return spans\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          { (markers || (markers = [])).push(mark); }\n      } }\n    });\n    if (!markers) { return null }\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          { newParts.push({from: p.from, to: m.from}); }\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          { newParts.push({from: m.to, to: p.to}); }\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n    return parts\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.detachLine(line); }\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.attachLine(line); }\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) { return lenDiff }\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) { return -fromCmp }\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) { return toCmp }\n    return b.id - a.id\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        { found = sp.marker; }\n    } }\n    return found\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }\n    } }\n    return found\n  }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n    var line = getLine(doc, lineNo$$1);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        { return true }\n    } }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      { line = merged.find(-1, true).line; }\n    return line\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return line\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line\n      ;(lines || (lines = [])).push(line);\n    }\n    return lines\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) { return lineN }\n    return lineNo(vis)\n  }\n\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) { return lineN }\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) { return lineN }\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return lineNo(line) + 1\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      if (sp.from == null) { return true }\n      if (sp.marker.widgetNode) { continue }\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        { return true }\n    } }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      { return true }\n    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) { return true }\n    }\n  }\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) { break }\n      else { h += line.height; }\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n        if (cur == chunk) { break }\n        else { h += cur.height; }\n      }\n    }\n    return h\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) { return 0 }\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n    return len\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) { return f(from, to, \"ltr\", 0) }\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n    if (!found) { f(from, to, \"ltr\"); }\n  }\n\n  var bidiOther = null;\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < ch && cur.to > ch) { return i }\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n    }\n    return found != null ? found : bidiOther\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6f9\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n    function charType(code) {\n      if (code <= 0xf7) { return lowTypes.charAt(code) }\n      else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n      else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n      else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n      else if (code == 0x200c) { return \"b\" }\n      else { return \"L\" }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n      var len = str.length, types = [];\n      for (var i = 0; i < len; ++i)\n        { types.push(charType(str.charCodeAt(i))); }\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n        if (type == \"m\") { types[i$1] = prev; }\n        else { prev = type; }\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n        if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n        else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n                 (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n        prev$1 = type$2;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n        if (type$3 == \",\") { types[i$4] = \"N\"; }\n        else if (type$3 == \"%\") {\n          var end = (void 0);\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i$4; j < end; ++j) { types[j] = replace; }\n          i$4 = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n        if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n        else if (isStrong.test(type$4)) { cur$1 = type$4; }\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = (void 0);\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n          var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n          i$6 = end$1 - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7, at = order.length;\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n              var nstart = j$2;\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              pos = j$2;\n            } else { ++j$2; }\n          }\n          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n        }\n      }\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order\n    }\n  })();\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line, direction) {\n    var order = line.order;\n    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n    return order\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var noHandlers = [];\n\n  var on = function(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map$$1 = emitter._handlers || (emitter._handlers = {});\n      map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\n      if (arr) {\n        var index = indexOf(arr, f);\n        if (index > -1)\n          { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n      }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type);\n    if (!handlers.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) { return }\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n      { set.push(arr[i]); } }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) { e.stopPropagation(); }\n    else { e.cancelBubble = true; }\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\n  function e_target(e) {return e.target || e.srcElement}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) { b = 1; }\n      else if (e.button & 2) { b = 3; }\n      else if (e.button & 4) { b = 2; }\n    }\n    if (mac && e.ctrlKey && b == 1) { b = 3; }\n    return b\n  }\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) { return false }\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) { return badBidiRects }\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3)\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) { nl = string.length; }\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result\n  } : function (string) { return string.split(/\\r\\n?|\\n/); };\n\n  var hasSelection = window.getSelection ? function (te) {\n    try { return te.selectionStart != te.selectionEnd }\n    catch(e) { return false }\n  } : function (te) {\n    var range$$1;\n    try {range$$1 = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range$$1 || range$$1.parentElement() != te) { return false }\n    return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n  };\n\n  var hasCopyEvent = (function () {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) { return true }\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\"\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) { return badZoomedRects }\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n  }\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  function defineMode(name, mode) {\n    if (arguments.length > 2)\n      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  }\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") { found = {name: found}; }\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\")\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\")\n    }\n    if (typeof spec == \"string\") { return {name: spec} }\n    else { return spec || {name: \"null\"} }\n  }\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) { return getMode(options, \"text/plain\") }\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) { continue }\n        if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) { modeObj.helperType = spec.helperType; }\n    if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n      { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n    return modeObj\n  }\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = {};\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) { return state }\n    if (mode.copyState) { return mode.copyState(state) }\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) { val = val.concat([]); }\n      nstate[n] = val;\n    }\n    return nstate\n  }\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  function innerMode(mode, state) {\n    var info;\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n      if (!info || info.mode == mode) { break }\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state}\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true\n  }\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = function(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {return this.pos >= this.string.length};\n  StringStream.prototype.sol = function () {return this.pos == this.lineStart};\n  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length)\n      { return this.string.charAt(this.pos++) }\n  };\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n    if (typeof match == \"string\") { ok = ch == match; }\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n    if (ok) {++this.pos; return ch}\n  };\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start\n  };\n  StringStream.prototype.eatSpace = function () {\n      var this$1 = this;\n\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n    return this.pos > start\n  };\n  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true}\n  };\n  StringStream.prototype.backUp = function (n) {this.pos -= n;};\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) { this.pos += pattern.length; }\n        return true\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) { return null }\n      if (match && consume !== false) { this.pos += match[0].length; }\n      return match\n    }\n  };\n  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n    try { return inner() }\n    finally { this.lineStart -= n; }\n  };\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n)\n  };\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos)\n  };\n\n  var SavedContext = function(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n    return line\n  };\n\n  Context.prototype.baseToken = function (n) {\n      var this$1 = this;\n\n    if (!this.baseTokens) { return null }\n    while (this.baseTokens[this.baseTokenPos] <= n)\n      { this$1.baseTokenPos += 2; }\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n            size: this.baseTokens[this.baseTokenPos] - n}\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n    if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext)\n      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n    else\n      { return new Context(doc, copyState(doc.mode, saved), line) }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n  };\n\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n            lineClasses, forceToEnd);\n    var state = context.state;\n\n    // Run overlays, adjust style array.\n    var loop = function ( o ) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            { st.splice(i, 1, end, st[i+1], i_end); }\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) { return }\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n      if (resetState) { context.state = resetState; }\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n      if (result.classes) { line.styleClasses = result.classes; }\n      else if (line.styleClasses) { line.styleClasses = null; }\n      if (updateFrontier === cm.doc.highlightFrontier)\n        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n    }\n    return line.styles\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) { return new Context(doc, true, n) }\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n    if (precise) { doc.modeFrontier = context.line; }\n    return context\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") { callBlankLine(mode, context.state); }\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) { return mode.blankLine(state) }\n    if (!mode.innerMode) { return }\n    var inner = innerMode(mode, state);\n    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) { inner[0] = innerMode(mode, state).mode; }\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) { return style }\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n  }\n\n  var Token = function(stream, type, state) {\n    this.start = stream.start; this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  };\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n    if (asArray) { tokens = []; }\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n    }\n    return asArray ? tokens : new Token(stream, style, context.state)\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) { for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) { break }\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        { output[prop] = lineClass[2]; }\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        { output[prop] += \" \" + lineClass[2]; }\n    } }\n    return type\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) { return doc.first }\n      var line = getLine(doc, search - 1), after = line.stateAfter;\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n        { return search }\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n    if (doc.highlightFrontier < n - 10) { return }\n    var start = doc.first;\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter;\n      // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break\n      }\n    }\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () { return lineNo(this) };\n  eventMixin(Line);\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n    if (line.order != null) { line.order = null; }\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) { return null }\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n        if (line.styleClasses.textClass)\n          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild;\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n        { builder.content.className = \"cm-tab-wrap-hack\"; }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n    return builder\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) { return }\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    var content;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) { mustWrap = true; }\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n          else { content.appendChild(txt); }\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) { break }\n        pos += skipped + 1;\n        var txt$1 = (void 0);\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n          else { content.appendChild(txt$1); }\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n      if (startStyle) { fullStyle += startStyle; }\n      if (endStyle) { fullStyle += endStyle; }\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (attributes) {\n        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\")\n          { token.setAttribute(attr, attributes[attr]); } }\n      }\n      return builder.content.appendChild(token)\n    }\n    builder.content.appendChild(content);\n  }\n\n  // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) { return text }\n    var spaceBefore = trailingBefore, result = \"\";\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        { ch = \"\\u00a0\"; }\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = (void 0);\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n          if (part.to > start && part.from <= start) { break }\n        }\n        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    }\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        { widget = builder.content.appendChild(document.createElement(\"span\")); }\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n      return\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles = (void 0);\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) { spanStyle += \" \" + m.className; }\n            if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n            if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n            // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n            if (m.title) { (attributes || (attributes = {})).title = m.title; }\n            if (m.attributes) {\n              for (var attr in m.attributes)\n                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\n            }\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              { collapsed = sp; }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) { return }\n          if (collapsed.to == pos) { collapsed = false; }\n        }\n      }\n      if (pos >= len) { break }\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        { callbacks[i].call(null); }\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n      }\n    } while (i < callbacks.length)\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n    if (!group) { return }\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type);\n    if (!arr.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    var loop = function ( i ) {\n      list.push(function () { return arr[i].apply(null, args); });\n    };\n\n    for (var i = 0; i < arr.length; ++i)\n      loop( i );\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") { updateLineText(cm, lineView); }\n      else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n      else if (type == \"class\") { updateLineClasses(cm, lineView); }\n      else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n    }\n    return lineView.node\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) { cls += \" CodeMirror-linebackground\"; }\n    if (lineView.background) {\n      if (cls) { lineView.background.className = cls; }\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built\n    }\n    return buildLineContent(cm, lineView)\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) { lineView.node = built.pre; }\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n    if (lineView.line.wrapClass)\n      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n    else if (lineView.node != lineView.text)\n      { lineView.node.className = \"\"; }\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        { lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n      if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                     (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n      } }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) { lineView.alignable = null; }\n    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n      next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        { lineView.node.removeChild(node); }\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) { lineView.bgClass = built.bgClass; }\n    if (built.textClass) { lineView.textClass = built.textClass; }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) { return }\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n      else\n        { wrap.appendChild(node); }\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n  (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) { return widget.height }\n    var cm = widget.doc.cm;\n    if (!cm) { return 0 }\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n      if (widget.noHScroll)\n        { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight\n  }\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        { return true }\n    }\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\n  function paddingH(display) {\n    if (display.cachedPaddingH) { return display.cachedPaddingH }\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n    return data\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n    for (var i = 0; i < lineView.rest.length; i++)\n      { if (lineView.rest[i] == line)\n        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n      { if (lineNo(lineView.rest[i$1]) > lineN)\n        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      { return cm.display.view[findViewIndex(cm, lineN)] }\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      { return ext }\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      { view = updateExternalMeasurement(cm, line); }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    }\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) { ch = -1; }\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) { prepared.cache[key] = found; }\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom}\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map$$1, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map$$1.length; i += 3) {\n      mStart = map$$1[i];\n      mEnd = map$$1[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) { collapse = \"right\"; }\n      }\n      if (start != null) {\n        node = map$$1[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          { collapse = bias; }\n        if (bias == \"left\" && start == 0)\n          { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n            node = map$$1[(i -= 3) + 2];\n            collapse = \"left\";\n          } }\n        if (bias == \"right\" && start == mEnd - mStart)\n          { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n            node = map$$1[(i += 3) + 2];\n            collapse = \"right\";\n          } }\n        break\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n    if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) { break }\n    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n      if ((rect = rects[i$1]).left != rect.right) { break }\n    } }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          { rect = node.parentNode.getBoundingClientRect(); }\n        else\n          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n        if (rect.left || rect.right || start == 0) { break }\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) { collapse = bias = \"right\"; }\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n      else\n        { rect = node.getBoundingClientRect(); }\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n      else\n        { rect = nullRect; }\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n    for (; i < heights.length - 1; i++)\n      { if (mid < heights[i]) { break } }\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) { result.bogus = true; }\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      { return rect }\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n        { lineView.measure.caches[i] = {}; } }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      { clearLineMeasurementCacheFor(cm.display.view[i]); }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n  }\n  function pageScrollY() {\n    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop\n  }\n\n  function widgetTopHeight(lineObj) {\n    var height = 0;\n    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n      { height += widgetHeight(lineObj.widgets[i]); } } }\n    return height\n  }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height; rect.bottom += height;\n    }\n    if (context == \"line\") { return rect }\n    if (!context) { context = \"local\"; }\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") { yOff += paddingTop(cm.display); }\n    else { yOff -= cm.display.viewOffset; }\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") { return coords }\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) { m.left = m.right; } else { m.right = m.left; }\n      return intoCoordSystem(cm, lineObj, m, context)\n    }\n    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n    if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos], right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert)\n    }\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n    if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n    return val\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height}\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n    if (outside) { pos.outside = true; }\n    return pos\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\n    if (x < 0) { x = 0; }\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 ? 1 : 0));\n      if (!collapsed) { return found }\n      var rangeEnd = collapsed.find(1);\n      if (rangeEnd.line == lineN) { return rangeEnd }\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n    return {begin: begin, end: end}\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n  }\n\n  // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n    // Move y into line-local coordinate space\n    y -= heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n    var widgetHeight$$1 = widgetTopHeight(lineObj);\n    var begin = 0, end = lineObj.text.length, ltr = true;\n\n    var order = getOrder(lineObj, cm.doc.direction);\n    // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                   (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);\n      ltr = part.level != 1;\n      // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    }\n\n    // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n    var chAround = null, boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;\n      if (!boxIsAfter(box, x, y, false)) { return false }\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n      return true\n    }, begin, end);\n\n    var baseX, sticky, outside = false;\n    // If a box around the coordinates was found, use that\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) { ch++; }\n      // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?\n        \"after\" : \"before\";\n      // Now get accurate coordinates for this place, in order to get a\n      // base X position\n      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), \"line\", lineObj, preparedMeasure);\n      baseX = coords.left;\n      outside = y < coords.top || y >= coords.bottom;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i], ltr = part.level != 1;\n      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                     \"line\", lineObj, preparedMeasure), x, y, true)\n    }, 0, order.length - 1);\n    var part = order[index];\n    // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n    if (index > 0) {\n      var ltr = part.level != 1;\n      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                               \"line\", lineObj, preparedMeasure);\n      if (boxIsAfter(start, x, y, true) && start.top > y)\n        { part = order[index - 1]; }\n    }\n    return part\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n    var part = null, closestDist = null;\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n      if (p.from >= end || p.to <= begin) { continue }\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n      // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n    if (!part) { part = order[order.length - 1]; }\n    // Clip the part to the wrapped line.\n    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n    return part\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) { display.cachedTextHeight = height; }\n    removeChildren(display.measure);\n    return height || 1\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) { display.cachedCharWidth = width; }\n    return width || 10\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[cm.options.gutters[i]] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth}\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) { return 0 }\n\n      var widgetsHeight = 0;\n      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n      } }\n\n      if (wrapping)\n        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n      else\n        { return widgetsHeight + th }\n    }\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n    });\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) { return null }\n    n -= cm.display.viewFrom;\n    if (n < 0) { return null }\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) { return i }\n    }\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if ( primary === void 0 ) primary = true;\n\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) { continue }\n      var range$$1 = doc.sel.ranges[i];\n      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\n      var collapsed = range$$1.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        { drawSelectionCursor(cm, range$$1.head, curFragment); }\n      if (!collapsed)\n        { drawSelectionRange(cm, range$$1, selFragment); }\n    }\n    return result\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range$$1, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) { top = 0; }\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop]\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n        var first = i == 0, last = !order || i == order.length - 1;\n        if (toPos.top - fromPos.top <= 3) { // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else { // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n        if (cmpCoords(toPos, start) < 0) { start = toPos; }\n        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n        if (cmpCoords(toPos, end) < 0) { end = toPos; }\n      });\n      return {start: start, end: end}\n    }\n\n    var sFrom = range$$1.from(), sTo = range$$1.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) { return }\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n        cm.options.cursorBlinkRate); }\n    else if (cm.options.cursorBlinkRate < 0)\n      { display.cursorDiv.style.visibility = \"hidden\"; }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n      onBlur(cm);\n    } }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n    if (cm.options.readOnly == \"nocursor\") { return }\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) { return }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], wrapping = cm.options.lineWrapping;\n      var height = (void 0), width = 0;\n      if (cur.hidden) { continue }\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n        // Check that lines don't extend past the right of the current\n        // editor width\n        if (!wrapping && cur.text.firstChild)\n          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\n      }\n      var diff = cur.line.height - height;\n      if (height < 2) { height = textHeight(display); }\n      if (diff > .005 || diff < -.005) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n          { updateWidgetHeight(cur.rest[j]); } }\n      }\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n      var w = line.widgets[i], parent = w.node.parentNode;\n      if (parent) { w.height = parent.offsetHeight; }\n    } }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)}\n  }\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          { view[i].gutter.style.left = left; }\n        if (view[i].gutterBackground)\n          { view[i].gutterBackground.style.left = left; }\n      }\n      var align = view[i].alignable;\n      if (align) { for (var j = 0; j < align.length; j++)\n        { align[j].style.left = left; } }\n    } }\n    if (cm.options.fixedGutter)\n      { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) { return false }\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm);\n      return true\n    }\n    return false\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (rect.top + box.top < 0) { doScroll = true; }\n    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) { margin = 0; }\n    var rect;\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n    }\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n      var coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      rect = {left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n      }\n      if (!changed) { break }\n    }\n    return rect\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (rect.top < 0) { rect.top = 0; }\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n      if (newTop != screentop) { result.scrollTop = newTop; }\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n    var tooWide = rect.right - rect.left > screenw;\n    if (tooWide) { rect.right = rect.left + screenw; }\n    if (rect.left < 10)\n      { result.scrollLeft = 0; }\n    else if (rect.left < screenleft)\n      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n    else if (rect.right > screenw + screenleft - 3)\n      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n    return result\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollTop(cm, top) {\n    if (top == null) { return }\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) { resolveScrollToPos(cm); }\n    if (x != null) { cm.curOp.scrollLeft = x; }\n    if (y != null) { cm.curOp.scrollTop = y; }\n  }\n\n  function scrollToRange(cm, range$$1) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range$$1;\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range$$1 = cm.curOp.scrollToPos;\n    if (range$$1) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n      scrollToCoordsRange(cm, from, to, range$$1.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  }\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n    if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n    setScrollTop(cm, val, true);\n    if (gecko) { updateDisplaySimple(cm); }\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n  }\n\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    }\n  }\n\n  var NativeScrollbars = function(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      this.vert.firstChild.style.height =\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width =\n        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) { this.zeroWidthHack(); }\n      this.checkedZeroWidth = true;\n    }\n\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n    this.disableHoriz = new Delayed;\n    this.disableVert = new Delayed;\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = \"auto\";\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n      if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n      else { delay.set(1000, maybeDisable); }\n    }\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function () {};\n\n  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\n  NullScrollbars.prototype.setScrollLeft = function () {};\n  NullScrollbars.prototype.setScrollTop = function () {};\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) { measure = measureForScrollbars(cm); }\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        { updateHeightsInViewport(cm); }\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else { d.scrollbarFiller.style.display = \"\"; }\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else { d.gutterFiller.style.display = \"\"; }\n  }\n\n  var scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n      else { updateScrollTop(cm, pos); }\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: 0,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    pushOperation(cm.curOp);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (op) { finishOperation(op, function (group) {\n      for (var i = 0; i < group.ops.length; i++)\n        { group.ops[i].cm.curOp = null; }\n      endOperations(group);\n    }); }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      { endOperation_R1(ops[i]); }\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n      { endOperation_W1(ops[i$1]); }\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n      { endOperation_R2(ops[i$2]); }\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n      { endOperation_W2(ops[i$3]); }\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n      { endOperation_finish(ops[i$4]); }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) { findMaxLine(cm); }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      { op.preparedSelection = display.input.prepareSelection(); }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt();\n    if (op.preparedSelection)\n      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      { updateScrollbars(cm, op.barMeasure); }\n    if (op.updatedDisplay)\n      { setDocumentHeight(cm, op.barMeasure); }\n\n    if (op.selectionChanged) { restartBlink(cm); }\n\n    if (cm.state.focused && op.updateInput)\n      { cm.display.input.reset(op.typing); }\n    if (takeFocus) { ensureFocus(op.cm); }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      { display.wheelStartX = display.wheelStartY = null; }\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) { for (var i = 0; i < hidden.length; ++i)\n      { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n    if (display.wrapper.offsetHeight)\n      { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      { signal(cm, \"changes\", cm, op.changeObjs); }\n    if (op.update)\n      { op.update.finish(); }\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) { return f() }\n    startOperation(cm);\n    try { return f() }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) { return f.apply(cm, arguments) }\n      startOperation(cm);\n      try { return f.apply(cm, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) { return f.apply(this, arguments) }\n      startOperation(this);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(this); }\n    }\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) { return f.apply(this, arguments) }\n      startOperation(cm);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) { from = cm.doc.first; }\n    if (to == null) { to = cm.doc.first + cm.doc.size; }\n    if (!lendiff) { lendiff = 0; }\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      { display.updateLineNumbers = from; }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        { resetView(cm); }\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        { ext.lineN += lendiff; }\n      else if (from < ext.lineN + ext.size)\n        { display.externalMeasured = null; }\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n\n    if (line < display.viewFrom || line >= display.viewTo) { return }\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) { return }\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) { arr.push(type); }\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      { return {index: index, lineN: newN} }\n    var n = cm.display.viewFrom;\n    for (var i = 0; i < index; i++)\n      { n += view[i].size; }\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) { return null }\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN}\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n      else if (display.viewFrom < from)\n        { display.view = display.view.slice(findViewIndex(cm, from)); }\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n      else if (display.viewTo > to)\n        { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n    }\n    return dirty\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo)\n      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.highlightFrontier >= cm.display.viewTo) { return }\n    var end = +new Date + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n        if (resetState) { context.state = resetState; }\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) { line.styleClasses = newCls; }\n        else if (oldCls) { line.styleClasses = null; }\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n        if (ischange) { changedLines.push(context.line); }\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          { processLine(cm, line.text, context); }\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n    if (changedLines.length) { runInOp(cm, function () {\n      for (var i = 0; i < changedLines.length; i++)\n        { regLineChange(cm, changedLines[i], \"text\"); }\n    }); }\n  }\n\n  // DISPLAY DRAWING\n\n  var DisplayUpdate = function(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type))\n      { this.events.push(arguments); }\n  };\n  DisplayUpdate.prototype.finish = function () {\n      var this$1 = this;\n\n    for (var i = 0; i < this.events.length; i++)\n      { signal.apply(null, this$1.events[i]); }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) { return null }\n    var active = activeElt();\n    if (!active || !contains(cm.display.lineDiv, active)) { return null }\n    var result = {activeElt: active};\n    if (window.getSelection) {\n      var sel = window.getSelection();\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n    return result\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n    snapshot.activeElt.focus();\n    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(), range$$1 = document.createRange();\n      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range$$1.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range$$1);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      { return false }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      { return false }\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var selSnapshot = selectionSnapshot(cm);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    restoreSelection(selSnapshot);\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          { break }\n      }\n      if (!updateDisplayIfNeeded(cm, update)) { break }\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        { node.style.display = \"none\"; }\n      else\n        { node.parentNode.removeChild(node); }\n      return next\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) { cur = rm(cur); }\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) { cur = rm(cur); }\n  }\n\n  function updateGutterSpace(cm) {\n    var width = cm.display.gutters.offsetWidth;\n    cm.display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    var i = 0;\n    for (; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n    updateGutterSpace(cm);\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) { wheelPixelsPerUnit = -.53; }\n  else if (gecko) { wheelPixelsPerUnit = 15; }\n  else if (chrome) { wheelPixelsPerUnit = -.7; }\n  else if (safari) { wheelPixelsPerUnit = -1/3; }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n    else if (dy == null) { dy = e.wheelDelta; }\n    return {x: dx, y: dy}\n  }\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        { e_preventDefault(e); }\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) { return }\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) { return }\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  var Selection = function(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\n  Selection.prototype.equals = function (other) {\n      var this$1 = this;\n\n    if (other == this) { return true }\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this$1.ranges[i], there = other.ranges[i];\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n    }\n    return true\n  };\n\n  Selection.prototype.deepCopy = function () {\n      var this$1 = this;\n\n    var out = [];\n    for (var i = 0; i < this.ranges.length; i++)\n      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n    return new Selection(out, this.primIndex)\n  };\n\n  Selection.prototype.somethingSelected = function () {\n      var this$1 = this;\n\n    for (var i = 0; i < this.ranges.length; i++)\n      { if (!this$1.ranges[i].empty()) { return true } }\n    return false\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n      var this$1 = this;\n\n    if (!end) { end = pos; }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this$1.ranges[i];\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n        { return i }\n    }\n    return -1\n  };\n\n  var Range = function(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  };\n\n  Range.prototype.from = function () { return minPos(this.anchor, this.head) };\n  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\n  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) { --primIndex; }\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex)\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0)\n  }\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  function changeEnd(change) {\n    if (!change.text) { return change.to }\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n  }\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) { return pos }\n    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n    return Pos(line, ch)\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex)\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n    else\n      { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex)\n  }\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) { line.stateAfter = null; }\n      if (line.styles) { line.styles = null; }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) { regChange(cm); }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight$$1);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      var result = [];\n      for (var i = start; i < end; ++i)\n        { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n      return result\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) { doc.remove(from.line, nlines); }\n      if (added.length) { doc.insert(from.line, added); }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) { continue }\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) { continue }\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      } }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) { throw new Error(\"This document is already in use.\") }\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    if (!cm.options.lineWrapping) { findMaxLine(cm); }\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n    return histChange\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) { array.pop(); }\n      else { break }\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done)\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done)\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done)\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n    var last;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        { pushSelectionToHistory(doc.sel, hist.done); }\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) { hist.done.shift(); }\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) { signal(doc, \"historyAdded\"); }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      { hist.done[hist.done.length - 1] = sel; }\n    else\n      { pushSelectionToHistory(sel, hist.done); }\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      { clearSelectionEvents(hist.undone); }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      { dest.push(sel); }\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans)\n        { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) { return null }\n    var out;\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n      else if (out) { out.push(spans[i]); }\n    }\n    return !out ? spans : out.length ? out : null\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) { return null }\n    var nw = [];\n    for (var i = 0; i < change.text.length; ++i)\n      { nw.push(removeClearedSpans(found[i])); }\n    return nw\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) { return stretched }\n    if (!stretched) { return old }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            { if (oldCur[k].marker == span.marker) { continue spans } }\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m = (void 0);\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        } } }\n      }\n    }\n    return copy\n  }\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head)\n    } else {\n      return new Range(other || head, head)\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    for (var i = 0; i < doc.sel.ranges.length; i++)\n      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        var this$1 = this;\n\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head)); }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\n    else { return sel }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      { sel = filterSelectionChange(doc, sel, options); }\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      { ensureCursorVisible(doc.cm); }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) { return }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) { out = sel.ranges.slice(0, i); }\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) { break }\n            else {--i; continue}\n          }\n        }\n        if (!m.atomic) { continue }\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n      }\n    } }\n    return pos\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0)\n    }\n    return found\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n      else { return null }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n      else { return null }\n    } else {\n      return new Pos(pos.line, pos.ch + dir)\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  }\n\n  // UPDATING\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function () { return obj.canceled = true; }\n    };\n    if (update) { obj.update = function (from, to, text, origin) {\n      if (from) { obj.from = clipPos(doc, from); }\n      if (to) { obj.to = clipPos(doc, to); }\n      if (text) { obj.text = text; }\n      if (origin !== undefined) { obj.origin = origin; }\n    }; }\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n    if (obj.canceled) {\n      if (doc.cm) { doc.cm.curOp.updateInput = 2; }\n      return null\n    }\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n      if (doc.cm.state.suppressEdits) { return }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) { return }\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n    if (suppress && !allowSelectionOnly) { return }\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    var i = 0;\n    for (; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        { break }\n    }\n    if (i == source.length) { return }\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return\n        }\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return\n      } else { break }\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function ( i ) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {}\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop( i$1 );\n\n      if ( returned ) return returned.v;\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) { return }\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n      Pos(range.anchor.line + distance, range.anchor.ch),\n      Pos(range.head.line + distance, range.head.ch)\n    ); }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        { regLineChange(doc.cm, l, \"gutter\"); }\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return\n    }\n    if (change.from.line > doc.lastLine()) { return }\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n    else { updateDoc(doc, change, spans); }\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      { signalCursorActivity(cm); }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      { regChange(cm); }\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      { regLineChange(cm, from.line, \"text\"); }\n    else\n      { regChange(cm, from.line, to.line + 1, lendiff); }\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) { to = from; }\n    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\n    if (typeof code == \"string\") { code = doc.splitLines(code); }\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue\n      }\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n    else { no = lineNo(handle); }\n    if (no == null) { return null }\n    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n    return line\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    var this$1 = this;\n\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this$1;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length },\n\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      var this$1 = this;\n\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this$1.lines[i];\n        this$1.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      var this$1 = this;\n\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\n    },\n\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      var this$1 = this;\n\n      for (var e = at + n; at < e; ++at)\n        { if (op(this$1.lines[at])) { return true } }\n    }\n  };\n\n  function BranchChunk(children) {\n    var this$1 = this;\n\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this$1;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size },\n\n    removeInner: function(at, n) {\n      var this$1 = this;\n\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this$1.height -= oldHeight - child.height;\n          if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n\n    collapse: function(lines) {\n      var this$1 = this;\n\n      for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\n    },\n\n    insertInner: function(at, lines, height) {\n      var this$1 = this;\n\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this$1.children.splice(++i, 0, leaf);\n              leaf.parent = this$1;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this$1.maybeSpill();\n          }\n          break\n        }\n        at -= sz;\n      }\n    },\n\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) { return }\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10)\n      me.parent.maybeSpill();\n    },\n\n    iterN: function(at, n, op) {\n      var this$1 = this;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) { return true }\n          if ((n -= used) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n    }\n  };\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function(doc, node, options) {\n    var this$1 = this;\n\n    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n      { this$1[opt] = options[opt]; } } }\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n      var this$1 = this;\n\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) { return }\n    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n    if (!ws.length) { line.widgets = null; }\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n      var this$1 = this;\n\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) { return }\n    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      { addToScrollTop(cm, diff); }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) { widgets.push(widget); }\n      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) { addToScrollTop(cm, widget.height); }\n        cm.curOp.forceUpdate = true;\n      }\n      return true\n    });\n    if (cm) { signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle)); }\n    return widget\n  }\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  var TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function () {\n      var this$1 = this;\n\n    if (this.explicitlyCleared) { return }\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) { startOperation(cm); }\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) { signalLater(this, \"clear\", found.from, found.to); }\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this$1.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this$1);\n      if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n      else if (cm) {\n        if (span.to != null) { max = lineNo(line); }\n        if (span.from != null) { min = lineNo(line); }\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\n        { updateLineHeight(line, textHeight(cm.display)); }\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n      var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    } }\n\n    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) { reCheckSelection(cm.doc); }\n    }\n    if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n    if (withOp) { endOperation(cm); }\n    if (this.parent) { this.parent.clear(); }\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function (side, lineObj) {\n      var this$1 = this;\n\n    if (side == null && this.type == \"bookmark\") { side = 1; }\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this$1.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this$1);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) { return from }\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) { return to }\n      }\n    }\n    return from && {from: from, to: to}\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function () {\n      var this$1 = this;\n\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) { return }\n    runInOp(cm, function () {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          { updateLineHeight(line, line.height + dHeight); }\n      }\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n    }\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp\n      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n  eventMixin(TextMarker);\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) { copyObj(options, marker, false); }\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      { return marker }\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory)\n      { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        { updateMaxLine = true; }\n      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n    }); }\n\n    if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n      if (doc.history.done.length || doc.history.undone.length)\n        { doc.clearHistory(); }\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n      if (marker.collapsed)\n        { regChange(cm, from.line, to.line + 1); }\n      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\n               marker.attributes || marker.title)\n        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n      if (marker.atomic) { reCheckSelection(cm.doc); }\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = function(markers, primary) {\n    var this$1 = this;\n\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      { markers[i].parent = this$1; }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n      var this$1 = this;\n\n    if (this.explicitlyCleared) { return }\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      { this$1.markers[i].clear(); }\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj)\n  };\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) { options.widgetNode = widget.cloneNode(true); }\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        { if (doc.linked[i].isParent) { return } }\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary)\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function ( i ) {\n      var marker = markers[i], linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) loop( i );\n  }\n\n  var nextDocId = 0;\n  var Doc = function(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n    if (firstLine == null) { firstLine = 0; }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") { text = this.splitLines(text); }\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) { this.iterN(from - this.first, to - from, op); }\n      else { this.iterN(this.first, this.first + this.size, from); }\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n    getLineNumber: function(line) {return lineNo(line)},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") { line = getLine(this, line); }\n      return visualLine(line)\n    },\n\n    lineCount: function() {return this.size},\n    firstLine: function() {return this.first},\n    lastLine: function() {return this.first + this.size - 1},\n\n    clipPos: function(pos) {return clipPos(this, pos)},\n\n    getCursor: function(start) {\n      var range$$1 = this.sel.primary(), pos;\n      if (start == null || start == \"head\") { pos = range$$1.head; }\n      else if (start == \"anchor\") { pos = range$$1.anchor; }\n      else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n      else { pos = range$$1.from(); }\n      return pos\n    },\n    listSelections: function() { return this.sel.ranges },\n    somethingSelected: function() {return this.sel.somethingSelected()},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      var this$1 = this;\n\n      if (!ranges.length) { return }\n      var out = [];\n      for (var i = 0; i < ranges.length; i++)\n        { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                           clipPos(this$1, ranges[i].head)); }\n      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var this$1 = this;\n\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) { return lines }\n      else { return lines.join(lineSep || this.lineSeparator()) }\n    },\n    getSelections: function(lineSep) {\n      var this$1 = this;\n\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n        parts[i] = sel;\n      }\n      return parts\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        { dup[i] = code; }\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var this$1 = this;\n\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range$$1 = sel.ranges[i];\n        changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n        { makeChange(this$1, changes[i$1]); }\n      if (newSel) { setSelectionReplaceHistory(this, newSel); }\n      else if (this.cm) { ensureCursorVisible(this.cm); }\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n      return {undo: done, redo: undone}\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n      return this.history.generation\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration)\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)}\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    setGutterMarker: docMethodOp(function(line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n        return true\n      })\n    }),\n\n    clearGutter: docMethodOp(function(gutterID) {\n      var this$1 = this;\n\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n            return true\n          });\n        }\n      });\n    }),\n\n    lineInfo: function(line) {\n      var n;\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) { return null }\n        n = line;\n        line = getLine(this, line);\n        if (!line) { return null }\n      } else {\n        n = lineNo(line);\n        if (n == null) { return null }\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets}\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) { line[prop] = cls; }\n        else if (classTest(cls).test(line[prop])) { return false }\n        else { line[prop] += \" \" + cls; }\n        return true\n      })\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) { return false }\n        else if (cls == null) { line[prop] = null; }\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) { return false }\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true\n      })\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options)\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\")\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          { markers.push(span.marker.parent || span.marker); }\n      } }\n      return markers\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo$$1 = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n        if (spans) { for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\n                span.from == null && lineNo$$1 != from.line ||\n                span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            { found.push(span.marker.parent || span.marker); }\n        } }\n        ++lineNo$$1;\n      });\n      return found\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) { for (var i = 0; i < sps.length; ++i)\n          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n      });\n      return markers\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true }\n        off -= sz;\n        ++lineNo$$1;\n      });\n      return clipPos(this, Pos(lineNo$$1, ch))\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) { return 0 }\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc\n    },\n\n    linkedDoc: function(options) {\n      if (!options) { options = {}; }\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) { from = options.from; }\n      if (options.to != null && options.to < to) { to = options.to; }\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n      if (options.sharedHist) { copy.history = this.history\n      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy\n    },\n    unlinkDoc: function(other) {\n      var this$1 = this;\n\n      if (other instanceof CodeMirror) { other = other.doc; }\n      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n        var link = this$1.linked[i];\n        if (link.doc != other) { continue }\n        this$1.linked.splice(i, 1);\n        other.unlinkDoc(this$1);\n        detachSharedMarkers(findSharedMarkers(this$1));\n        break\n      } }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode},\n    getEditor: function() {return this.cm},\n\n    splitLines: function(str) {\n      if (this.lineSep) { return str.split(this.lineSep) }\n      return splitLinesAuto(str)\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") { dir = \"ltr\"; }\n      if (dir == this.direction) { return }\n      this.direction = dir;\n      this.iter(function (line) { return line.order = null; });\n      if (this.cm) { directionChanged(this.cm); }\n    })\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      { return }\n    e_preventDefault(e);\n    if (ie) { lastDrop = +new Date; }\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) { return }\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function (file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n          { return }\n\n        var reader = new FileReader;\n        reader.onload = operation(cm, function () {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n          text[i] = content;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function () { return cm.display.input.focus(); }, 20);\n        return\n      }\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n        if (text$1) {\n          var selected;\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            { selected = cm.listSelections(); }\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n            { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\";\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) { img.parentNode.removeChild(img); }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) { return }\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) { return }\n    var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) { editors.push(cm); }\n    }\n    if (editors.length) { editors[0].operation(function () {\n      for (var i = 0; i < editors.length; i++) { f(editors[i]); }\n    }); }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) { return }\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100); }\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n  }\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\", 145: \"ScrollLock\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n\n  // Number keys\n  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n  // Alphabetic keys\n  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n  // Function keys\n  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\n  var keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n    \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n      else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n      else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n      else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n    }\n    if (alt) { name = \"Alt-\" + name; }\n    if (ctrl) { name = \"Ctrl-\" + name; }\n    if (cmd) { name = \"Cmd-\" + name; }\n    if (shift) { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n      if (value == \"...\") { delete keymap[keyname]; continue }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val = (void 0), name = (void 0);\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) { copy[name] = val; }\n        else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n      }\n      delete keymap[keyname];\n    } }\n    for (var prop in copy) { keymap[prop] = copy[prop]; }\n    return keymap\n  }\n\n  function lookupKey(key, map$$1, handle, context) {\n    map$$1 = getKeyMap(map$$1);\n    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n    if (found === false) { return \"nothing\" }\n    if (found === \"...\") { return \"multi\" }\n    if (found != null && handle(found)) { return \"handled\" }\n\n    if (map$$1.fallthrough) {\n      if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n        { return lookupKey(key, map$$1.fallthrough, handle, context) }\n      for (var i = 0; i < map$$1.fallthrough.length; i++) {\n        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n        if (result) { return result }\n      }\n    }\n  }\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n    if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\n    if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // Look up the name of a key as indicated by an event object.\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) { return false }\n    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n    if (event.keyCode == 3 && event.code) { name = event.code; }\n    return addModifierNames(name, event, noShift)\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = (dir < 0) == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch;\n        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n          if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n        } else { ch = dir < 0 ? part.to : part.from; }\n        return new Pos(lineNo, ch, sticky)\n      }\n    }\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n    if (!bidi) { return moveLogically(line, start, dir) }\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir)\n    }\n\n    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n    var prep;\n    var getWrappedLineExtent = function (ch) {\n      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch)\n    };\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = (part.level == 1) == (dir < 0);\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky)\n      }\n    }\n\n    // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n        ? new Pos(start.line, mv(ch, 1), \"before\")\n        : new Pos(start.line, ch, \"after\"); };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = (dir > 0) == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n      }\n    };\n\n    // Case 3a: Look for other bidi parts on the same visual line\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n    if (res) { return res }\n\n    // Case 3b: Look for other bidi parts on the next visual line\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n      if (res) { return res }\n    }\n\n    // Case 4: Nowhere to move\n    return null\n  }\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n    killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n      if (range.empty()) {\n        var len = getLine(cm.doc, range.head.line).text.length;\n        if (range.head.ch == len && range.head.line < cm.lastLine())\n          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n        else\n          { return {from: range.head, to: Pos(range.head.line, len)} }\n      } else {\n        return {from: range.from(), to: range.to()}\n      }\n    }); },\n    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0),\n      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n    }); }); },\n    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0), to: range.from()\n    }); }); },\n    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n      return {from: leftPos, to: range.from()}\n    }); },\n    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      return {from: range.from(), to: rightPos }\n    }); },\n    undo: function (cm) { return cm.undo(); },\n    redo: function (cm) { return cm.redo(); },\n    undoSelection: function (cm) { return cm.undoSelection(); },\n    redoSelection: function (cm) { return cm.redoSelection(); },\n    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n      {origin: \"+move\", bias: -1}\n    ); },\n    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: 0, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n      if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n      return pos\n    }, sel_move); },\n    goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n    goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n    goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n    goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n    goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n    goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n    goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n    goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n    goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n    goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n    goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n    goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n    delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n    delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n    delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n    delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n    delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n    delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n    indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n    indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n    indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n    insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n    insertSoftTab: function (cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function (cm) {\n      if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n      else { cm.execCommand(\"insertTab\"); }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function (cm) { return runInOp(cm, function () {\n      var ranges = cm.listSelections(), newSel = [];\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty()) { continue }\n        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n        if (line) {\n          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n          if (cur.ch > 0) {\n            cur = new Pos(cur.line, cur.ch + 1);\n            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                            Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n          } else if (cur.line > cm.doc.first) {\n            var prev = getLine(cm.doc, cur.line - 1).text;\n            if (prev) {\n              cur = new Pos(cur.line, 1);\n              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                              prev.charAt(prev.length - 1),\n                              Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n            }\n          }\n        }\n        newSel.push(new Range(cur, cur));\n      }\n      cm.setSelections(newSel);\n    }); },\n    newlineAndIndent: function (cm) { return runInOp(cm, function () {\n      var sels = cm.listSelections();\n      for (var i = sels.length - 1; i >= 0; i--)\n        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n      sels = cm.listSelections();\n      for (var i$1 = 0; i$1 < sels.length; i$1++)\n        { cm.indentLine(sels[i$1].from().line, null, true); }\n      ensureCursorVisible(cm);\n    }); },\n    openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n  };\n\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, visual, lineN, 1)\n  }\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, line, lineN, -1)\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n    }\n    return start\n  }\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) { return false }\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      if (dropShift) { cm.display.shift = false; }\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) { return result }\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm)\n  }\n\n  // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n  var stopSeq = new Delayed;\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) { return \"handled\" }\n      if (/\\'$/.test(name))\n        { cm.state.keySeq = null; }\n      else\n        { stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        }); }\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n    }\n    return dispatchKeyInner(cm, name, e, handle)\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      { cm.state.keySeq = name; }\n    if (result == \"handled\")\n      { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) { return false }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n          || dispatchKey(cm, name, e, function (b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 { return doHandleBinding(cm, b) }\n             })\n    } else {\n      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) { return }\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        { cm.replaceSelection(\"\", null, \"cut\"); }\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      { showCrossHair(cm); }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) { this.doc.sel.shift = false; }\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    // Some browsers fire keypress events for backspace\n    if (ch == \"\\x08\") { return }\n    if (handleCharBinding(cm, e, ch)) { return }\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time &&\n      cmp(pos, this.pos) == 0 && button == this.button\n  };\n\n  var lastClick, lastDoubleClick;\n  function clickRepeat(pos, button) {\n    var now = +new Date;\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\"\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\"\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\"\n    }\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () { return display.scroller.draggable = true; }, 100);\n      }\n      return\n    }\n    if (clickInGutter(cm, e)) { return }\n    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n    window.focus();\n\n    // #3261: make sure, that we're not starting a second selection\n    if (button == 1 && cm.state.selectingText)\n      { cm.state.selectingText(e); }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n    if (button == 1) {\n      if (pos) { leftButtonDown(cm, pos, repeat, e); }\n      else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n    } else if (button == 2) {\n      if (pos) { extendSelection(cm.doc, pos); }\n      setTimeout(function () { return display.input.focus(); }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) { cm.display.input.onContextMenu(e); }\n      else { delayBlurEvent(cm); }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n    if (repeat == \"double\") { name = \"Double\" + name; }\n    else if (repeat == \"triple\") { name = \"Triple\" + name; }\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") { bound = commands[bound]; }\n      if (!bound) { return false }\n      var done = false;\n      try {\n        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n      return done\n    })\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n    return value\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n    else { cm.curOp.focus = activeElt(); }\n\n    var behavior = configureMouse(cm, repeat, event);\n\n    var sel = cm.doc.sel, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n      { leftButtonStartDrag(cm, event, pos, behavior); }\n    else\n      { leftButtonSelect(cm, event, pos, behavior); }\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display, moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) { display.scroller.draggable = false; }\n      cm.state.draggingText = false;\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n      if (!moved) {\n        e_preventDefault(e);\n        if (!behavior.addNew)\n          { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if (webkit || ie && ie_version == 9)\n          { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }\n        else\n          { display.input.focus(); }\n      }\n    });\n    var mouseMove = function(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n    var dragStart = function () { return moved = true; };\n    // Let the drag handler handle this.\n    if (webkit) { display.scroller.draggable = true; }\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n\n    delayBlurEvent(cm);\n    setTimeout(function () { return display.input.focus(); }, 20);\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") { return new Range(pos, pos) }\n    if (unit == \"word\") { return cm.findWordAt(pos) }\n    if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to)\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, event, start, behavior) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(event);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        { ourRange = ranges[ourIndex]; }\n      else\n        { ourRange = new Range(start, start); }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) { ourRange = new Range(start, start); }\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range$$1 = rangeForUnit(cm, start, behavior.unit);\n      if (behavior.extend)\n        { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\n      else\n        { ourRange = range$$1; }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) { return }\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n          else if (text.length > leftPos)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n        }\n        if (!ranges.length) { ranges.push(new Range(start, start)); }\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range$$1 = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor, head;\n        if (cmp(range$$1.anchor, anchor) > 0) {\n          head = range$$1.head;\n          anchor = minPos(oldRange.from(), range$$1.anchor);\n        } else {\n          head = range$$1.anchor;\n          anchor = maxPos(oldRange.to(), range$$1.head);\n        }\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n      if (!cur) { return }\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) { setTimeout(operation(cm, function () {\n          if (counter != curCount) { return }\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50); }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      e_preventDefault(e);\n      display.input.focus();\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) { done(e); }\n      else { extend(e); }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  }\n\n  // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n  function bidiSimplify(cm, range$$1) {\n    var anchor = range$$1.anchor;\n    var head = range$$1.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }\n    var order = getOrder(anchorLine);\n    if (!order) { return range$$1 }\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n    if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }\n    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n    if (boundary == 0 || boundary == order.length) { return range$$1 }\n\n    // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n    var leftSide;\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n      if (headIndex == boundary - 1 || headIndex == boundary)\n        { leftSide = dir < 0; }\n      else\n        { leftSide = dir > 0; }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)\n  }\n\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try { mX = e.clientX; mY = e.clientY; }\n      catch(e) { return false }\n    }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n    if (prevent) { e_preventDefault(e); }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signal(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e)\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true)\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n    if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n    if (!captureRightClick) { cm.display.input.onContextMenu(e); }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n    return gutterEvent(cm, e, \"gutterContextMenu\", false)\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {toString: function(){return \"CodeMirror.Init\"}};\n\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n      if (handle) { optionHandlers[name] =\n        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n    }\n\n    CodeMirror.defineOption = option;\n\n    // Passed to option handlers when there is no old value.\n    CodeMirror.Init = Init;\n\n    // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n    option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n      if (!val) { return }\n      var newBreaks = [], lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n          if (found == -1) { break }\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n        lineNo++;\n      });\n      for (var i = newBreaks.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n      if (old != Init) { cm.refresh(); }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      guttersChanged(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n      if (prev && prev.detach) { prev.detach(cm, next); }\n      if (next.attach) { next.attach(cm, prev || null); }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm) {\n      setGuttersForLineNumbers(cm.options);\n      guttersChanged(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm) {\n      setGuttersForLineNumbers(cm.options);\n      guttersChanged(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, guttersChanged, true);\n    option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n      cm.display.input.readOnlyChanged(val);\n    });\n    option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) { cm.display.input.resetPosition(); }\n    });\n\n    option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n    option(\"phrases\", null);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    alignHorizontally(cm);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () { return updateScrollbars(cm); }, 100);\n  }\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n    setGuttersForLineNumbers(options);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n    else if (options.mode) { doc.modeOption = options.mode; }\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    themeChanged(this);\n    if (options.lineWrapping)\n      { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) { display.input.focus(); }\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || this.hasFocus())\n      { setTimeout(bind(onFocus, this), 20); }\n    else\n      { onBlur(this); }\n\n    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n      { optionHandlers[opt](this$1, options[opt], Init); } }\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) { options.finishInit(this); }\n    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      { display.lineDiv.style.textRendering = \"auto\"; }\n  }\n\n  // The default configuration options.\n  CodeMirror.defaults = defaults;\n  // Functions to run when options are changed.\n  CodeMirror.optionHandlers = optionHandlers;\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) { return }\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      })); }\n    else\n      { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); });\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    }\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) { return false }\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1\n    }\n    function farAway(touch, other) {\n      if (other.left == null) { return true }\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20\n    }\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) { d.activeTouch.moved = true; }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          { range = new Range(pos, pos); }\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          { range = cm.findWordAt(pos); }\n        else // Triple tap\n          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n    on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function (e) { return onDragStart(cm, e); },\n      drop: operation(cm, onDrop),\n      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n    on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n  }\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) { how = \"add\"; }\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) { how = \"prev\"; }\n      else { state = getContextBefore(cm, n).state; }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) { line.stateAfter = null; }\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) { return }\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n      else { indentation = 0; }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n    if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break\n        }\n      }\n    }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) { sel = doc.sel; }\n\n    var paste = cm.state.pasteIncoming || origin == \"paste\";\n    var textLines = splitLinesAuto(inserted), multiPaste = null;\n    // When pasting N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) { return [l]; });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput;\n    // Normal behavior is to insert the new text into every selection\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range$$1 = sel.ranges[i$1];\n      var from = range$$1.from(), to = range$$1.to();\n      if (range$$1.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          { from = Pos(from.line, from.ch - deleted); }\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n          { from = to = Pos(from.line, 0); }\n      }\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      { triggerElectric(cm, inserted); }\n\n    ensureCursorVisible(cm);\n    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n      return true\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range$$1 = sel.ranges[i];\n      if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n      var mode = cm.getModeAt(range$$1.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range$$1.head.line, \"smart\");\n            break\n          } }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n          { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n      }\n      if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges}\n  }\n\n  function disableBrowserMagic(field, spellcheck) {\n    field.setAttribute(\"autocorrect\", \"off\");\n    field.setAttribute(\"autocapitalize\", \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) { te.style.width = \"1000px\"; }\n    else { te.setAttribute(\"wrap\", \"off\"); }\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) { te.style.border = \"1px solid black\"; }\n    disableBrowserMagic(te);\n    return div\n  }\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    var helpers = CodeMirror.helpers = {};\n\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function(){window.focus(); this.display.input.focus();},\n\n      setOption: function(option, value) {\n        var options = this.options, old = options[option];\n        if (options[option] == value && option != \"mode\") { return }\n        options[option] = value;\n        if (optionHandlers.hasOwnProperty(option))\n          { operation(this, optionHandlers[option])(this, value, old); }\n        signal(this, \"optionChange\", this, option);\n      },\n\n      getOption: function(option) {return this.options[option]},\n      getDoc: function() {return this.doc},\n\n      addKeyMap: function(map$$1, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n      },\n      removeKeyMap: function(map$$1) {\n        var maps = this.state.keyMaps;\n        for (var i = 0; i < maps.length; ++i)\n          { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n            maps.splice(i, 1);\n            return true\n          } }\n      },\n\n      addOverlay: methodOp(function(spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n        if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n        insertSorted(this.state.overlays,\n                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                      priority: (options && options.priority) || 0},\n                     function (overlay) { return overlay.priority; });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function(spec) {\n        var this$1 = this;\n\n        var overlays = this.state.overlays;\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this$1.state.modeGen++;\n            regChange(this$1);\n            return\n          }\n        }\n      }),\n\n      indentLine: methodOp(function(n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n          else { dir = dir ? \"add\" : \"subtract\"; }\n        }\n        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n      }),\n      indentSelection: methodOp(function(how) {\n        var this$1 = this;\n\n        var ranges = this.doc.sel.ranges, end = -1;\n        for (var i = 0; i < ranges.length; i++) {\n          var range$$1 = ranges[i];\n          if (!range$$1.empty()) {\n            var from = range$$1.from(), to = range$$1.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n            for (var j = start; j < end; ++j)\n              { indentLine(this$1, j, how); }\n            var newRanges = this$1.doc.sel.ranges;\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n              { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n          } else if (range$$1.head.line > end) {\n            indentLine(this$1, range$$1.head.line, how, true);\n            end = range$$1.head.line;\n            if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n          }\n        }\n      }),\n\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function(pos, precise) {\n        return takeToken(this, pos, precise)\n      },\n\n      getLineTokens: function(line, precise) {\n        return takeToken(this, Pos(line), precise, true)\n      },\n\n      getTokenTypeAt: function(pos) {\n        pos = clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n        var type;\n        if (ch == 0) { type = styles[2]; }\n        else { for (;;) {\n          var mid = (before + after) >> 1;\n          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n          else { type = styles[mid * 2 + 2]; break }\n        } }\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n      },\n\n      getModeAt: function(pos) {\n        var mode = this.doc.mode;\n        if (!mode.innerMode) { return mode }\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n      },\n\n      getHelper: function(pos, type) {\n        return this.getHelpers(pos, type)[0]\n      },\n\n      getHelpers: function(pos, type) {\n        var this$1 = this;\n\n        var found = [];\n        if (!helpers.hasOwnProperty(type)) { return found }\n        var help = helpers[type], mode = this.getModeAt(pos);\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) { found.push(help[mode[type]]); }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n            if (val) { found.push(val); }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\n            { found.push(cur.val); }\n        }\n        return found\n      },\n\n      getStateAfter: function(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n        return getContextBefore(this, line + 1, precise).state\n      },\n\n      cursorCoords: function(start, mode) {\n        var pos, range$$1 = this.doc.sel.primary();\n        if (start == null) { pos = range$$1.head; }\n        else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n        else { pos = start ? range$$1.from() : range$$1.to(); }\n        return cursorCoords(this, pos, mode || \"page\")\n      },\n\n      charCoords: function(pos, mode) {\n        return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n      },\n\n      coordsChar: function(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return coordsChar(this, coords.left, coords.top)\n      },\n\n      lineAtHeight: function(height, mode) {\n        height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n        return lineAtHeight(this.doc, height + this.display.viewOffset)\n      },\n      heightAtLine: function(line, mode, includeWidgets) {\n        var end = false, lineObj;\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n          if (line < this.doc.first) { line = this.doc.first; }\n          else if (line > last) { line = last; end = true; }\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n          (end ? this.doc.height - heightAtLine(lineObj) : 0)\n      },\n\n      defaultTextHeight: function() { return textHeight(this.display) },\n      defaultCharWidth: function() { return charWidth(this.display) },\n\n      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = cursorCoords(this, clipPos(this.doc, pos));\n        var top = pos.bottom, left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n          // Default to positioning above (if specified and possible); otherwise default to positioning below\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n            { top = pos.top - node.offsetHeight; }\n          else if (pos.bottom + node.offsetHeight <= vspace)\n            { top = pos.bottom; }\n          if (left + node.offsetWidth > hspace)\n            { left = hspace - node.offsetWidth; }\n        }\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") { left = 0; }\n          else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n          node.style.left = left + \"px\";\n        }\n        if (scroll)\n          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n      },\n\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n\n      execCommand: function(cmd) {\n        if (commands.hasOwnProperty(cmd))\n          { return commands[cmd].call(null, this) }\n      },\n\n      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n      findPosH: function(from, amount, unit, visually) {\n        var this$1 = this;\n\n        var dir = 1;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          cur = findPosH(this$1.doc, cur, dir, unit, visually);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveH: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        this.extendSelectionsBy(function (range$$1) {\n          if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n            { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n          else\n            { return dir < 0 ? range$$1.from() : range$$1.to() }\n        }, sel_move);\n      }),\n\n      deleteH: methodOp(function(dir, unit) {\n        var sel = this.doc.sel, doc = this.doc;\n        if (sel.somethingSelected())\n          { doc.replaceSelection(\"\", null, \"+delete\"); }\n        else\n          { deleteNearSelection(this, function (range$$1) {\n            var other = findPosH(doc, range$$1.head, dir, unit, false);\n            return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n          }); }\n      }),\n\n      findPosV: function(from, amount, unit, goalColumn) {\n        var this$1 = this;\n\n        var dir = 1, x = goalColumn;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          var coords = cursorCoords(this$1, cur, \"div\");\n          if (x == null) { x = coords.left; }\n          else { coords.left = x; }\n          cur = findPosV(this$1, coords, dir, unit);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveV: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        var doc = this.doc, goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range$$1) {\n          if (collapse)\n            { return dir < 0 ? range$$1.from() : range$$1.to() }\n          var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n          if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n          goals.push(headPos.left);\n          var pos = findPosV(this$1, headPos, dir, unit);\n          if (unit == \"page\" && range$$1 == doc.sel.primary())\n            { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n          return pos\n        }, sel_move);\n        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n          { doc.sel.ranges[i].goalColumn = goals[i]; } }\n      }),\n\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function(pos) {\n        var doc = this.doc, line = getLine(doc, pos.line).text;\n        var start = pos.ch, end = pos.ch;\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n          if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper)\n            ? function (ch) { return isWordChar(ch, helper); }\n            : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n            : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n          while (start > 0 && check(line.charAt(start - 1))) { --start; }\n          while (end < line.length && check(line.charAt(end))) { ++end; }\n        }\n        return new Range(Pos(pos.line, start), Pos(pos.line, end))\n      },\n\n      toggleOverwrite: function(value) {\n        if (value != null && value == this.state.overwrite) { return }\n        if (this.state.overwrite = !this.state.overwrite)\n          { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n        else\n          { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function() { return this.display.input.getField() == activeElt() },\n      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n      getScrollInfo: function() {\n        var scroller = this.display.scroller;\n        return {left: scroller.scrollLeft, top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n      },\n\n      scrollIntoView: methodOp(function(range$$1, margin) {\n        if (range$$1 == null) {\n          range$$1 = {from: this.doc.sel.primary().head, to: null};\n          if (margin == null) { margin = this.options.cursorScrollMargin; }\n        } else if (typeof range$$1 == \"number\") {\n          range$$1 = {from: Pos(range$$1, 0), to: null};\n        } else if (range$$1.from == null) {\n          range$$1 = {from: range$$1, to: null};\n        }\n        if (!range$$1.to) { range$$1.to = range$$1.from; }\n        range$$1.margin = margin || 0;\n\n        if (range$$1.from.line != null) {\n          scrollToRange(this, range$$1);\n        } else {\n          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n        }\n      }),\n\n      setSize: methodOp(function(width, height) {\n        var this$1 = this;\n\n        var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n        if (width != null) { this.display.wrapper.style.width = interpret(width); }\n        if (height != null) { this.display.wrapper.style.height = interpret(height); }\n        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n        var lineNo$$1 = this.display.viewFrom;\n        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n          ++lineNo$$1;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n\n      operation: function(f){return runInOp(this, f)},\n      startOperation: function(){return startOperation(this)},\n      endOperation: function(){return endOperation(this)},\n\n      refresh: methodOp(function() {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this);\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n          { estimateLineHeights(this); }\n        signal(this, \"refresh\", this);\n      }),\n\n      swapDoc: methodOp(function(doc) {\n        var old = this.doc;\n        old.cm = null;\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old\n      }),\n\n      phrase: function(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\n      },\n\n      getInputField: function(){return this.display.input.getField()},\n      getWrapperElement: function(){return this.display.wrapper},\n      getScrollerElement: function(){return this.display.scroller},\n      getGutterElement: function(){return this.display.gutters}\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function(type, name, value) {\n      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n      helpers[type][name] = value;\n    };\n    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n      helpers[type]._global.push({pred: predicate, val: value});\n    };\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    function findNextLine() {\n      var l = pos.line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) { return false }\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l)\n    }\n    function moveOnce(boundToLine) {\n      var next;\n      if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n      if (next == null) {\n        if (!boundToLine && findNextLine())\n          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n        else\n          { return false }\n      } else {\n        pos = next;\n      }\n      return true\n    }\n\n    if (unit == \"char\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) { break }\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) { type = \"s\"; }\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n          break\n        }\n\n        if (type) { sawType = type; }\n        if (dir > 0 && !moveOnce(!first)) { break }\n      }\n    }\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n    return result\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    var target;\n    for (;;) {\n      target = coordsChar(cm, x, y);\n      if (!target.outside) { break }\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n      y += dir * 5;\n    }\n    return target\n  }\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  var ContentEditableInput = function(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = input.cm;\n    var div = input.div = display.lineDiv;\n    disableBrowserMagic(div, cm.options.spellcheck);\n\n    on(div, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n      // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n    });\n\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {data: e.data, done: false};\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n        this$1.composing.done = true;\n      }\n    });\n\n    on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n    on(div, \"input\", function () {\n      if (!this$1.composing) { this$1.readFromDOMSoon(); }\n    });\n\n    function onCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n        if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\");\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        e.clipboardData.setData(\"Text\", content);\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return\n        }\n      }\n      // Old-fashioned briefly-focus-a-textarea hack\n      var kludge = hiddenTextarea(), te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = document.activeElement;\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n        if (hadFocus == div) { input.showPrimarySelection(); }\n      }, 50);\n    }\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = this.cm.state.focused;\n    return result\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) { return }\n    if (info.focus || takeFocus) { this.showPrimarySelection(); }\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection()\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n    var from = prim.from(), to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n        cmp(minPos(curAnchor, curFocus), from) == 0 &&\n        cmp(maxPos(curAnchor, curFocus), to) == 0)\n      { return }\n\n    var view = cm.display.view;\n    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n        {node: view[0].measure.map[2], offset: 0};\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0), rng;\n    try { rng = range(start.node, start.offset, end.offset, end.node); }\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n      if (old && sel.anchorNode == null) { sel.addRange(old); }\n      else if (gecko) { this.startGracePeriod(); }\n    }\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n      var this$1 = this;\n\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n      if (this$1.selectionChanged())\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n    if (!sel.rangeCount) { return false }\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node)\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor())\n        { this.showSelection(this.prepareSelection(), true); }\n      this.div.focus();\n    }\n  };\n  ContentEditableInput.prototype.blur = function () { this.div.blur(); };\n  ContentEditableInput.prototype.getField = function () { return this.div };\n\n  ContentEditableInput.prototype.supportsTouch = function () { return true };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var input = this;\n    if (this.selectionInEditor())\n      { this.pollSelection(); }\n    else\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n    var sel = this.getSelection(), cm = this.cm;\n    // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n    if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n      this.blur();\n      this.focus();\n      return\n    }\n    if (this.composing) { return }\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (anchor && head) { runInOp(cm, function () {\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n    }); }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n    var from = sel.from(), to = sel.to();\n    if (from.ch == 0 && from.line > cm.firstLine())\n      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n      { to = Pos(to.line + 1, 0); }\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n    var fromIndex, fromLine, fromNode;\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) { return false }\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n      else { break }\n    }\n\n    var cutFront = 0, cutEnd = 0;\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n      { ++cutFront; }\n    var newBot = lst(newText), oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0));\n    while (cutEnd < maxCutEnd &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n      { ++cutEnd; }\n    // Try to move start of change to start of selection if ambiguous\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n      return true\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) { return }\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n      var this$1 = this;\n\n    if (this.readDOMTimeout != null) { return }\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n      if (this$1.composing) {\n        if (this$1.composing.done) { this$1.composing = null; }\n        else { return }\n      }\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n      var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent())\n      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) { return }\n    e.preventDefault();\n    if (!this.cm.isReadOnly())\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) { return null }\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line, cm.doc.direction), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode)\n      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n    return false\n  }\n\n  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n    function close() {\n      if (closing) {\n        text += lineSep;\n        if (extraLinebreak) { text += lineSep; }\n        closing = extraLinebreak = false;\n      }\n    }\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText) {\n          addText(cmText);\n          return\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range$$1 = found[0].find(0)))\n            { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n          return\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }\n\n        if (isBlock) { close(); }\n        for (var i = 0; i < node.childNodes.length; i++)\n          { walk(node.childNodes[i]); }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\n        if (isBlock) { closing = true; }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) { break }\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n    return text\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        { return locateNodeInLineView(lineView, node, offset) }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad)\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) { offset = textNode.nodeValue.length; }\n    }\n    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map$$1 = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map$$1.length; j += 3) {\n          var curNode = map$$1[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map$$1[j] + offset;\n            if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n            return Pos(line, ch)\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) { return badPos(found, bad) }\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        { return badPos(Pos(found.line, found.ch - dist), bad) }\n      else\n        { dist += after.textContent.length; }\n    }\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n      else\n        { dist$1 += before.textContent.length; }\n    }\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  var TextareaInput = function(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n    if (ios) { te.style.width = \"0px\"; }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n      input.poll();\n    });\n\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n      cm.state.pasteIncoming = true;\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n      if (e.type == \"cut\") { cm.state.cutIncoming = true; }\n    }\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n      cm.state.pasteIncoming = true;\n      input.focus();\n    });\n\n    // Prevent normal selection in the editor (we handle our own)\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) { e_preventDefault(e); }\n    });\n\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n      if (input.composing) { input.composing.range.clear(); }\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea();\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm, display = cm.display, doc = cm.doc;\n    var result = prepareSelection(cm);\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm, display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  };\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) { return }\n    var cm = this.cm;\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n      if (cm.state.focused) { selectInput(this.textarea); }\n      if (ie && ie_version >= 9) { this.hasSelection = content; }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n      if (ie && ie_version >= 9) { this.hasSelection = null; }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () { return this.textarea };\n\n  TextareaInput.prototype.supportsTouch = function () { return false };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n      try { this.textarea.focus(); }\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n    }\n  };\n\n  TextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  TextareaInput.prototype.slowPoll = function () {\n      var this$1 = this;\n\n    if (this.pollingFast) { return }\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n      if (this$1.cm.state.focused) { this$1.slowPoll(); }\n    });\n  };\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false, input = this;\n    input.pollingFast = true;\n    function p() {\n      var changed = input.poll();\n      if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n      else {input.pollingFast = false; input.slowPoll();}\n    }\n    input.polling.set(20, p);\n  };\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  TextareaInput.prototype.poll = function () {\n      var this$1 = this;\n\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (this.contextMenuPending || !cm.state.focused ||\n        (hasSelection(input) && !prevInput && !this.composing) ||\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n      { return false }\n\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) { return false }\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && this.hasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n      if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n    }\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\n                     null, this$1.composing ? \"*compose\" : null);\n\n      // Don't leave long text in the textarea, since it makes further polling slow\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n      else { this$1.prevInput = text; }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                           {className: \"CodeMirror-composing\"});\n      }\n    });\n    return true\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n    if (input.contextMenuPending) { input.contextMenuPending(); }\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) { return } // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n    display.input.focus();\n    if (webkit) { window.scrollTo(null, oldScrollY); }\n    display.input.reset();\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200b\" + (selected ? te.value : \"\");\n        te.value = \"\\u21da\"; // Used to catch context-menu undo\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200b\";\n        te.selectionStart = 1; te.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      if (input.contextMenuPending != rehide) { return }\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n      // Try to detect the user choosing select-all\n      if (te.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n        var i = 0, poll = function () {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n              te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function () {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) { this.reset(); }\n    this.textarea.disabled = val == \"nocursor\";\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      { options.tabindex = textarea.tabIndex; }\n    if (!options.placeholder && textarea.placeholder)\n      { options.placeholder = textarea.placeholder; }\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n\n    var realSubmit;\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n      cm.getTextArea = function () { return textarea; };\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (typeof textarea.form.submit == \"function\")\n            { textarea.form.submit = realSubmit; }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n      options);\n    return cm\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  }\n\n  // EDITOR CONSTRUCTOR\n\n  defineOptions(CodeMirror);\n\n  addEditorMethods(CodeMirror);\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    { CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments)}\n    })(Doc.prototype[prop]); } }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name/*, mode, \u2026*/) {\n    if (!CodeMirror.defaults.mode && name != \"null\") { CodeMirror.defaults.mode = name; }\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME;\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n\n  addLegacyProps(CodeMirror);\n\n  CodeMirror.version = \"5.42.2\";\n\n  return CodeMirror;\n\n})));\n","Magezon_Builder/vendor/angular-drag-and-drop-lists/angular-drag-and-drop-lists.js":"/**\n * angular-drag-and-drop-lists v2.1.0\n *\n * Copyright (c) 2014 Marcel Juenemann marcel@juenemann.cc\n * Copyright (c) 2014-2017 Google Inc.\n * https://github.com/marceljuenemann/angular-drag-and-drop-lists\n *\n * License: MIT\n */\n(function(dndLists) {\n\n  // In standard-compliant browsers we use a custom mime type and also encode the dnd-type in it.\n  // However, IE and Edge only support a limited number of mime types. The workarounds are described\n  // in https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n  var MIME_TYPE = 'application/x-dnd';\n  var EDGE_MIME_TYPE = 'application/json';\n  var MSIE_MIME_TYPE = 'Text';\n\n  // All valid HTML5 drop effects, in the order in which we prefer to use them.\n  var ALL_EFFECTS = ['move', 'copy', 'link'];\n\n  /**\n   * Use the dnd-draggable attribute to make your element draggable\n   *\n   * Attributes:\n   * - dnd-draggable      Required attribute. The value has to be an object that represents the data\n   *                      of the element. In case of a drag and drop operation the object will be\n   *                      serialized and unserialized on the receiving end.\n   * - dnd-effect-allowed Use this attribute to limit the operations that can be performed. Valid\n   *                      options are \"move\", \"copy\" and \"link\", as well as \"all\", \"copyMove\",\n   *                      \"copyLink\" and \"linkMove\". The semantics of these operations are up to you\n   *                      and have to be implemented using the callbacks described below. If you\n   *                      allow multiple options, the user can choose between them by using the\n   *                      modifier keys (OS specific). The cursor will be changed accordingly,\n   *                      expect for IE and Edge, where this is not supported.\n   * - dnd-type           Use this attribute if you have different kinds of items in your\n   *                      application and you want to limit which items can be dropped into which\n   *                      lists. Combine with dnd-allowed-types on the dnd-list(s). This attribute\n   *                      must be a lower case string. Upper case characters can be used, but will\n   *                      be converted to lower case automatically.\n   * - dnd-disable-if     You can use this attribute to dynamically disable the draggability of the\n   *                      element. This is useful if you have certain list items that you don't want\n   *                      to be draggable, or if you want to disable drag & drop completely without\n   *                      having two different code branches (e.g. only allow for admins).\n   *\n   * Callbacks:\n   * - dnd-dragstart      Callback that is invoked when the element was dragged. The original\n   *                      dragstart event will be provided in the local event variable.\n   * - dnd-moved          Callback that is invoked when the element was moved. Usually you will\n   *                      remove your element from the original list in this callback, since the\n   *                      directive is not doing that for you automatically. The original dragend\n   *                      event will be provided in the local event variable.\n   * - dnd-copied         Same as dnd-moved, just that it is called when the element was copied\n   *                      instead of moved, so you probably want to implement a different logic.\n   * - dnd-linked         Same as dnd-moved, just that it is called when the element was linked\n   *                      instead of moved, so you probably want to implement a different logic.\n   * - dnd-canceled       Callback that is invoked if the element was dragged, but the operation was\n   *                      canceled and the element was not dropped. The original dragend event will\n   *                      be provided in the local event variable.\n   * - dnd-dragend        Callback that is invoked when the drag operation ended. Available local\n   *                      variables are event and dropEffect.\n   * - dnd-selected       Callback that is invoked when the element was clicked but not dragged.\n   *                      The original click event will be provided in the local event variable.\n   * - dnd-callback       Custom callback that is passed to dropzone callbacks and can be used to\n   *                      communicate between source and target scopes. The dropzone can pass user\n   *                      defined variables to this callback.\n   *\n   * CSS classes:\n   * - dndDragging        This class will be added to the element while the element is being\n   *                      dragged. It will affect both the element you see while dragging and the\n   *                      source element that stays at it's position. Do not try to hide the source\n   *                      element with this class, because that will abort the drag operation.\n   * - dndDraggingSource  This class will be added to the element after the drag operation was\n   *                      started, meaning it only affects the original element that is still at\n   *                      it's source position, and not the \"element\" that the user is dragging with\n   *                      his mouse pointer.\n   */\n  dndLists.directive('dndDraggable', ['$parse', '$timeout', function($parse, $timeout) {\n    return function(scope, element, attr) {\n\n\n      // Set the HTML5 draggable attribute on the element.\n      element.attr(\"draggable\", \"true\");\n\n      // If the dnd-disable-if attribute is set, we have to watch that.\n      if (attr.dndDisableIf) {\n        scope.$watch(attr.dndDisableIf, function(disabled) {\n          element.attr(\"draggable\", !disabled);\n        });\n      }\n\n      /**\n       * When the drag operation is started we have to prepare the dataTransfer object,\n       * which is the primary way we communicate with the target element\n       */\n      element.on('dragstart', function(event) {\n        event = event.originalEvent || event;\n\n        // Check whether the element is draggable, since dragstart might be triggered on a child.\n        if (element.attr('draggable') == 'false') return true;\n\n        // Initialize global state.\n        dndState.isDragging = true;\n        dndState.itemType = attr.dndType && scope.$eval(attr.dndType).toLowerCase();\n\n        // Set the allowed drop effects. See below for special IE handling.\n        dndState.dropEffect = \"none\";\n        dndState.effectAllowed = attr.dndEffectAllowed || ALL_EFFECTS[0];\n        event.dataTransfer.effectAllowed = dndState.effectAllowed;\n\n        // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n        // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n        var item = scope.$eval(attr.dndDraggable);\n        var mimeType = MIME_TYPE + (dndState.itemType ? ('-' + dndState.itemType) : '');\n        try {\n          event.dataTransfer.setData(mimeType, angular.toJson(item));\n        } catch (e) {\n          // Setting a custom MIME type did not work, we are probably in IE or Edge.\n          var data = angular.toJson({item: item, type: dndState.itemType});\n          try {\n            event.dataTransfer.setData(EDGE_MIME_TYPE, data);\n          } catch (e) {\n            // We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n            // does not allow changing the cursor in the dragover event, therefore we have to choose\n            // the one we want to display now by setting effectAllowed.\n            var effectsAllowed = filterEffects(ALL_EFFECTS, dndState.effectAllowed);\n            event.dataTransfer.effectAllowed = effectsAllowed[0];\n            event.dataTransfer.setData(MSIE_MIME_TYPE, data);\n          }\n        }\n\n        // Add CSS classes. See documentation above.\n        element.addClass(\"dndDragging\");\n        $timeout(function() { element.addClass(\"dndDraggingSource\"); }, 0);\n\n        // Try setting a proper drag image if triggered on a dnd-handle (won't work in IE).\n        if (event._dndHandle && event.dataTransfer.setDragImage) {\n          var dragImageElement = element.children('.mgz-element-inner');\n          dragImageElement.css('overflow', 'hidden');\n          dragImageElement.css('outline', 'none');\n          dragImageElement.children('.mgz-element-inner').css('padding', '10px');\n          dragImageElement.children('.mgz-element-controls').hide();\n          event.dataTransfer.setDragImage(dragImageElement[0], 0, 0);\n        }\n\n        // Invoke dragstart callback and prepare extra callback for dropzone.\n        $parse(attr.dndDragstart)(scope, {event: event});\n        if (attr.dndCallback) {\n          var callback = $parse(attr.dndCallback);\n          dndState.callback = function(params) { return callback(scope, params || {}); };\n        }\n\n        event.stopPropagation();\n      });\n\n      /**\n       * The dragend event is triggered when the element was dropped or when the drag\n       * operation was aborted (e.g. hit escape button). Depending on the executed action\n       * we will invoke the callbacks specified with the dnd-moved or dnd-copied attribute.\n       */\n      element.on('dragend', function(event) {\n        event = event.originalEvent || event;\n\n        // Invoke callbacks. Usually we would use event.dataTransfer.dropEffect to determine\n        // the used effect, but Chrome has not implemented that field correctly. On Windows\n        // it always sets it to 'none', while Chrome on Linux sometimes sets it to something\n        // else when it's supposed to send 'none' (drag operation aborted).\n        scope.$apply(function() {\n          var dropEffect = dndState.dropEffect;\n          var cb = {copy: 'dndCopied', link: 'dndLinked', move: 'dndMoved', none: 'dndCanceled'};\n          $parse(attr[cb[dropEffect]])(scope, {event: event});\n          $parse(attr.dndDragend)(scope, {event: event, dropEffect: dropEffect});\n        });\n\n        var dragImageElement = element.children('.mgz-element-inner');\n        dragImageElement.css('overflow', '');\n        dragImageElement.css('outline', '');\n        dragImageElement.children('.mgz-element-inner').css('padding', '');\n        dragImageElement.children('.mgz-element-controls').show();\n\n        // Clean up\n        dndState.isDragging = false;\n        dndState.callback = undefined;\n        element.removeClass(\"dndDragging\");\n        element.removeClass(\"dndDraggingSource\");\n        event.stopPropagation();\n\n        // In IE9 it is possible that the timeout from dragstart triggers after the dragend handler.\n        $timeout(function() { element.removeClass(\"dndDraggingSource\"); }, 0);\n      });\n\n      /**\n       * When the element is clicked we invoke the callback function\n       * specified with the dnd-selected attribute.\n       */\n      element.on('click', function(event) {\n        if (!attr.dndSelected) return;\n\n        event = event.originalEvent || event;\n        scope.$apply(function() {\n          $parse(attr.dndSelected)(scope, {event: event});\n        });\n\n        // Prevent triggering dndSelected in parent elements.\n        event.stopPropagation();\n      });\n\n      /**\n       * Workaround to make element draggable in IE9\n       */\n      element.on('selectstart', function() {\n        if (this.dragDrop) this.dragDrop();\n      });\n    };\n  }]);\n\n  dndLists.directive('dndDraggableParent', ['$parse', '$timeout', function($parse, $timeout) {\n    return function(scope, element, attr) {\n\n\n      // Set the HTML5 draggable attribute on the element.\n      element.attr(\"draggable\", \"true\");\n\n      // If the dnd-disable-if attribute is set, we have to watch that.\n      if (attr.dndDisableIf) {\n        scope.$watch(attr.dndDisableIf, function(disabled) {\n          element.attr(\"draggable\", !disabled);\n        });\n      }\n\n      /**\n       * When the drag operation is started we have to prepare the dataTransfer object,\n       * which is the primary way we communicate with the target element\n       */\n      element.on('dragstart', function(event) {\n        event = event.originalEvent || event;\n\n        // Check whether the element is draggable, since dragstart might be triggered on a child.\n        if (element.attr('draggable') == 'false') return true;\n\n        // Initialize global state.\n        dndState.isDragging = true;\n        dndState.itemType = attr.dndType && scope.$eval(attr.dndType).toLowerCase();\n\n        // Set the allowed drop effects. See below for special IE handling.\n        dndState.dropEffect = \"none\";\n        dndState.effectAllowed = attr.dndEffectAllowed || ALL_EFFECTS[0];\n        event.dataTransfer.effectAllowed = dndState.effectAllowed;\n\n        // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n        // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n        var item     = scope.$eval(attr.dndDraggableParent);\n        var mimeType = MIME_TYPE + (dndState.itemType ? ('-' + dndState.itemType) : '');\n        var parent = angular.element(jQuery('.' + item.id));\n        jQuery('.mgz-element-control-dropdown').addClass('mgz-hidden');\n        jQuery(event.target).parent().parent().css('background', 'transparent');\n        jQuery(event.target).css('border-radius', '5px');\n\n        try {\n          event.dataTransfer.setData(mimeType, angular.toJson(item));\n        } catch (e) {\n          // Setting a custom MIME type did not work, we are probably in IE or Edge.\n          var data = angular.toJson({item: item, type: dndState.itemType});\n          try {\n            event.dataTransfer.setData(EDGE_MIME_TYPE, data);\n          } catch (e) {\n            // We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n            // does not allow changing the cursor in the dragover event, therefore we have to choose\n            // the one we want to display now by setting effectAllowed.\n            var effectsAllowed = filterEffects(ALL_EFFECTS, dndState.effectAllowed);\n            event.dataTransfer.effectAllowed = effectsAllowed[0];\n            event.dataTransfer.setData(MSIE_MIME_TYPE, data);\n          }\n        }\n\n        // Add CSS classes. See documentation above.\n        parent.addClass(\"dndDragging\");\n        $timeout(function() { parent.addClass(\"dndDraggingSource\"); }, 0);\n\n        // Try setting a proper drag image if triggered on a dnd-handle (won't work in IE).\n        if (event._dndHandle && event.dataTransfer.setDragImage) {\n          if (item.type !== 'row') {\n            event.dataTransfer.setDragImage(parent[0], 0, 0);\n          }\n        }\n\n        // Invoke dragstart callback and prepare extra callback for dropzone.\n        $parse(attr.dndDragstart)(scope, {event: event});\n        if (attr.dndCallback) {\n          var callback = $parse(attr.dndCallback);\n          dndState.callback = function(params) { return callback(scope, params || {}); };\n        }\n\n        event.stopPropagation();\n      });\n\n      /**\n       * The dragend event is triggered when the element was dropped or when the drag\n       * operation was aborted (e.g. hit escape button). Depending on the executed action\n       * we will invoke the callbacks specified with the dnd-moved or dnd-copied attribute.\n       */\n      element.on('dragend', function(event) {\n        event = event.originalEvent || event;\n\n        // Invoke callbacks. Usually we would use event.dataTransfer.dropEffect to determine\n        // the used effect, but Chrome has not implemented that field correctly. On Windows\n        // it always sets it to 'none', while Chrome on Linux sometimes sets it to something\n        // else when it's supposed to send 'none' (drag operation aborted).\n        scope.$apply(function() {\n          var dropEffect = dndState.dropEffect;\n          var cb = {copy: 'dndCopied', link: 'dndLinked', move: 'dndMoved', none: 'dndCanceled'};\n          $parse(attr[cb[dropEffect]])(scope, {event: event});\n          $parse(attr.dndDragend)(scope, {event: event, dropEffect: dropEffect});\n        });\n\n        var item   = scope.$eval(attr.dndDraggableParent);\n        var parent = angular.element(jQuery('.' + item.id));\n        jQuery('.mgz-element-control-dropdown').removeClass('mgz-hidden');\n        jQuery(event.target).parent().parent().css('background', '');\n        jQuery(event.target).css('border-radius', '');\n\n        // Clean up\n        dndState.isDragging = false;\n        dndState.callback = undefined;\n        parent.removeClass(\"dndDragging\");\n        parent.removeClass(\"dndDraggingSource\");\n        event.stopPropagation();\n\n        // In IE9 it is possible that the timeout from dragstart triggers after the dragend handler.\n        $timeout(function() { parent.removeClass(\"dndDraggingSource\"); }, 0);\n      });\n\n      /**\n       * When the element is clicked we invoke the callback function\n       * specified with the dnd-selected attribute.\n       */\n      element.on('click', function(event) {\n        if (!attr.dndSelected) return;\n\n        event = event.originalEvent || event;\n        scope.$apply(function() {\n          $parse(attr.dndSelected)(scope, {event: event});\n        });\n\n        // Prevent triggering dndSelected in parent elements.\n        event.stopPropagation();\n      });\n\n      /**\n       * Workaround to make element draggable in IE9\n       */\n      element.on('selectstart', function() {\n        if (this.dragDrop) this.dragDrop();\n      });\n    };\n  }]);\n\n  /**\n   * Use the dnd-list attribute to make your list element a dropzone. Usually you will add a single\n   * li element as child with the ng-repeat directive. If you don't do that, we will not be able to\n   * position the dropped element correctly. If you want your list to be sortable, also add the\n   * dnd-draggable directive to your li element(s).\n   *\n   * Attributes:\n   * - dnd-list             Required attribute. The value has to be the array in which the data of\n   *                        the dropped element should be inserted. The value can be blank if used\n   *                        with a custom dnd-drop handler that always returns true.\n   * - dnd-allowed-types    Optional array of allowed item types. When used, only items that had a\n   *                        matching dnd-type attribute will be dropable. Upper case characters will\n   *                        automatically be converted to lower case.\n   * - dnd-effect-allowed   Optional string expression that limits the drop effects that can be\n   *                        performed in the list. See dnd-effect-allowed on dnd-draggable for more\n   *                        details on allowed options. The default value is all.\n   * - dnd-disable-if       Optional boolean expresssion. When it evaluates to true, no dropping\n   *                        into the list is possible. Note that this also disables rearranging\n   *                        items inside the list.\n   * - dnd-horizontal-list  Optional boolean expresssion. When it evaluates to true, the positioning\n   *                        algorithm will use the left and right halfs of the list items instead of\n   *                        the upper and lower halfs.\n   * - dnd-external-sources Optional boolean expression. When it evaluates to true, the list accepts\n   *                        drops from sources outside of the current browser tab. This allows to\n   *                        drag and drop accross different browser tabs. The only major browser\n   *                        that does not support this is currently Microsoft Edge.\n   *\n   * Callbacks:\n   * - dnd-dragover         Optional expression that is invoked when an element is dragged over the\n   *                        list. If the expression is set, but does not return true, the element is\n   *                        not allowed to be dropped. The following variables will be available:\n   *                        - event: The original dragover event sent by the browser.\n   *                        - index: The position in the list at which the element would be dropped.\n   *                        - type: The dnd-type set on the dnd-draggable, or undefined if non was\n   *                          set. Will be null for drops from external sources in IE and Edge,\n   *                          since we don't know the type in those cases.\n   *                        - dropEffect: One of move, copy or link, see dnd-effect-allowed.\n   *                        - external: Whether the element was dragged from an external source.\n   *                        - callback: If dnd-callback was set on the source element, this is a\n   *                          function reference to the callback. The callback can be invoked with\n   *                          custom variables like this: callback({var1: value1, var2: value2}).\n   *                          The callback will be executed on the scope of the source element. If\n   *                          dnd-external-sources was set and external is true, this callback will\n   *                          not be available.\n   * - dnd-drop             Optional expression that is invoked when an element is dropped on the\n   *                        list. The same variables as for dnd-dragover will be available, with the\n   *                        exception that type is always known and therefore never null. There\n   *                        will also be an item variable, which is the transferred object. The\n   *                        return value determines the further handling of the drop:\n   *                        - falsy: The drop will be canceled and the element won't be inserted.\n   *                        - true: Signalises that the drop is allowed, but the dnd-drop\n   *                          callback already took care of inserting the element.\n   *                        - otherwise: All other return values will be treated as the object to\n   *                          insert into the array. In most cases you want to simply return the\n   *                          item parameter, but there are no restrictions on what you can return.\n   * - dnd-inserted         Optional expression that is invoked after a drop if the element was\n   *                        actually inserted into the list. The same local variables as for\n   *                        dnd-drop will be available. Note that for reorderings inside the same\n   *                        list the old element will still be in the list due to the fact that\n   *                        dnd-moved was not called yet.\n   *\n   * CSS classes:\n   * - dndPlaceholder       When an element is dragged over the list, a new placeholder child\n   *                        element will be added. This element is of type li and has the class\n   *                        dndPlaceholder set. Alternatively, you can define your own placeholder\n   *                        by creating a child element with dndPlaceholder class.\n   * - dndDragover          Will be added to the list while an element is dragged over the list.\n   */\n  dndLists.directive('dndList', ['$parse', '$compile', function($parse, $compile) {\n    return function(scope, element, attr) {\n      // While an element is dragged over the list, this placeholder element is inserted\n      // at the location where the element would be inserted after dropping.\n      var placeholder = getPlaceholderElement();\n      placeholder.remove();\n\n      var placeholderNode = placeholder[0];\n      var listNode = element[0];\n      var listSettings = {};\n\n      if (attr.dndDisableBuilder && scope.$eval(attr.dndDisableBuilder)) return;\n      \n\n      /**\n       * The dragenter event is fired when a dragged element or text selection enters a valid drop\n       * target. According to the spec, we either need to have a dropzone attribute or listen on\n       * dragenter events and call preventDefault(). It should be noted though that no browser seems\n       * to enforce this behaviour.\n       */\n      element.on('dragenter', function (event) {\n        event = event.originalEvent || event;\n\n        // Calculate list properties, so that we don't have to repeat this on every dragover event.\n        var types = attr.dndAllowedTypes && scope.$eval(attr.dndAllowedTypes);\n        listSettings = {\n          allowedTypes: angular.isArray(types) && types.join('|').toLowerCase().split('|'),\n          disabled: attr.dndDisableIf && scope.$eval(attr.dndDisableIf),\n          externalSources: attr.dndExternalSources && scope.$eval(attr.dndExternalSources),\n          horizontal: attr.dndHorizontalList && scope.$eval(attr.dndHorizontalList)\n        };\n\n        var mimeType = getMimeType(event.dataTransfer.types);\n        if (!mimeType || !isDropAllowed(getItemType(mimeType))) return true;\n        event.preventDefault();\n      });\n\n      /**\n       * The dragover event is triggered \"every few hundred milliseconds\" while an element\n       * is being dragged over our list, or over an child element.\n       */\n      element.on('dragover', function(event) {\n        if (angular.element(event.target).hasClass('mgz-builder-dnd-disable')) {\n            return true;\n        }\n        event = event.originalEvent || event;\n\n        // Check whether the drop is allowed and determine mime type.\n        var mimeType = getMimeType(event.dataTransfer.types);\n        var itemType = getItemType(mimeType);\n        if (!mimeType || !isDropAllowed(itemType)) return true;\n\n        // Make sure the placeholder is shown, which is especially important if the list is empty.\n        if (placeholderNode.parentNode != listNode) {\n          element.append(placeholder);\n        }\n\n        if (event.target != listNode) {\n          // Try to find the node direct directly below the list node.\n          var listItemNode = event.target;\n          while (listItemNode.parentNode != listNode && listItemNode.parentNode) {\n            listItemNode = listItemNode.parentNode;\n          }\n\n          if (listItemNode.parentNode == listNode && listItemNode != placeholderNode) {\n            // If the mouse pointer is in the upper half of the list item element,\n            // we position the placeholder before the list item, otherwise after it.\n            var rect = listItemNode.getBoundingClientRect();\n            if (listSettings.horizontal) {\n              var isFirstHalf = event.clientX < rect.left + rect.width / 2;\n            } else {\n              var isFirstHalf = event.clientY < rect.top + rect.height / 2;\n            }\n\n            var _elem = jQuery(listItemNode);\n            if (!_elem.hasClass('mgz-placeholder')) {\n              if(isFirstHalf) {\n                if (!_elem.prev('.mgz-placeholder').length) {\n                  jQuery('.mgz-placeholder').remove();\n                  _elem.before(placeholder);\n                }\n              } else {\n                if (!_elem.next('.mgz-placeholder').length) {\n                  jQuery('.mgz-placeholder').remove();\n                  _elem.after(placeholder);\n                }\n              }\n            }\n          }\n        }\n\n        // In IE we set a fake effectAllowed in dragstart to get the correct cursor, we therefore\n        // ignore the effectAllowed passed in dataTransfer. We must also not access dataTransfer for\n        // drops from external sources, as that throws an exception.\n        var ignoreDataTransfer = mimeType == MSIE_MIME_TYPE;\n        var dropEffect = getDropEffect(event, ignoreDataTransfer);\n        if (dropEffect == 'none') return stopDragover();\n\n        // At this point we invoke the callback, which still can disallow the drop.\n        // We can't do this earlier because we want to pass the index of the placeholder.\n        if (attr.dndDragover && !invokeCallback(attr.dndDragover, event, dropEffect, itemType)) {\n          return stopDragover();\n        }\n\n        // Set dropEffect to modify the cursor shown by the browser, unless we're in IE, where this\n        // is not supported. This must be done after preventDefault in Firefox.\n        event.preventDefault();\n        if (!ignoreDataTransfer) {\n          event.dataTransfer.dropEffect = dropEffect;\n        }\n\n        element.addClass(\"dndDragover\");\n        element.addClass(\"mgz-dndDragover\");\n        element.parent().addClass(\"parent-dndDragover\");\n        event.stopPropagation();\n        return false;\n      });\n\n      /**\n       * When the element is dropped, we use the position of the placeholder element as the\n       * position where we insert the transferred data. This assumes that the list has exactly\n       * one child element per array element.\n       */\n      element.on('drop', function(event) {\n        event = event.originalEvent || event;\n\n        // Check whether the drop is allowed and determine mime type.\n        var mimeType = getMimeType(event.dataTransfer.types);\n        var itemType = getItemType(mimeType);\n        if (!mimeType || !isDropAllowed(itemType)) return true;\n\n        // The default behavior in Firefox is to interpret the dropped element as URL and\n        // forward to it. We want to prevent that even if our drop is aborted.\n        event.preventDefault();\n\n        // Unserialize the data that was serialized in dragstart.\n        try {\n          var data = JSON.parse(event.dataTransfer.getData(mimeType));\n        } catch(e) {\n          return stopDragover();\n        }\n\n        // Drops with invalid types from external sources might not have been filtered out yet.\n        if (mimeType == MSIE_MIME_TYPE || mimeType == EDGE_MIME_TYPE) {\n          itemType = data.type || undefined;\n          data = data.item;\n          if (!isDropAllowed(itemType)) return stopDragover();\n        }\n\n        // Special handling for internal IE drops, see dragover handler.\n        var ignoreDataTransfer = mimeType == MSIE_MIME_TYPE;\n        var dropEffect = getDropEffect(event, ignoreDataTransfer);\n        if (dropEffect == 'none') return stopDragover();\n\n        // Invoke the callback, which can transform the transferredObject and even abort the drop.\n        var index = getPlaceholderIndex();\n        if (attr.dndDrop) {\n          data = invokeCallback(attr.dndDrop, event, dropEffect, itemType, index, data);\n          if (!data) return stopDragover();\n        }\n\n        // The drop is definitely going to happen now, store the dropEffect.\n        dndState.dropEffect = dropEffect;\n        if (!ignoreDataTransfer) {\n          event.dataTransfer.dropEffect = dropEffect;\n        }\n\n        // Insert the object into the array, unless dnd-drop took care of that (returned true).\n        if (data !== true) {\n          scope.$apply(function() {\n            scope.$eval(attr.dndList).splice(index, 0, data);\n          });\n        }\n        invokeCallback(attr.dndInserted, event, dropEffect, itemType, index, data);\n\n        // Clean up\n        stopDragover();\n        event.stopPropagation();\n        return false;\n      });\n\n      /**\n       * We have to remove the placeholder when the element is no longer dragged over our list. The\n       * problem is that the dragleave event is not only fired when the element leaves our list,\n       * but also when it leaves a child element. Therefore, we determine whether the mouse cursor\n       * is still pointing to an element inside the list or not.\n       */\n      element.on('dragleave', function(event) {\n        event = event.originalEvent || event;\n\n        var newTarget = document.elementFromPoint(event.clientX, event.clientY);\n        if (listNode.contains(newTarget) && !event._dndPhShown) {\n          // Signalize to potential parent lists that a placeholder is already shown.\n          event._dndPhShown = true;\n        } else {\n          stopDragover();\n        }\n      });\n\n      /**\n       * Given the types array from the DataTransfer object, returns the first valid mime type.\n       * A type is valid if it starts with MIME_TYPE, or it equals MSIE_MIME_TYPE or EDGE_MIME_TYPE.\n       */\n      function getMimeType(types) {\n        if (!types) return MSIE_MIME_TYPE; // IE 9 workaround.\n        for (var i = 0; i < types.length; i++) {\n          if (types[i] == MSIE_MIME_TYPE || types[i] == EDGE_MIME_TYPE ||\n              types[i].substr(0, MIME_TYPE.length) == MIME_TYPE) {\n            return types[i];\n          }\n        }\n        return null;\n      }\n\n      /**\n       * Determines the type of the item from the dndState, or from the mime type for items from\n       * external sources. Returns undefined if no item type was set and null if the item type could\n       * not be determined.\n       */\n      function getItemType(mimeType) {\n        if (dndState.isDragging) return dndState.itemType || undefined;\n        if (mimeType == MSIE_MIME_TYPE || mimeType == EDGE_MIME_TYPE) return null;\n        return (mimeType && mimeType.substr(MIME_TYPE.length + 1)) || undefined;\n      }\n\n      /**\n       * Checks various conditions that must be fulfilled for a drop to be allowed, including the\n       * dnd-allowed-types attribute. If the item Type is unknown (null), the drop will be allowed.\n       */\n      function isDropAllowed(itemType) {\n        if (listSettings.disabled) return false;\n        if (!listSettings.externalSources && !dndState.isDragging) return false;\n        if (!listSettings.allowedTypes || itemType === null) return true;\n        return itemType && listSettings.allowedTypes.indexOf(itemType) != -1;\n      }\n\n      /**\n       * Determines which drop effect to use for the given event. In Internet Explorer we have to\n       * ignore the effectAllowed field on dataTransfer, since we set a fake value in dragstart.\n       * In those cases we rely on dndState to filter effects. Read the design doc for more details:\n       * https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n       */\n      function getDropEffect(event, ignoreDataTransfer) {\n        var effects = ALL_EFFECTS;\n        if (!ignoreDataTransfer) {\n          effects = filterEffects(effects, event.dataTransfer.effectAllowed);\n        }\n        if (dndState.isDragging) {\n          effects = filterEffects(effects, dndState.effectAllowed);\n        }\n        if (attr.dndEffectAllowed) {\n          effects = filterEffects(effects, attr.dndEffectAllowed);\n        }\n        // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\n        // therefore the following modifier keys will only affect other operating systems.\n        if (!effects.length) {\n          return 'none';\n        } else if (event.ctrlKey && effects.indexOf('copy') != -1) {\n          return 'copy';\n        } else if (event.altKey && effects.indexOf('link') != -1) {\n          return 'link';\n        } else {\n          return effects[0];\n        }\n      }\n\n      /**\n       * Small helper function that cleans up if we aborted a drop.\n       */\n      function stopDragover() {\n        placeholder.remove();\n        element.removeClass(\"dndDragover\");\n        element.removeClass(\"mgz-dndDragover\");\n        element.parent().removeClass(\"parent-dndDragover\");\n        return true;\n      }\n\n      /**\n       * Invokes a callback with some interesting parameters and returns the callbacks return value.\n       */\n      function invokeCallback(expression, event, dropEffect, itemType, index, item) {\n        return $parse(expression)(scope, {\n          callback: dndState.callback,\n          dropEffect: dropEffect,\n          event: event,\n          external: !dndState.isDragging,\n          index: index !== undefined ? index : getPlaceholderIndex(),\n          item: item || undefined,\n          type: itemType\n        });\n      }\n\n      /**\n       * We use the position of the placeholder node to determine at which position of the array the\n       * object needs to be inserted\n       */\n      function getPlaceholderIndex() {\n        return Array.prototype.indexOf.call(listNode.children, placeholderNode);\n      }\n\n      /**\n       * Tries to find a child element that has the dndPlaceholder class set. If none was found, a\n       * new li element is created.\n       */\n      function getPlaceholderElement() {\n        var placeholder;\n        angular.forEach(element.children(), function(childNode) {\n          var child = angular.element(childNode);\n          if (child.hasClass('dndPlaceholder')) {\n            placeholder = child;\n          }\n        });\n        if (!placeholder && scope.element && scope.element.builder && scope.element.builder.is_collection) {\n          var parallaxHtml = '<div class=\"dndPlaceholder mgz-placeholder\" ng-class=\"getPlaceHolderClassess()\"></div>';\n          var placeholderHtml = angular.element($compile(parallaxHtml)(scope));\n          element.append(placeholderHtml);\n          placeholder = element.children('.mgz-placeholder');\n        }\n        return placeholder || angular.element(\"<li class='dndPlaceholder mgz-placeholder'></li>\");\n      }\n    };\n  }]);\n\n  /**\n   * Use the dnd-nodrag attribute inside of dnd-draggable elements to prevent them from starting\n   * drag operations. This is especially useful if you want to use input elements inside of\n   * dnd-draggable elements or create specific handle elements. Note: This directive does not work\n   * in Internet Explorer 9.\n   */\n  dndLists.directive('dndNodrag', function() {\n    return function(scope, element, attr) {\n      // Set as draggable so that we can cancel the events explicitly\n      element.attr(\"draggable\", \"true\");\n\n      /**\n       * Since the element is draggable, the browser's default operation is to drag it on dragstart.\n       * We will prevent that and also stop the event from bubbling up.\n       */\n      element.on('dragstart', function(event) {\n        event = event.originalEvent || event;\n\n        if (!event._dndHandle) {\n          // If a child element already reacted to dragstart and set a dataTransfer object, we will\n          // allow that. For example, this is the case for user selections inside of input elements.\n          if (!(event.dataTransfer.types && event.dataTransfer.types.length)) {\n            event.preventDefault();\n          }\n          event.stopPropagation();\n        }\n      });\n\n      /**\n       * Stop propagation of dragend events, otherwise dnd-moved might be triggered and the element\n       * would be removed.\n       */\n      element.on('dragend', function(event) {\n        event = event.originalEvent || event;\n        if (!event._dndHandle) {\n          event.stopPropagation();\n        }\n      });\n    };\n  });\n\n  /**\n   * Use the dnd-handle directive within a dnd-nodrag element in order to allow dragging with that\n   * element after all. Therefore, by combining dnd-nodrag and dnd-handle you can allow\n   * dnd-draggable elements to only be dragged via specific \"handle\" elements. Note that Internet\n   * Explorer will show the handle element as drag image instead of the dnd-draggable element. You\n   * can work around this by styling the handle element differently when it is being dragged. Use\n   * the CSS selector .dndDragging:not(.dndDraggingSource) [dnd-handle] for that.\n   */\n  dndLists.directive('dndHandle', function() {\n    return function(scope, element, attr) {\n      element.attr(\"draggable\", \"true\");\n\n      element.on('dragstart dragend', function(event) {\n        event = event.originalEvent || event;\n        event._dndHandle = true;\n      });\n    };\n  });\n\n  /**\n   * Filters an array of drop effects using a HTML5 effectAllowed string.\n   */\n  function filterEffects(effects, effectAllowed) {\n    if (effectAllowed == 'all') return effects;\n    return effects.filter(function(effect) {\n      return effectAllowed.toLowerCase().indexOf(effect) != -1;\n    });\n  }\n\n  /**\n   * For some features we need to maintain global state. This is done here, with these fields:\n   * - callback: A callback function set at dragstart that is passed to internal dropzone handlers.\n   * - dropEffect: Set in dragstart to \"none\" and to the actual value in the drop handler. We don't\n   *   rely on the dropEffect passed by the browser, since there are various bugs in Chrome and\n   *   Safari, and Internet Explorer defaults to copy if effectAllowed is copyMove.\n   * - effectAllowed: Set in dragstart based on dnd-effect-allowed. This is needed for IE because\n   *   setting effectAllowed on dataTransfer might result in an undesired cursor.\n   * - isDragging: True between dragstart and dragend. Falsy for drops from external sources.\n   * - itemType: The item type of the dragged element set via dnd-type. This is needed because IE\n   *   and Edge don't support custom mime types that we can use to transfer this information.\n   */\n  var dndState = {};\n\n})(angular.module('dndLists', []));\n","Magezon_Builder/vendor/angular-ui-codemirror/ui-codemirror.js":"define([\n  'jquery',\n  'angular',\n  'mgzcodemirror'\n], function($, angular, CodeMirror) {\n'use strict';\nwindow.mgzCodeMirror = CodeMirror;\n\n/**\n * Binds a CodeMirror widget to a <textarea> element.\n */\nangular.module('ui.codemirror', [])\n  .constant('uiCodemirrorConfig', {})\n  .directive('uiCodemirror', uiCodemirrorDirective);\n\n/**\n * @ngInject\n */\nfunction uiCodemirrorDirective($timeout, uiCodemirrorConfig) {\n\n  return {\n    restrict: 'EA',\n    require: '?ngModel',\n    compile: function compile() {\n\n      // Require CodeMirror\n      if (angular.isUndefined(window.mgzCodeMirror)) {\n        throw new Error('ui-codemirror needs CodeMirror to work... (o rly?)');\n      }\n\n      return postLink;\n    }\n  };\n\n  function postLink(scope, iElement, iAttrs, ngModel) {\n\n    var codemirrorOptions = angular.extend(\n      { value: iElement.text() },\n      uiCodemirrorConfig.codemirror || {},\n      scope.$eval(iAttrs.uiCodemirror),\n      scope.$eval(iAttrs.uiCodemirrorOpts)\n    );\n\n    var codemirror = newCodemirrorEditor(iElement, codemirrorOptions);\n\n    configOptionsWatcher(\n      codemirror,\n      iAttrs.uiCodemirror || iAttrs.uiCodemirrorOpts,\n      scope\n    );\n\n    configNgModelLink(codemirror, ngModel, scope);\n\n    configUiRefreshAttribute(codemirror, iAttrs.uiRefresh, scope);\n\n    // Allow access to the CodeMirror instance through a broadcasted event\n    // eg: $broadcast('CodeMirror', function(cm){...});\n    scope.$on('CodeMirror', function(event, callback) {\n      if (angular.isFunction(callback)) {\n        callback(codemirror);\n      } else {\n        throw new Error('the CodeMirror event requires a callback function');\n      }\n    });\n\n    // onLoad callback\n    if (angular.isFunction(codemirrorOptions.onLoad)) {\n      codemirrorOptions.onLoad(codemirror);\n    }\n  }\n\n  function newCodemirrorEditor(iElement, codemirrorOptions) {\n    var codemirrot;\n\n    if (iElement[0].tagName === 'TEXTAREA') {\n      // Might bug but still ...\n      codemirrot = window.mgzCodeMirror.fromTextArea(iElement[0], codemirrorOptions);\n    } else {\n      iElement.html('');\n      codemirrot = new window.mgzCodeMirror(function(cm_el) {\n        iElement.append(cm_el);\n      }, codemirrorOptions);\n    }\n\n    return codemirrot;\n  }\n\n  function configOptionsWatcher(codemirrot, uiCodemirrorAttr, scope) {\n    if (!uiCodemirrorAttr) { return; }\n\n    var codemirrorDefaultsKeys = Object.keys(window.mgzCodeMirror.defaults);\n    scope.$watch(uiCodemirrorAttr, updateOptions, true);\n    function updateOptions(newValues, oldValue) {\n      if (!angular.isObject(newValues)) { return; }\n      codemirrorDefaultsKeys.forEach(function(key) {\n        if (newValues.hasOwnProperty(key)) {\n\n          if (oldValue && newValues[key] === oldValue[key]) {\n            return;\n          }\n\n          codemirrot.setOption(key, newValues[key]);\n        }\n      });\n    }\n  }\n\n  function configNgModelLink(codemirror, ngModel, scope) {\n    if (!ngModel) { return; }\n    // CodeMirror expects a string, so make sure it gets one.\n    // This does not change the model.\n    ngModel.$formatters.push(function(value) {\n      if (angular.isUndefined(value) || value === null) {\n        return '';\n      } else if (angular.isObject(value) || angular.isArray(value)) {\n        throw new Error('ui-codemirror cannot use an object or an array as a model');\n      }\n      return value;\n    });\n\n\n    // Override the ngModelController $render method, which is what gets called when the model is updated.\n    // This takes care of the synchronizing the codeMirror element with the underlying model, in the case that it is changed by something else.\n    ngModel.$render = function() {\n      //Code mirror expects a string so make sure it gets one\n      //Although the formatter have already done this, it can be possible that another formatter returns undefined (for example the required directive)\n      var safeViewValue = ngModel.$viewValue || '';\n      codemirror.setValue(safeViewValue);\n    };\n\n\n    // Keep the ngModel in sync with changes from CodeMirror\n    codemirror.on('change', function(instance) {\n      var newValue = instance.getValue();\n      if (newValue !== ngModel.$viewValue) {\n        scope.$evalAsync(function() {\n          ngModel.$setViewValue(newValue);\n        });\n      }\n    });\n  }\n\n  function configUiRefreshAttribute(codeMirror, uiRefreshAttr, scope) {\n    if (!uiRefreshAttr) { return; }\n\n    scope.$watch(uiRefreshAttr, function(newVal, oldVal) {\n      // Skip the initial watch firing\n      if (newVal !== oldVal) {\n        $timeout(function() {\n          codeMirror.refresh();\n        });\n      }\n    });\n  }\n\n}\nuiCodemirrorDirective.$inject = [\"$timeout\", \"uiCodemirrorConfig\"];\n\n});","Magezon_Builder/vendor/fotorama/fotorama.js":"/*!\n * Fotorama 4.6.4 | http://fotorama.io/license/\n */\nfotoramaVersion=\"4.6.4\",function(a,b,c,d,e){\"use strict\";function f(a){var b=\"bez_\"+d.makeArray(arguments).join(\"_\").replace(\".\",\"p\");if(\"function\"!=typeof d.easing[b]){var c=function(a,b){var c=[null,null],d=[null,null],e=[null,null],f=function(f,g){return e[g]=3*a[g],d[g]=3*(b[g]-a[g])-e[g],c[g]=1-e[g]-d[g],f*(e[g]+f*(d[g]+f*c[g]))},g=function(a){return e[0]+a*(2*d[0]+3*c[0]*a)},h=function(a){for(var b,c=a,d=0;++d<14&&(b=f(c,0)-a,!(Math.abs(b)<.001));)c-=b/g(c);return c};return function(a){return f(h(a),1)}};d.easing[b]=function(b,d,e,f,g){return f*c([a[0],a[1]],[a[2],a[3]])(d/g)+e}}return b}function g(){}function h(a,b,c){return Math.max(isNaN(b)?-1/0:b,Math.min(isNaN(c)?1/0:c,a))}function i(a){return a.match(/ma/)&&a.match(/-?\\d+(?!d)/g)[a.match(/3d/)?12:4]}function j(a){return Ic?+i(a.css(\"transform\")):+a.css(\"left\").replace(\"px\",\"\")}function k(a){var b={};return Ic?b.transform=\"translate3d(\"+a+\"px,0,0)\":b.left=a,b}function l(a){return{\"transition-duration\":a+\"ms\"}}function m(a,b){return isNaN(a)?b:a}function n(a,b){return m(+String(a).replace(b||\"px\",\"\"))}function o(a){return/%$/.test(a)?n(a,\"%\"):e}function p(a,b){return m(o(a)/100*b,n(a))}function q(a){return(!isNaN(n(a))||!isNaN(n(a,\"%\")))&&a}function r(a,b,c,d){return(a-(d||0))*(b+(c||0))}function s(a,b,c,d){return-Math.round(a/(b+(c||0))-(d||0))}function t(a){var b=a.data();if(!b.tEnd){var c=a[0],d={WebkitTransition:\"webkitTransitionEnd\",MozTransition:\"transitionend\",OTransition:\"oTransitionEnd otransitionend\",msTransition:\"MSTransitionEnd\",transition:\"transitionend\"};T(c,d[uc.prefixed(\"transition\")],function(a){b.tProp&&a.propertyName.match(b.tProp)&&b.onEndFn()}),b.tEnd=!0}}function u(a,b,c,d){var e,f=a.data();f&&(f.onEndFn=function(){e||(e=!0,clearTimeout(f.tT),c())},f.tProp=b,clearTimeout(f.tT),f.tT=setTimeout(function(){f.onEndFn()},1.5*d),t(a))}function v(a,b){if(a.length){var c=a.data();Ic?(a.css(l(0)),c.onEndFn=g,clearTimeout(c.tT)):a.stop();var d=w(b,function(){return j(a)});return a.css(k(d)),d}}function w(){for(var a,b=0,c=arguments.length;c>b&&(a=b?arguments[b]():arguments[b],\"number\"!=typeof a);b++);return a}function x(a,b){return Math.round(a+(b-a)/1.5)}function y(){return y.p=y.p||(\"https:\"===c.protocol?\"https://\":\"http://\"),y.p}function z(a){var c=b.createElement(\"a\");return c.href=a,c}function A(a,b){if(\"string\"!=typeof a)return a;a=z(a);var c,d;if(a.host.match(/youtube\\.com/)&&a.search){if(c=a.search.split(\"v=\")[1]){var e=c.indexOf(\"&\");-1!==e&&(c=c.substring(0,e)),d=\"youtube\"}}else a.host.match(/youtube\\.com|youtu\\.be/)?(c=a.pathname.replace(/^\\/(embed\\/|v\\/)?/,\"\").replace(/\\/.*/,\"\"),d=\"youtube\"):a.host.match(/vimeo\\.com/)&&(d=\"vimeo\",c=a.pathname.replace(/^\\/(video\\/)?/,\"\").replace(/\\/.*/,\"\"));return c&&d||!b||(c=a.href,d=\"custom\"),c?{id:c,type:d,s:a.search.replace(/^\\?/,\"\"),p:y()}:!1}function B(a,b,c){var e,f,g=a.video;return\"youtube\"===g.type?(f=y()+\"img.youtube.com/vi/\"+g.id+\"/default.jpg\",e=f.replace(/\\/default.jpg$/,\"/hqdefault.jpg\"),a.thumbsReady=!0):\"vimeo\"===g.type?d.ajax({url:y()+\"vimeo.com/api/v2/video/\"+g.id+\".json\",dataType:\"jsonp\",success:function(d){a.thumbsReady=!0,C(b,{img:d[0].thumbnail_large,thumb:d[0].thumbnail_small},a.i,c)}}):a.thumbsReady=!0,{img:e,thumb:f}}function C(a,b,c,e){for(var f=0,g=a.length;g>f;f++){var h=a[f];if(h.i===c&&h.thumbsReady){var i={videoReady:!0};i[Xc]=i[Zc]=i[Yc]=!1,e.splice(f,1,d.extend({},h,i,b));break}}}function D(a){function b(a,b,e){var f=a.children(\"img\").eq(0),g=a.attr(\"href\"),h=a.attr(\"src\"),i=f.attr(\"src\"),j=b.video,k=e?A(g,j===!0):!1;k?g=!1:k=j,c(a,f,d.extend(b,{video:k,img:b.img||g||h||i,thumb:b.thumb||i||h||g}))}function c(a,b,c){var e=c.thumb&&c.img!==c.thumb,f=n(c.width||a.attr(\"width\")),g=n(c.height||a.attr(\"height\"));d.extend(c,{width:f,height:g,thumbratio:S(c.thumbratio||n(c.thumbwidth||b&&b.attr(\"width\")||e||f)/n(c.thumbheight||b&&b.attr(\"height\")||e||g))})}var e=[];return a.children().each(function(){var a=d(this),f=R(d.extend(a.data(),{id:a.attr(\"id\")}));if(a.is(\"a, img\"))b(a,f,!0);else{if(a.is(\":empty\"))return;c(a,null,d.extend(f,{html:this,_html:a.html()}))}e.push(f)}),e}function E(a){return 0===a.offsetWidth&&0===a.offsetHeight}function F(a){return!d.contains(b.documentElement,a)}function G(a,b,c,d){return G.i||(G.i=1,G.ii=[!0]),d=d||G.i,\"undefined\"==typeof G.ii[d]&&(G.ii[d]=!0),a()?b():G.ii[d]&&setTimeout(function(){G.ii[d]&&G(a,b,c,d)},c||100),G.i++}function H(a){c.replace(c.protocol+\"//\"+c.host+c.pathname.replace(/^\\/?/,\"/\")+c.search+\"#\"+a)}function I(a,b,c,d){var e=a.data(),f=e.measures;if(f&&(!e.l||e.l.W!==f.width||e.l.H!==f.height||e.l.r!==f.ratio||e.l.w!==b.w||e.l.h!==b.h||e.l.m!==c||e.l.p!==d)){var g=f.width,i=f.height,j=b.w/b.h,k=f.ratio>=j,l=\"scaledown\"===c,m=\"contain\"===c,n=\"cover\"===c,o=$(d);k&&(l||m)||!k&&n?(g=h(b.w,0,l?g:1/0),i=g/f.ratio):(k&&n||!k&&(l||m))&&(i=h(b.h,0,l?i:1/0),g=i*f.ratio),a.css({width:g,height:i,left:p(o.x,b.w-g),top:p(o.y,b.h-i)}),e.l={W:f.width,H:f.height,r:f.ratio,w:b.w,h:b.h,m:c,p:d}}return!0}function J(a,b){var c=a[0];c.styleSheet?c.styleSheet.cssText=b:a.html(b)}function K(a,b,c){return b===c?!1:b>=a?\"left\":a>=c?\"right\":\"left right\"}function L(a,b,c,d){if(!c)return!1;if(!isNaN(a))return a-(d?0:1);for(var e,f=0,g=b.length;g>f;f++){var h=b[f];if(h.id===a){e=f;break}}return e}function M(a,b,c){c=c||{},a.each(function(){var a,e=d(this),f=e.data();f.clickOn||(f.clickOn=!0,d.extend(cb(e,{onStart:function(b){a=b,(c.onStart||g).call(this,b)},onMove:c.onMove||g,onTouchEnd:c.onTouchEnd||g,onEnd:function(c){c.moved||b.call(this,a)}}),{noMove:!0}))})}function N(a,b){return'<div class=\"'+a+'\">'+(b||\"\")+\"</div>\"}function O(a){for(var b=a.length;b;){var c=Math.floor(Math.random()*b--),d=a[b];a[b]=a[c],a[c]=d}return a}function P(a){return\"[object Array]\"==Object.prototype.toString.call(a)&&d.map(a,function(a){return d.extend({},a)})}function Q(a,b,c){a.scrollLeft(b||0).scrollTop(c||0)}function R(a){if(a){var b={};return d.each(a,function(a,c){b[a.toLowerCase()]=c}),b}}function S(a){if(a){var b=+a;return isNaN(b)?(b=a.split(\"/\"),+b[0]/+b[1]||e):b}}function T(a,b,c,d){b&&(a.addEventListener?a.addEventListener(b,c,!!d):a.attachEvent(\"on\"+b,c))}function U(a){return!!a.getAttribute(\"disabled\")}function V(a){return{tabindex:-1*a+\"\",disabled:a}}function W(a,b){T(a,\"keyup\",function(c){U(a)||13==c.keyCode&&b.call(a,c)})}function X(a,b){T(a,\"focus\",a.onfocusin=function(c){b.call(a,c)},!0)}function Y(a,b){a.preventDefault?a.preventDefault():a.returnValue=!1,b&&a.stopPropagation&&a.stopPropagation()}function Z(a){return a?\">\":\"<\"}function $(a){return a=(a+\"\").split(/\\s+/),{x:q(a[0])||bd,y:q(a[1])||bd}}function _(a,b){var c=a.data(),e=Math.round(b.pos),f=function(){c.sliding=!1,(b.onEnd||g)()};\"undefined\"!=typeof b.overPos&&b.overPos!==b.pos&&(e=b.overPos,f=function(){_(a,d.extend({},b,{overPos:b.pos,time:Math.max(Qc,b.time/2)}))});var h=d.extend(k(e),b.width&&{width:b.width});c.sliding=!0,Ic?(a.css(d.extend(l(b.time),h)),b.time>10?u(a,\"transform\",f,b.time):f()):a.stop().animate(h,b.time,_c,f)}function ab(a,b,c,e,f,h){var i=\"undefined\"!=typeof h;if(i||(f.push(arguments),Array.prototype.push.call(arguments,f.length),!(f.length>1))){a=a||d(a),b=b||d(b);var j=a[0],k=b[0],l=\"crossfade\"===e.method,m=function(){if(!m.done){m.done=!0;var a=(i||f.shift())&&f.shift();a&&ab.apply(this,a),(e.onEnd||g)(!!a)}},n=e.time/(h||1);c.removeClass(Rb+\" \"+Qb),a.stop().addClass(Rb),b.stop().addClass(Qb),l&&k&&a.fadeTo(0,0),a.fadeTo(l?n:0,1,l&&m),b.fadeTo(n,0,m),j&&l||k||m()}}function bb(a){var b=(a.touches||[])[0]||a;a._x=b.pageX,a._y=b.clientY,a._now=d.now()}function cb(a,c){function e(a){return m=d(a.target),u.checked=p=q=s=!1,k||u.flow||a.touches&&a.touches.length>1||a.which>1||ed&&ed.type!==a.type&&gd||(p=c.select&&m.is(c.select,t))?p:(o=\"touchstart\"===a.type,q=m.is(\"a, a *\",t),n=u.control,r=u.noMove||u.noSwipe||n?16:u.snap?0:4,bb(a),l=ed=a,fd=a.type.replace(/down|start/,\"move\").replace(/Down/,\"Move\"),(c.onStart||g).call(t,a,{control:n,$target:m}),k=u.flow=!0,void((!o||u.go)&&Y(a)))}function f(a){if(a.touches&&a.touches.length>1||Nc&&!a.isPrimary||fd!==a.type||!k)return k&&h(),void(c.onTouchEnd||g)();bb(a);var b=Math.abs(a._x-l._x),d=Math.abs(a._y-l._y),e=b-d,f=(u.go||u.x||e>=0)&&!u.noSwipe,i=0>e;o&&!u.checked?(k=f)&&Y(a):(Y(a),(c.onMove||g).call(t,a,{touch:o})),!s&&Math.sqrt(Math.pow(b,2)+Math.pow(d,2))>r&&(s=!0),u.checked=u.checked||f||i}function h(a){(c.onTouchEnd||g)();var b=k;u.control=k=!1,b&&(u.flow=!1),!b||q&&!u.checked||(a&&Y(a),gd=!0,clearTimeout(hd),hd=setTimeout(function(){gd=!1},1e3),(c.onEnd||g).call(t,{moved:s,$target:m,control:n,touch:o,startEvent:l,aborted:!a||\"MSPointerCancel\"===a.type}))}function i(){u.flow||setTimeout(function(){u.flow=!0},10)}function j(){u.flow&&setTimeout(function(){u.flow=!1},Pc)}var k,l,m,n,o,p,q,r,s,t=a[0],u={};return Nc?(T(t,\"MSPointerDown\",e),T(b,\"MSPointerMove\",f),T(b,\"MSPointerCancel\",h),T(b,\"MSPointerUp\",h)):(T(t,\"touchstart\",e),T(t,\"touchmove\",f),T(t,\"touchend\",h),T(b,\"touchstart\",i),T(b,\"touchend\",j),T(b,\"touchcancel\",j),Ec.on(\"scroll\",j),a.on(\"mousedown\",e),Fc.on(\"mousemove\",f).on(\"mouseup\",h)),a.on(\"click\",\"a\",function(a){u.checked&&Y(a)}),u}function db(a,b){function c(c,d){A=!0,j=l=c._x,q=c._now,p=[[q,j]],m=n=D.noMove||d?0:v(a,(b.getPos||g)()),(b.onStart||g).call(B,c)}function e(a,b){s=D.min,t=D.max,u=D.snap,w=a.altKey,A=z=!1,y=b.control,y||C.sliding||c(a)}function f(d,e){D.noSwipe||(A||c(d),l=d._x,p.push([d._now,l]),n=m-(j-l),o=K(n,s,t),s>=n?n=x(n,s):n>=t&&(n=x(n,t)),D.noMove||(a.css(k(n)),z||(z=!0,e.touch||Nc||a.addClass(ec)),(b.onMove||g).call(B,d,{pos:n,edge:o})))}function i(e){if(!D.noSwipe||!e.moved){A||c(e.startEvent,!0),e.touch||Nc||a.removeClass(ec),r=d.now();for(var f,i,j,k,o,q,v,x,y,z=r-Pc,C=null,E=Qc,F=b.friction,G=p.length-1;G>=0;G--){if(f=p[G][0],i=Math.abs(f-z),null===C||j>i)C=f,k=p[G][1];else if(C===z||i>j)break;j=i}v=h(n,s,t);var H=k-l,I=H>=0,J=r-C,K=J>Pc,L=!K&&n!==m&&v===n;u&&(v=h(Math[L?I?\"floor\":\"ceil\":\"round\"](n/u)*u,s,t),s=t=v),L&&(u||v===n)&&(y=-(H/J),E*=h(Math.abs(y),b.timeLow,b.timeHigh),o=Math.round(n+y*E/F),u||(v=o),(!I&&o>t||I&&s>o)&&(q=I?s:t,x=o-q,u||(v=q),x=h(v+.03*x,q-50,q+50),E=Math.abs((n-x)/(y/F)))),E*=w?10:1,(b.onEnd||g).call(B,d.extend(e,{moved:e.moved||K&&u,pos:n,newPos:v,overPos:x,time:E}))}}var j,l,m,n,o,p,q,r,s,t,u,w,y,z,A,B=a[0],C=a.data(),D={};return D=d.extend(cb(b.$wrap,d.extend({},b,{onStart:e,onMove:f,onEnd:i})),D)}function eb(a,b){var c,e,f,h=a[0],i={prevent:{}};return T(h,Oc,function(a){var h=a.wheelDeltaY||-1*a.deltaY||0,j=a.wheelDeltaX||-1*a.deltaX||0,k=Math.abs(j)&&!Math.abs(h),l=Z(0>j),m=e===l,n=d.now(),o=Pc>n-f;e=l,f=n,k&&i.ok&&(!i.prevent[l]||c)&&(Y(a,!0),c&&m&&o||(b.shift&&(c=!0,clearTimeout(i.t),i.t=setTimeout(function(){c=!1},Rc)),(b.onEnd||g)(a,b.shift?l:j)))}),i}function fb(){d.each(d.Fotorama.instances,function(a,b){b.index=a})}function gb(a){d.Fotorama.instances.push(a),fb()}function hb(a){d.Fotorama.instances.splice(a.index,1),fb()}var ib=\"fotorama\",jb=\"fullscreen\",kb=ib+\"__wrap\",lb=kb+\"--css2\",mb=kb+\"--css3\",nb=kb+\"--video\",ob=kb+\"--fade\",pb=kb+\"--slide\",qb=kb+\"--no-controls\",rb=kb+\"--no-shadows\",sb=kb+\"--pan-y\",tb=kb+\"--rtl\",ub=kb+\"--only-active\",vb=kb+\"--no-captions\",wb=kb+\"--toggle-arrows\",xb=ib+\"__stage\",yb=xb+\"__frame\",zb=yb+\"--video\",Ab=xb+\"__shaft\",Bb=ib+\"__grab\",Cb=ib+\"__pointer\",Db=ib+\"__arr\",Eb=Db+\"--disabled\",Fb=Db+\"--prev\",Gb=Db+\"--next\",Hb=ib+\"__nav\",Ib=Hb+\"-wrap\",Jb=Hb+\"__shaft\",Kb=Hb+\"--dots\",Lb=Hb+\"--thumbs\",Mb=Hb+\"__frame\",Nb=Mb+\"--dot\",Ob=Mb+\"--thumb\",Pb=ib+\"__fade\",Qb=Pb+\"-front\",Rb=Pb+\"-rear\",Sb=ib+\"__shadow\",Tb=Sb+\"s\",Ub=Tb+\"--left\",Vb=Tb+\"--right\",Wb=ib+\"__active\",Xb=ib+\"__select\",Yb=ib+\"--hidden\",Zb=ib+\"--fullscreen\",$b=ib+\"__fullscreen-icon\",_b=ib+\"__error\",ac=ib+\"__loading\",bc=ib+\"__loaded\",cc=bc+\"--full\",dc=bc+\"--img\",ec=ib+\"__grabbing\",fc=ib+\"__img\",gc=fc+\"--full\",hc=ib+\"__dot\",ic=ib+\"__thumb\",jc=ic+\"-border\",kc=ib+\"__html\",lc=ib+\"__video\",mc=lc+\"-play\",nc=lc+\"-close\",oc=ib+\"__caption\",pc=ib+\"__caption__wrap\",qc=ib+\"__spinner\",rc='\" tabindex=\"0\" role=\"button',sc=d&&d.fn.jquery.split(\".\");if(!sc||sc[0]<1||1==sc[0]&&sc[1]<8)throw\"Fotorama requires jQuery 1.8 or later and will not run without it.\";var tc={},uc=function(a,b,c){function d(a){r.cssText=a}function e(a,b){return typeof a===b}function f(a,b){return!!~(\"\"+a).indexOf(b)}function g(a,b){for(var d in a){var e=a[d];if(!f(e,\"-\")&&r[e]!==c)return\"pfx\"==b?e:!0}return!1}function h(a,b,d){for(var f in a){var g=b[a[f]];if(g!==c)return d===!1?a[f]:e(g,\"function\")?g.bind(d||b):g}return!1}function i(a,b,c){var d=a.charAt(0).toUpperCase()+a.slice(1),f=(a+\" \"+u.join(d+\" \")+d).split(\" \");return e(b,\"string\")||e(b,\"undefined\")?g(f,b):(f=(a+\" \"+v.join(d+\" \")+d).split(\" \"),h(f,b,c))}var j,k,l,m=\"2.6.2\",n={},o=b.documentElement,p=\"modernizr\",q=b.createElement(p),r=q.style,s=({}.toString,\" -webkit- -moz- -o- -ms- \".split(\" \")),t=\"Webkit Moz O ms\",u=t.split(\" \"),v=t.toLowerCase().split(\" \"),w={},x=[],y=x.slice,z=function(a,c,d,e){var f,g,h,i,j=b.createElement(\"div\"),k=b.body,l=k||b.createElement(\"body\");if(parseInt(d,10))for(;d--;)h=b.createElement(\"div\"),h.id=e?e[d]:p+(d+1),j.appendChild(h);return f=[\"&#173;\",'<style id=\"s',p,'\">',a,\"</style>\"].join(\"\"),j.id=p,(k?j:l).innerHTML+=f,l.appendChild(j),k||(l.style.background=\"\",l.style.overflow=\"hidden\",i=o.style.overflow,o.style.overflow=\"hidden\",o.appendChild(l)),g=c(j,a),k?j.parentNode.removeChild(j):(l.parentNode.removeChild(l),o.style.overflow=i),!!g},A={}.hasOwnProperty;l=e(A,\"undefined\")||e(A.call,\"undefined\")?function(a,b){return b in a&&e(a.constructor.prototype[b],\"undefined\")}:function(a,b){return A.call(a,b)},Function.prototype.bind||(Function.prototype.bind=function(a){var b=this;if(\"function\"!=typeof b)throw new TypeError;var c=y.call(arguments,1),d=function(){if(this instanceof d){var e=function(){};e.prototype=b.prototype;var f=new e,g=b.apply(f,c.concat(y.call(arguments)));return Object(g)===g?g:f}return b.apply(a,c.concat(y.call(arguments)))};return d}),w.csstransforms3d=function(){var a=!!i(\"perspective\");return a};for(var B in w)l(w,B)&&(k=B.toLowerCase(),n[k]=w[B](),x.push((n[k]?\"\":\"no-\")+k));return n.addTest=function(a,b){if(\"object\"==typeof a)for(var d in a)l(a,d)&&n.addTest(d,a[d]);else{if(a=a.toLowerCase(),n[a]!==c)return n;b=\"function\"==typeof b?b():b,\"undefined\"!=typeof enableClasses&&enableClasses&&(o.className+=\" \"+(b?\"\":\"no-\")+a),n[a]=b}return n},d(\"\"),q=j=null,n._version=m,n._prefixes=s,n._domPrefixes=v,n._cssomPrefixes=u,n.testProp=function(a){return g([a])},n.testAllProps=i,n.testStyles=z,n.prefixed=function(a,b,c){return b?i(a,b,c):i(a,\"pfx\")},n}(a,b),vc={ok:!1,is:function(){return!1},request:function(){},cancel:function(){},event:\"\",prefix:\"\"},wc=\"webkit moz o ms khtml\".split(\" \");if(\"undefined\"!=typeof b.cancelFullScreen)vc.ok=!0;else for(var xc=0,yc=wc.length;yc>xc;xc++)if(vc.prefix=wc[xc],\"undefined\"!=typeof b[vc.prefix+\"CancelFullScreen\"]){vc.ok=!0;break}vc.ok&&(vc.event=vc.prefix+\"fullscreenchange\",vc.is=function(){switch(this.prefix){case\"\":return b.fullScreen;case\"webkit\":return b.webkitIsFullScreen;default:return b[this.prefix+\"FullScreen\"]}},vc.request=function(a){return\"\"===this.prefix?a.requestFullScreen():a[this.prefix+\"RequestFullScreen\"]()},vc.cancel=function(){return\"\"===this.prefix?b.cancelFullScreen():b[this.prefix+\"CancelFullScreen\"]()});var zc,Ac={lines:12,length:5,width:2,radius:7,corners:1,rotate:15,color:\"rgba(128, 128, 128, .75)\",hwaccel:!0},Bc={top:\"auto\",left:\"auto\",className:\"\"};!function(a,b){zc=b()}(this,function(){function a(a,c){var d,e=b.createElement(a||\"div\");for(d in c)e[d]=c[d];return e}function c(a){for(var b=1,c=arguments.length;c>b;b++)a.appendChild(arguments[b]);return a}function d(a,b,c,d){var e=[\"opacity\",b,~~(100*a),c,d].join(\"-\"),f=.01+c/d*100,g=Math.max(1-(1-a)/b*(100-f),a),h=m.substring(0,m.indexOf(\"Animation\")).toLowerCase(),i=h&&\"-\"+h+\"-\"||\"\";return o[e]||(p.insertRule(\"@\"+i+\"keyframes \"+e+\"{0%{opacity:\"+g+\"}\"+f+\"%{opacity:\"+a+\"}\"+(f+.01)+\"%{opacity:1}\"+(f+b)%100+\"%{opacity:\"+a+\"}100%{opacity:\"+g+\"}}\",p.cssRules.length),o[e]=1),e}function f(a,b){var c,d,f=a.style;for(b=b.charAt(0).toUpperCase()+b.slice(1),d=0;d<n.length;d++)if(c=n[d]+b,f[c]!==e)return c;return f[b]!==e?b:void 0}function g(a,b){for(var c in b)a.style[f(a,c)||c]=b[c];return a}function h(a){for(var b=1;b<arguments.length;b++){var c=arguments[b];for(var d in c)a[d]===e&&(a[d]=c[d])}return a}function i(a){for(var b={x:a.offsetLeft,y:a.offsetTop};a=a.offsetParent;)b.x+=a.offsetLeft,b.y+=a.offsetTop;return b}function j(a,b){return\"string\"==typeof a?a:a[b%a.length]}function k(a){return\"undefined\"==typeof this?new k(a):void(this.opts=h(a||{},k.defaults,q))}function l(){function b(b,c){return a(\"<\"+b+' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"spin-vml\">',c)}p.addRule(\".spin-vml\",\"behavior:url(#default#VML)\"),k.prototype.lines=function(a,d){function e(){return g(b(\"group\",{coordsize:k+\" \"+k,coordorigin:-i+\" \"+-i}),{width:k,height:k})}function f(a,f,h){c(m,c(g(e(),{rotation:360/d.lines*a+\"deg\",left:~~f}),c(g(b(\"roundrect\",{arcsize:d.corners}),{width:i,height:d.width,left:d.radius,top:-d.width>>1,filter:h}),b(\"fill\",{color:j(d.color,a),opacity:d.opacity}),b(\"stroke\",{opacity:0}))))}var h,i=d.length+d.width,k=2*i,l=2*-(d.width+d.length)+\"px\",m=g(e(),{position:\"absolute\",top:l,left:l});if(d.shadow)for(h=1;h<=d.lines;h++)f(h,-2,\"progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)\");for(h=1;h<=d.lines;h++)f(h);return c(a,m)},k.prototype.opacity=function(a,b,c,d){var e=a.firstChild;d=d.shadow&&d.lines||0,e&&b+d<e.childNodes.length&&(e=e.childNodes[b+d],e=e&&e.firstChild,e=e&&e.firstChild,e&&(e.opacity=c))}}var m,n=[\"webkit\",\"Moz\",\"ms\",\"O\"],o={},p=function(){var d=a(\"style\",{type:\"text/css\"});return c(b.getElementsByTagName(\"head\")[0],d),d.sheet||d.styleSheet}(),q={lines:12,length:7,width:5,radius:10,rotate:0,corners:1,color:\"#000\",direction:1,speed:1,trail:100,opacity:.25,fps:20,zIndex:2e9,className:\"spinner\",top:\"auto\",left:\"auto\",position:\"relative\"};k.defaults={},h(k.prototype,{spin:function(b){this.stop();var c,d,e=this,f=e.opts,h=e.el=g(a(0,{className:f.className}),{position:f.position,width:0,zIndex:f.zIndex}),j=f.radius+f.length+f.width;if(b&&(b.insertBefore(h,b.firstChild||null),d=i(b),c=i(h),g(h,{left:(\"auto\"==f.left?d.x-c.x+(b.offsetWidth>>1):parseInt(f.left,10)+j)+\"px\",top:(\"auto\"==f.top?d.y-c.y+(b.offsetHeight>>1):parseInt(f.top,10)+j)+\"px\"})),h.setAttribute(\"role\",\"progressbar\"),e.lines(h,e.opts),!m){var k,l=0,n=(f.lines-1)*(1-f.direction)/2,o=f.fps,p=o/f.speed,q=(1-f.opacity)/(p*f.trail/100),r=p/f.lines;!function s(){l++;for(var a=0;a<f.lines;a++)k=Math.max(1-(l+(f.lines-a)*r)%p*q,f.opacity),e.opacity(h,a*f.direction+n,k,f);e.timeout=e.el&&setTimeout(s,~~(1e3/o))}()}return e},stop:function(){var a=this.el;return a&&(clearTimeout(this.timeout),a.parentNode&&a.parentNode.removeChild(a),this.el=e),this},lines:function(b,e){function f(b,c){return g(a(),{position:\"absolute\",width:e.length+e.width+\"px\",height:e.width+\"px\",background:b,boxShadow:c,transformOrigin:\"left\",transform:\"rotate(\"+~~(360/e.lines*i+e.rotate)+\"deg) translate(\"+e.radius+\"px,0)\",borderRadius:(e.corners*e.width>>1)+\"px\"})}for(var h,i=0,k=(e.lines-1)*(1-e.direction)/2;i<e.lines;i++)h=g(a(),{position:\"absolute\",top:1+~(e.width/2)+\"px\",transform:e.hwaccel?\"translate3d(0,0,0)\":\"\",opacity:e.opacity,animation:m&&d(e.opacity,e.trail,k+i*e.direction,e.lines)+\" \"+1/e.speed+\"s linear infinite\"}),e.shadow&&c(h,g(f(\"#000\",\"0 0 4px #000\"),{top:\"2px\"})),c(b,c(h,f(j(e.color,i),\"0 0 1px rgba(0,0,0,.1)\")));return b},opacity:function(a,b,c){b<a.childNodes.length&&(a.childNodes[b].style.opacity=c)}});var r=g(a(\"group\"),{behavior:\"url(#default#VML)\"});return!f(r,\"transform\")&&r.adj?l():m=f(r,\"animation\"),k});var Cc,Dc,Ec=d(a),Fc=d(b),Gc=\"quirks\"===c.hash.replace(\"#\",\"\"),Hc=uc.csstransforms3d,Ic=Hc&&!Gc,Jc=Hc||\"CSS1Compat\"===b.compatMode,Kc=vc.ok,Lc=navigator.userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone/i),Mc=!Ic||Lc,Nc=navigator.msPointerEnabled,Oc=\"onwheel\"in b.createElement(\"div\")?\"wheel\":b.onmousewheel!==e?\"mousewheel\":\"DOMMouseScroll\",Pc=250,Qc=300,Rc=1400,Sc=5e3,Tc=2,Uc=64,Vc=500,Wc=333,Xc=\"$stageFrame\",Yc=\"$navDotFrame\",Zc=\"$navThumbFrame\",$c=\"auto\",_c=f([.1,0,.25,1]),ad=99999,bd=\"50%\",cd={width:null,minwidth:null,maxwidth:\"100%\",height:null,minheight:null,maxheight:null,ratio:null,margin:Tc,glimpse:0,fit:\"contain\",position:bd,thumbposition:bd,nav:\"dots\",navposition:\"bottom\",navwidth:null,thumbwidth:Uc,thumbheight:Uc,thumbmargin:Tc,thumbborderwidth:Tc,thumbfit:\"cover\",allowfullscreen:!1,transition:\"slide\",clicktransition:null,transitionduration:Qc,captions:!0,hash:!1,startindex:0,loop:!1,autoplay:!1,stopautoplayontouch:!0,keyboard:!1,arrows:!0,click:!0,swipe:!0,trackpad:!1,enableifsingleframe:!1,controlsonstart:!0,shuffle:!1,direction:\"ltr\",shadows:!0,spinner:null},dd={left:!0,right:!0,down:!1,up:!1,space:!1,home:!1,end:!1};G.stop=function(a){G.ii[a]=!1};var ed,fd,gd,hd;jQuery.Fotorama=function(a,e){function f(){d.each(yd,function(a,b){if(!b.i){b.i=me++;var c=A(b.video,!0);if(c){var d={};b.video=c,b.img||b.thumb?b.thumbsReady=!0:d=B(b,yd,ie),C(yd,{img:d.img,thumb:d.thumb},b.i,ie)}}})}function g(a){return Zd[a]||ie.fullScreen}function i(a){var b=\"keydown.\"+ib,c=ib+je,d=\"keydown.\"+c,f=\"resize.\"+c+\" orientationchange.\"+c;a?(Fc.on(d,function(a){var b,c;Cd&&27===a.keyCode?(b=!0,md(Cd,!0,!0)):(ie.fullScreen||e.keyboard&&!ie.index)&&(27===a.keyCode?(b=!0,ie.cancelFullScreen()):a.shiftKey&&32===a.keyCode&&g(\"space\")||37===a.keyCode&&g(\"left\")||38===a.keyCode&&g(\"up\")?c=\"<\":32===a.keyCode&&g(\"space\")||39===a.keyCode&&g(\"right\")||40===a.keyCode&&g(\"down\")?c=\">\":36===a.keyCode&&g(\"home\")?c=\"<<\":35===a.keyCode&&g(\"end\")&&(c=\">>\")),(b||c)&&Y(a),c&&ie.show({index:c,slow:a.altKey,user:!0})}),ie.index||Fc.off(b).on(b,\"textarea, input, select\",function(a){!Dc.hasClass(jb)&&a.stopPropagation()}),Ec.on(f,ie.resize)):(Fc.off(d),Ec.off(f))}function j(b){b!==j.f&&(b?(a.html(\"\").addClass(ib+\" \"+ke).append(qe).before(oe).before(pe),gb(ie)):(qe.detach(),oe.detach(),pe.detach(),a.html(ne.urtext).removeClass(ke),hb(ie)),i(b),j.f=b)}function m(){yd=ie.data=yd||P(e.data)||D(a),zd=ie.size=yd.length,!xd.ok&&e.shuffle&&O(yd),f(),Je=y(Je),zd&&j(!0)}function o(){var a=2>zd&&!e.enableifsingleframe||Cd;Me.noMove=a||Sd,Me.noSwipe=a||!e.swipe,!Wd&&se.toggleClass(Bb,!e.click&&!Me.noMove&&!Me.noSwipe),Nc&&qe.toggleClass(sb,!Me.noSwipe)}function t(a){a===!0&&(a=\"\"),e.autoplay=Math.max(+a||Sc,1.5*Vd)}function u(){function a(a,c){b[a?\"add\":\"remove\"].push(c)}ie.options=e=R(e),Sd=\"crossfade\"===e.transition||\"dissolve\"===e.transition,Md=e.loop&&(zd>2||Sd&&(!Wd||\"slide\"!==Wd)),Vd=+e.transitionduration||Qc,Yd=\"rtl\"===e.direction,Zd=d.extend({},e.keyboard&&dd,e.keyboard);var b={add:[],remove:[]};zd>1||e.enableifsingleframe?(Nd=e.nav,Pd=\"top\"===e.navposition,b.remove.push(Xb),we.toggle(!!e.arrows)):(Nd=!1,we.hide()),Rb(),Bd=new zc(d.extend(Ac,e.spinner,Bc,{direction:Yd?-1:1})),Gc(),Hc(),e.autoplay&&t(e.autoplay),Td=n(e.thumbwidth)||Uc,Ud=n(e.thumbheight)||Uc,Ne.ok=Pe.ok=e.trackpad&&!Mc,o(),ed(e,[Le]),Od=\"thumbs\"===Nd,Od?(lc(zd,\"navThumb\"),Ad=Be,he=Zc,J(oe,d.Fotorama.jst.style({w:Td,h:Ud,b:e.thumbborderwidth,m:e.thumbmargin,s:je,q:!Jc})),ye.addClass(Lb).removeClass(Kb)):\"dots\"===Nd?(lc(zd,\"navDot\"),Ad=Ae,he=Yc,ye.addClass(Kb).removeClass(Lb)):(Nd=!1,ye.removeClass(Lb+\" \"+Kb)),Nd&&(Pd?xe.insertBefore(re):xe.insertAfter(re),wc.nav=!1,wc(Ad,ze,\"nav\")),Qd=e.allowfullscreen,Qd?(De.prependTo(re),Rd=Kc&&\"native\"===Qd):(De.detach(),Rd=!1),a(Sd,ob),a(!Sd,pb),a(!e.captions,vb),a(Yd,tb),a(\"always\"!==e.arrows,wb),Xd=e.shadows&&!Mc,a(!Xd,rb),qe.addClass(b.add.join(\" \")).removeClass(b.remove.join(\" \")),Ke=d.extend({},e)}function x(a){return 0>a?(zd+a%zd)%zd:a>=zd?a%zd:a}function y(a){return h(a,0,zd-1)}function z(a){return Md?x(a):y(a)}function E(a){return a>0||Md?a-1:!1}function U(a){return zd-1>a||Md?a+1:!1}function $(){Me.min=Md?-1/0:-r(zd-1,Le.w,e.margin,Fd),Me.max=Md?1/0:-r(0,Le.w,e.margin,Fd),Me.snap=Le.w+e.margin}function bb(){Oe.min=Math.min(0,Le.nw-ze.width()),Oe.max=0,ze.toggleClass(Bb,!(Oe.noMove=Oe.min===Oe.max))}function cb(a,b,c){if(\"number\"==typeof a){a=new Array(a);var e=!0}return d.each(a,function(a,d){if(e&&(d=a),\"number\"==typeof d){var f=yd[x(d)];if(f){var g=\"$\"+b+\"Frame\",h=f[g];c.call(this,a,d,f,h,g,h&&h.data())}}})}function fb(a,b,c,d){(!$d||\"*\"===$d&&d===Ld)&&(a=q(e.width)||q(a)||Vc,b=q(e.height)||q(b)||Wc,ie.resize({width:a,ratio:e.ratio||c||a/b},0,d!==Ld&&\"*\"))}function Pb(a,b,c,f,g,h){cb(a,b,function(a,i,j,k,l,m){function n(a){var b=x(i);fd(a,{index:b,src:w,frame:yd[b]})}function o(){t.remove(),d.Fotorama.cache[w]=\"error\",j.html&&\"stage\"===b||!y||y===w?(!w||j.html||r?\"stage\"===b&&(k.trigger(\"f:load\").removeClass(ac+\" \"+_b).addClass(bc),n(\"load\"),fb()):(k.trigger(\"f:error\").removeClass(ac).addClass(_b),n(\"error\")),m.state=\"error\",!(zd>1&&yd[i]===j)||j.html||j.deleted||j.video||r||(j.deleted=!0,ie.splice(i,1))):(j[v]=w=y,Pb([i],b,c,f,g,!0))}function p(){d.Fotorama.measures[w]=u.measures=d.Fotorama.measures[w]||{width:s.width,height:s.height,ratio:s.width/s.height},fb(u.measures.width,u.measures.height,u.measures.ratio,i),t.off(\"load error\").addClass(fc+(r?\" \"+gc:\"\")).prependTo(k),I(t,(d.isFunction(c)?c():c)||Le,f||j.fit||e.fit,g||j.position||e.position),d.Fotorama.cache[w]=m.state=\"loaded\",setTimeout(function(){k.trigger(\"f:load\").removeClass(ac+\" \"+_b).addClass(bc+\" \"+(r?cc:dc)),\"stage\"===b?n(\"load\"):(j.thumbratio===$c||!j.thumbratio&&e.thumbratio===$c)&&(j.thumbratio=u.measures.ratio,vd())},0)}function q(){var a=10;G(function(){return!fe||!a--&&!Mc},function(){p()})}if(k){var r=ie.fullScreen&&j.full&&j.full!==j.img&&!m.$full&&\"stage\"===b;if(!m.$img||h||r){var s=new Image,t=d(s),u=t.data();m[r?\"$full\":\"$img\"]=t;var v=\"stage\"===b?r?\"full\":\"img\":\"thumb\",w=j[v],y=r?null:j[\"stage\"===b?\"thumb\":\"img\"];if(\"navThumb\"===b&&(k=m.$wrap),!w)return void o();d.Fotorama.cache[w]?!function z(){\"error\"===d.Fotorama.cache[w]?o():\"loaded\"===d.Fotorama.cache[w]?setTimeout(q,0):setTimeout(z,100)}():(d.Fotorama.cache[w]=\"*\",t.on(\"load\",q).on(\"error\",o)),m.state=\"\",s.src=w}}})}function Qb(a){Ie.append(Bd.spin().el).appendTo(a)}function Rb(){Ie.detach(),Bd&&Bd.stop()}function Sb(){var a=Dd[Xc];a&&!a.data().state&&(Qb(a),a.on(\"f:load f:error\",function(){a.off(\"f:load f:error\"),Rb()}))}function ec(a){W(a,sd),X(a,function(){setTimeout(function(){Q(ye)},0),Rc({time:Vd,guessIndex:d(this).data().eq,minMax:Oe})})}function lc(a,b){cb(a,b,function(a,c,e,f,g,h){if(!f){f=e[g]=qe[g].clone(),h=f.data(),h.data=e;var i=f[0];\"stage\"===b?(e.html&&d('<div class=\"'+kc+'\"></div>').append(e._html?d(e.html).removeAttr(\"id\").html(e._html):e.html).appendTo(f),e.caption&&d(N(oc,N(pc,e.caption))).appendTo(f),e.video&&f.addClass(zb).append(Fe.clone()),X(i,function(){setTimeout(function(){Q(re)},0),pd({index:h.eq,user:!0})}),te=te.add(f)):\"navDot\"===b?(ec(i),Ae=Ae.add(f)):\"navThumb\"===b&&(ec(i),h.$wrap=f.children(\":first\"),Be=Be.add(f),e.video&&h.$wrap.append(Fe.clone()))}})}function sc(a,b,c,d){return a&&a.length&&I(a,b,c,d)}function tc(a){cb(a,\"stage\",function(a,b,c,f,g,h){if(f){var i=x(b),j=c.fit||e.fit,k=c.position||e.position;h.eq=i,Re[Xc][i]=f.css(d.extend({left:Sd?0:r(b,Le.w,e.margin,Fd)},Sd&&l(0))),F(f[0])&&(f.appendTo(se),md(c.$video)),sc(h.$img,Le,j,k),sc(h.$full,Le,j,k)}})}function uc(a,b){if(\"thumbs\"===Nd&&!isNaN(a)){var c=-a,f=-a+Le.nw;Be.each(function(){var a=d(this),g=a.data(),h=g.eq,i=function(){return{h:Ud,w:g.w}},j=i(),k=yd[h]||{},l=k.thumbfit||e.thumbfit,m=k.thumbposition||e.thumbposition;j.w=g.w,g.l+g.w<c||g.l>f||sc(g.$img,j,l,m)||b&&Pb([h],\"navThumb\",i,l,m)})}}function wc(a,b,c){if(!wc[c]){var f=\"nav\"===c&&Od,g=0;b.append(a.filter(function(){for(var a,b=d(this),c=b.data(),e=0,f=yd.length;f>e;e++)if(c.data===yd[e]){a=!0,c.eq=e;break}return a||b.remove()&&!1}).sort(function(a,b){return d(a).data().eq-d(b).data().eq}).each(function(){if(f){var a=d(this),b=a.data(),c=Math.round(Ud*b.data.thumbratio)||Td;b.l=g,b.w=c,a.css({width:c}),g+=c+e.thumbmargin}})),wc[c]=!0}}function xc(a){return a-Se>Le.w/3}function yc(a){return!(Md||Je+a&&Je-zd+a||Cd)}function Gc(){var a=yc(0),b=yc(1);ue.toggleClass(Eb,a).attr(V(a)),ve.toggleClass(Eb,b).attr(V(b))}function Hc(){Ne.ok&&(Ne.prevent={\"<\":yc(0),\">\":yc(1)})}function Lc(a){var b,c,d=a.data();return Od?(b=d.l,c=d.w):(b=a.position().left,c=a.width()),{c:b+c/2,min:-b+10*e.thumbmargin,max:-b+Le.w-c-10*e.thumbmargin}}function Oc(a){var b=Dd[he].data();_(Ce,{time:1.2*a,pos:b.l,width:b.w-2*e.thumbborderwidth})}function Rc(a){var b=yd[a.guessIndex][he];if(b){var c=Oe.min!==Oe.max,d=a.minMax||c&&Lc(Dd[he]),e=c&&(a.keep&&Rc.l?Rc.l:h((a.coo||Le.nw/2)-Lc(b).c,d.min,d.max)),f=c&&h(e,Oe.min,Oe.max),g=1.1*a.time;_(ze,{time:g,pos:f||0,onEnd:function(){uc(f,!0)}}),ld(ye,K(f,Oe.min,Oe.max)),Rc.l=e}}function Tc(){_c(he),Qe[he].push(Dd[he].addClass(Wb))}function _c(a){for(var b=Qe[a];b.length;)b.shift().removeClass(Wb)}function bd(a){var b=Re[a];d.each(Ed,function(a,c){delete b[x(c)]}),d.each(b,function(a,c){delete b[a],c.detach()})}function cd(a){Fd=Gd=Je;var b=Dd[Xc];b&&(_c(Xc),Qe[Xc].push(b.addClass(Wb)),a||ie.show.onEnd(!0),v(se,0,!0),bd(Xc),tc(Ed),$(),bb())}function ed(a,b){a&&d.each(b,function(b,c){c&&d.extend(c,{width:a.width||c.width,height:a.height,minwidth:a.minwidth,maxwidth:a.maxwidth,minheight:a.minheight,maxheight:a.maxheight,ratio:S(a.ratio)})})}function fd(b,c){a.trigger(ib+\":\"+b,[ie,c])}function gd(){clearTimeout(hd.t),fe=1,e.stopautoplayontouch?ie.stopAutoplay():ce=!0}function hd(){fe&&(e.stopautoplayontouch||(id(),jd()),hd.t=setTimeout(function(){fe=0},Qc+Pc))}function id(){ce=!(!Cd&&!de)}function jd(){if(clearTimeout(jd.t),G.stop(jd.w),!e.autoplay||ce)return void(ie.autoplay&&(ie.autoplay=!1,fd(\"stopautoplay\")));ie.autoplay||(ie.autoplay=!0,fd(\"startautoplay\"));var a=Je,b=Dd[Xc].data();jd.w=G(function(){return b.state||a!==Je},function(){jd.t=setTimeout(function(){if(!ce&&a===Je){var b=Kd,c=yd[b][Xc].data();jd.w=G(function(){return c.state||b!==Kd},function(){ce||b!==Kd||ie.show(Md?Z(!Yd):Kd)})}},e.autoplay)})}function kd(){ie.fullScreen&&(ie.fullScreen=!1,Kc&&vc.cancel(le),Dc.removeClass(jb),Cc.removeClass(jb),a.removeClass(Zb).insertAfter(pe),Le=d.extend({},ee),md(Cd,!0,!0),rd(\"x\",!1),ie.resize(),Pb(Ed,\"stage\"),Q(Ec,ae,_d),fd(\"fullscreenexit\"))}function ld(a,b){Xd&&(a.removeClass(Ub+\" \"+Vb),b&&!Cd&&a.addClass(b.replace(/^|\\s/g,\" \"+Tb+\"--\")))}function md(a,b,c){b&&(qe.removeClass(nb),Cd=!1,o()),a&&a!==Cd&&(a.remove(),fd(\"unloadvideo\")),c&&(id(),jd())}function nd(a){qe.toggleClass(qb,a)}function od(a){if(!Me.flow){var b=a?a.pageX:od.x,c=b&&!yc(xc(b))&&e.click;od.p!==c&&re.toggleClass(Cb,c)&&(od.p=c,od.x=b)}}function pd(a){clearTimeout(pd.t),e.clicktransition&&e.clicktransition!==e.transition?setTimeout(function(){var b=e.transition;ie.setOptions({transition:e.clicktransition}),Wd=b,pd.t=setTimeout(function(){ie.show(a)},10)},0):ie.show(a)}function qd(a,b){var c=a.target,f=d(c);f.hasClass(mc)?ie.playVideo():c===Ee?ie.toggleFullScreen():Cd?c===He&&md(Cd,!0,!0):b?nd():e.click&&pd({index:a.shiftKey||Z(xc(a._x)),slow:a.altKey,user:!0})}function rd(a,b){Me[a]=Oe[a]=b}function sd(a){var b=d(this).data().eq;pd({index:b,slow:a.altKey,user:!0,coo:a._x-ye.offset().left})}function td(a){pd({index:we.index(this)?\">\":\"<\",slow:a.altKey,user:!0})}function ud(a){X(a,function(){setTimeout(function(){Q(re)},0),nd(!1)})}function vd(){if(m(),u(),!vd.i){vd.i=!0;var a=e.startindex;(a||e.hash&&c.hash)&&(Ld=L(a||c.hash.replace(/^#/,\"\"),yd,0===ie.index||a,a)),Je=Fd=Gd=Hd=Ld=z(Ld)||0}if(zd){if(wd())return;Cd&&md(Cd,!0),Ed=[],bd(Xc),vd.ok=!0,ie.show({index:Je,time:0}),ie.resize()}else ie.destroy()}function wd(){return!wd.f===Yd?(wd.f=Yd,Je=zd-1-Je,ie.reverse(),!0):void 0}function xd(){xd.ok||(xd.ok=!0,fd(\"ready\"))}Cc=d(\"html\"),Dc=d(\"body\");var yd,zd,Ad,Bd,Cd,Dd,Ed,Fd,Gd,Hd,Id,Jd,Kd,Ld,Md,Nd,Od,Pd,Qd,Rd,Sd,Td,Ud,Vd,Wd,Xd,Yd,Zd,$d,_d,ae,be,ce,de,ee,fe,ge,he,ie=this,je=d.now(),ke=ib+je,le=a[0],me=1,ne=a.data(),oe=d(\"<style></style>\"),pe=d(N(Yb)),qe=d(N(kb)),re=d(N(xb)).appendTo(qe),se=(re[0],d(N(Ab)).appendTo(re)),te=d(),ue=d(N(Db+\" \"+Fb+rc)),ve=d(N(Db+\" \"+Gb+rc)),we=ue.add(ve).appendTo(re),xe=d(N(Ib)),ye=d(N(Hb)).appendTo(xe),ze=d(N(Jb)).appendTo(ye),Ae=d(),Be=d(),Ce=(se.data(),ze.data(),d(N(jc)).appendTo(ze)),De=d(N($b+rc)),Ee=De[0],Fe=d(N(mc)),Ge=d(N(nc)).appendTo(re),He=Ge[0],Ie=d(N(qc)),Je=!1,Ke={},Le={},Me={},Ne={},Oe={},Pe={},Qe={},Re={},Se=0,Te=[];\nqe[Xc]=d(N(yb)),qe[Zc]=d(N(Mb+\" \"+Ob+rc,N(ic))),qe[Yc]=d(N(Mb+\" \"+Nb+rc,N(hc))),Qe[Xc]=[],Qe[Zc]=[],Qe[Yc]=[],Re[Xc]={},qe.addClass(Ic?mb:lb).toggleClass(qb,!e.controlsonstart),ne.fotorama=this,ie.startAutoplay=function(a){return ie.autoplay?this:(ce=de=!1,t(a||e.autoplay),jd(),this)},ie.stopAutoplay=function(){return ie.autoplay&&(ce=de=!0,jd()),this},ie.show=function(a){var b;\"object\"!=typeof a?(b=a,a={}):b=a.index,b=\">\"===b?Gd+1:\"<\"===b?Gd-1:\"<<\"===b?0:\">>\"===b?zd-1:b,b=isNaN(b)?L(b,yd,!0):b,b=\"undefined\"==typeof b?Je||0:b,ie.activeIndex=Je=z(b),Id=E(Je),Jd=U(Je),Kd=x(Je+(Yd?-1:1)),Ed=[Je,Id,Jd],Gd=Md?b:Je;var c=Math.abs(Hd-Gd),d=w(a.time,function(){return Math.min(Vd*(1+(c-1)/12),2*Vd)}),f=a.overPos;a.slow&&(d*=10);var g=Dd;ie.activeFrame=Dd=yd[Je];var i=g===Dd&&!a.user;md(Cd,Dd.i!==yd[x(Fd)].i),lc(Ed,\"stage\"),tc(Mc?[Gd]:[Gd,E(Gd),U(Gd)]),rd(\"go\",!0),i||fd(\"show\",{user:a.user,time:d}),ce=!0;var j=ie.show.onEnd=function(b){if(!j.ok){if(j.ok=!0,b||cd(!0),i||fd(\"showend\",{user:a.user}),!b&&Wd&&Wd!==e.transition)return ie.setOptions({transition:Wd}),void(Wd=!1);Sb(),Pb(Ed,\"stage\"),rd(\"go\",!1),Hc(),od(),id(),jd()}};if(Sd){var k=Dd[Xc],l=Je!==Hd?yd[Hd][Xc]:null;ab(k,l,te,{time:d,method:e.transition,onEnd:j},Te)}else _(se,{pos:-r(Gd,Le.w,e.margin,Fd),overPos:f,time:d,onEnd:j});if(Gc(),Nd){Tc();var m=y(Je+h(Gd-Hd,-1,1));Rc({time:d,coo:m!==Je&&a.coo,guessIndex:\"undefined\"!=typeof a.coo?m:Je,keep:i}),Od&&Oc(d)}return be=\"undefined\"!=typeof Hd&&Hd!==Je,Hd=Je,e.hash&&be&&!ie.eq&&H(Dd.id||Je+1),this},ie.requestFullScreen=function(){return Qd&&!ie.fullScreen&&(_d=Ec.scrollTop(),ae=Ec.scrollLeft(),Q(Ec),rd(\"x\",!0),ee=d.extend({},Le),a.addClass(Zb).appendTo(Dc.addClass(jb)),Cc.addClass(jb),md(Cd,!0,!0),ie.fullScreen=!0,Rd&&vc.request(le),ie.resize(),Pb(Ed,\"stage\"),Sb(),fd(\"fullscreenenter\")),this},ie.cancelFullScreen=function(){return Rd&&vc.is()?vc.cancel(b):kd(),this},ie.toggleFullScreen=function(){return ie[(ie.fullScreen?\"cancel\":\"request\")+\"FullScreen\"]()},T(b,vc.event,function(){!yd||vc.is()||Cd||kd()}),ie.resize=function(a){if(!yd)return this;var b=arguments[1]||0,c=arguments[2];ed(ie.fullScreen?{width:\"100%\",maxwidth:null,minwidth:null,height:\"100%\",maxheight:null,minheight:null}:R(a),[Le,c||ie.fullScreen||e]);var d=Le.width,f=Le.height,g=Le.ratio,i=Ec.height()-(Nd?ye.height():0);return q(d)&&(qe.addClass(ub).css({width:d,minWidth:Le.minwidth||0,maxWidth:Le.maxwidth||ad}),d=Le.W=Le.w=qe.width(),Le.nw=Nd&&p(e.navwidth,d)||d,e.glimpse&&(Le.w-=Math.round(2*(p(e.glimpse,d)||0))),se.css({width:Le.w,marginLeft:(Le.W-Le.w)/2}),f=p(f,i),f=f||g&&d/g,f&&(d=Math.round(d),f=Le.h=Math.round(h(f,p(Le.minheight,i),p(Le.maxheight,i))),re.stop().animate({width:d,height:f},b,function(){qe.removeClass(ub)}),cd(),Nd&&(ye.stop().animate({width:Le.nw},b),Rc({guessIndex:Je,time:b,keep:!0}),Od&&wc.nav&&Oc(b)),$d=c||!0,xd())),Se=re.offset().left,this},ie.setOptions=function(a){return d.extend(e,a),vd(),this},ie.shuffle=function(){return yd&&O(yd)&&vd(),this},ie.destroy=function(){return ie.cancelFullScreen(),ie.stopAutoplay(),yd=ie.data=null,j(),Ed=[],bd(Xc),vd.ok=!1,this},ie.playVideo=function(){var a=Dd,b=a.video,c=Je;return\"object\"==typeof b&&a.videoReady&&(Rd&&ie.fullScreen&&ie.cancelFullScreen(),G(function(){return!vc.is()||c!==Je},function(){c===Je&&(a.$video=a.$video||d(d.Fotorama.jst.video(b)),a.$video.appendTo(a[Xc]),qe.addClass(nb),Cd=a.$video,o(),we.blur(),De.blur(),fd(\"loadvideo\"))})),this},ie.stopVideo=function(){return md(Cd,!0,!0),this},re.on(\"mousemove\",od),Me=db(se,{onStart:gd,onMove:function(a,b){ld(re,b.edge)},onTouchEnd:hd,onEnd:function(a){ld(re);var b=(Nc&&!ge||a.touch)&&e.arrows&&\"always\"!==e.arrows;if(a.moved||b&&a.pos!==a.newPos&&!a.control){var c=s(a.newPos,Le.w,e.margin,Fd);ie.show({index:c,time:Sd?Vd:a.time,overPos:a.overPos,user:!0})}else a.aborted||a.control||qd(a.startEvent,b)},timeLow:1,timeHigh:1,friction:2,select:\".\"+Xb+\", .\"+Xb+\" *\",$wrap:re}),Oe=db(ze,{onStart:gd,onMove:function(a,b){ld(ye,b.edge)},onTouchEnd:hd,onEnd:function(a){function b(){Rc.l=a.newPos,id(),jd(),uc(a.newPos,!0)}if(a.moved)a.pos!==a.newPos?(ce=!0,_(ze,{time:a.time,pos:a.newPos,overPos:a.overPos,onEnd:b}),uc(a.newPos),Xd&&ld(ye,K(a.newPos,Oe.min,Oe.max))):b();else{var c=a.$target.closest(\".\"+Mb,ze)[0];c&&sd.call(c,a.startEvent)}},timeLow:.5,timeHigh:2,friction:5,$wrap:ye}),Ne=eb(re,{shift:!0,onEnd:function(a,b){gd(),hd(),ie.show({index:b,slow:a.altKey})}}),Pe=eb(ye,{onEnd:function(a,b){gd(),hd();var c=v(ze)+.25*b;ze.css(k(h(c,Oe.min,Oe.max))),Xd&&ld(ye,K(c,Oe.min,Oe.max)),Pe.prevent={\"<\":c>=Oe.max,\">\":c<=Oe.min},clearTimeout(Pe.t),Pe.t=setTimeout(function(){Rc.l=c,uc(c,!0)},Pc),uc(c)}}),qe.hover(function(){setTimeout(function(){fe||nd(!(ge=!0))},0)},function(){ge&&nd(!(ge=!1))}),M(we,function(a){Y(a),td.call(this,a)},{onStart:function(){gd(),Me.control=!0},onTouchEnd:hd}),we.each(function(){W(this,function(a){td.call(this,a)}),ud(this)}),W(Ee,ie.toggleFullScreen),ud(Ee),d.each(\"load push pop shift unshift reverse sort splice\".split(\" \"),function(a,b){ie[b]=function(){return yd=yd||[],\"load\"!==b?Array.prototype[b].apply(yd,arguments):arguments[0]&&\"object\"==typeof arguments[0]&&arguments[0].length&&(yd=P(arguments[0])),vd(),ie}}),vd()},d.fn.fotorama=function(b){return this.each(function(){var c=this,e=d(this),f=e.data(),g=f.fotorama;g?g.setOptions(b,!0):G(function(){return!E(c)},function(){f.urtext=e.html(),new d.Fotorama(e,d.extend({},cd,a.fotoramaDefaults,b,f))})})},d.Fotorama.instances=[],d.Fotorama.cache={},d.Fotorama.measures={},d=d||{},d.Fotorama=d.Fotorama||{},d.Fotorama.jst=d.Fotorama.jst||{},d.Fotorama.jst.style=function(a){{var b,c=\"\";tc.escape}return c+=\".fotorama\"+(null==(b=a.s)?\"\":b)+\" .fotorama__nav--thumbs .fotorama__nav__frame{\\npadding:\"+(null==(b=a.m)?\"\":b)+\"px;\\nheight:\"+(null==(b=a.h)?\"\":b)+\"px}\\n.fotorama\"+(null==(b=a.s)?\"\":b)+\" .fotorama__thumb-border{\\nheight:\"+(null==(b=a.h-a.b*(a.q?0:2))?\"\":b)+\"px;\\nborder-width:\"+(null==(b=a.b)?\"\":b)+\"px;\\nmargin-top:\"+(null==(b=a.m)?\"\":b)+\"px}\"},d.Fotorama.jst.video=function(a){function b(){c+=d.call(arguments,\"\")}var c=\"\",d=(tc.escape,Array.prototype.join);return c+='<div class=\"fotorama__video\"><iframe src=\"',b((\"youtube\"==a.type?a.p+\"youtube.com/embed/\"+a.id+\"?autoplay=1\":\"vimeo\"==a.type?a.p+\"player.vimeo.com/video/\"+a.id+\"?autoplay=1&badge=0\":a.id)+(a.s&&\"custom\"!=a.type?\"&\"+a.s:\"\")),c+='\" frameborder=\"0\" allowfullscreen></iframe></div>\\n'},d(function(){d(\".\"+ib+':not([data-auto=\"false\"])').fotorama()})}(window,document,location,\"undefined\"!=typeof jQuery&&jQuery);","Magezon_Builder/js/magezon-builder.js":"define([\n\t'jquery',\n\t'Magezon_Builder/js/vimeo/player',\n\t'Magezon_Builder/js/parallax',\n\t'Magezon_Builder/js/responsive-typography',\n\t'Magezon_Core/js/jquery.magnific-popup.min',\n\t'waypoints'\n\t], function ($, Vimeo) {\n\n\t\tvar mgzInit = function() {\n\t\t\t\n\t\t$(window).resize(function() {\n\t\t\tvar height = $(window).height();\n\t\t\t$(document).find('.mgz-row-full-height').each(function(index, el) {\n\t\t\t\t$(this).css('min-height', height);\n\t\t\t\t$(this).children('.mgz-element-inner').css('min-height', height);\n\t\t\t\t$(this).children().children('.mgz-element-row-content').css('min-height', height);\n\t\t\t});\n\t\t}).resize();\n\n\t\t// ANIMATION\n\t\tif ($(\".mgz-animated:not(.mgz_start_animation)\").length) {\n\t\t\t$(\".mgz-animated:not(.mgz_start_animation)\").waypoint(function() {\n\t\t\t\tvar self = this;\n\t\t\t\tvar delayTime = 0;\n\t\t\t\tif ($(this.element).data('animation-delay')) {\n\t\t\t\t\tdelayTime = $(this.element).data('animation-delay');\n\t\t\t\t}\n\t\t\t\tvar durationTime = 0;\n\t\t\t\tif ($(this.element).data('animation-duration')) {\n\t\t\t\t\tdurationTime = $(this.element).data('animation-duration');\n\t\t\t\t}\n\t\t\t\tif (durationTime) $(self.element).css(\"animation-duration\", durationTime + 's');\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t$(self.element).addClass(\"mgz_start_animation animated\")\n\t\t\t\t}, delayTime * 1000);\n\t\t\t}, {\n\t\t\t\toffset: \"85%\"\n\t\t\t});\n\t\t}\n\n\t\t// WAYPOINT\n\t\tif ($(\".mgz-waypoint\").length) {\n\t\t\t$(\".mgz-waypoint\").waypoint(function() {\n\t\t\t\tif (!$(this.element).hasClass('mgz-animation-applied')) {\n\t\t\t\t\t$(this.element).trigger('mgz:animation:run');\n\t\t\t\t\t$(this.element).addClass('mgz-animation-applied');\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\toffset: \"85%\",\n\t\t\t\ttriggerOnce: true\n\t\t\t});\n\t\t}\n\n\t\t$('.magezon-builder').find('.mgz-magnific-link').each(function(index, el) {\n\t\t\tvar type = $(this).data('type') ? $(this).data('type') : 'image';\n\t\t\tvar options = {\n\t\t\t\ttype: type,\n\t\t\t\tmainClass: $(this).data('main-class'),\n\t\t\t\tremovalDelay: 300,\n\t\t\t\tfixedContentPos: true,\n\t\t\t\tfixedBgPos: true,\n\t\t\t\timage: {\n\t\t\t\t\tverticalFit: true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($(this).data('zoom')) {\n\t\t\t\tif (options['mainClass']) {\n\t\t\t\t\toptions['mainClass'] += ' mfp-no-margins mfp-with-zoom';\n\t\t\t\t} else {\n\t\t\t\t\toptions['mainClass'] = 'mfp-no-margins mfp-with-zoom';\n\t\t\t\t}\n\t\t\t\toptions['zoom'] = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tduration: 300\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t$(this).magnificPopup(options);\n\t\t});\n\n\t\t$('.magezon-builder').find('.mgz-magnific-gallery').each(function(index, el) {\n\t\t\tvar options = {\n\t\t\t\tdelegate: 'a',\n\t\t\t\ttype: 'image',\n\t\t\t\ttLoading: 'Loading image #%curr%...',\n\t\t\t\tmainClass: 'mgz-mfp',\n\t\t\t\tfixedContentPos: true,\n\t\t\t\tgallery: {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tnavigateByImgClick: true,\n\t\t\t\t\tpreload: [0,1]\n\t\t\t\t}\n\t\t\t}\n\t\t\t$(this).magnificPopup(options);\n\t\t});\n\n\t\t$('.magezon-builder').find('.mgz-magnific').each(function(index, el) {\n\t\t\tvar type = $(this).data('type') ? $(this).data('type') : 'image';\n\t\t\tvar options = {};\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'gallery':\n\t\t\t\tvar delegate = 'a';\n\t\t\t\toptions = {\n\t\t\t\t\tdelegate: delegate,\n\t\t\t\t\ttype: 'image',\n\t\t\t\t\ttLoading: 'Loading image #%curr%...',\n\t\t\t\t\tmainClass: 'mgz-mfp',\n\t\t\t\t\tfixedContentPos: true,\n\t\t\t\t\tgallery: {\n\t\t\t\t\t\tenabled: true,\n\t\t\t\t\t\tnavigateByImgClick: true,\n\t\t\t\t\t\tpreload: [0,1]\n\t\t\t\t\t},\n\t\t\t\t\tiframe: {\n\t\t\t\t\t\tmarkup: '<div class=\"mfp-iframe-scaler\">'+\n\t\t\t\t\t\t'<div class=\"mfp-close\"></div>'+\n\t\t\t\t\t\t'<iframe class=\"mfp-iframe\" frameborder=\"0\" allowfullscreen></iframe>'+\n\t\t\t\t\t\t'<div class=\"mfp-title\"></div>' +\n\t\t\t\t\t\t'<div class=\"mfp-counter\"></div>' +\n\t\t\t\t\t\t'</div>',\n\t\t\t\t\t\tpatterns: {\n\t\t\t\t\t\t\tyoutube: {\n\t\t\t\t\t\t\t\tindex: 'youtube.com/',\n\t\t\t\t\t\t\t\tid: 'v=',\n\t\t\t\t\t\t\t\tsrc: 'http://www.youtube.com/embed/%id%?rel=0&autoplay=1'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tcallbacks: {\n\t\t\t\t\t\telementParse: function(item) {\n\t\t\t\t\t\t\tif (item.el.data('type')) {\n\t\t\t\t\t\t\t\titem.type = item.el.data('type');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmarkupParse: function(template, values, item) {\n\t\t\t\t\t\t\tvalues.title = item.el.attr('title');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\toptions = {\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmainClass: $(this).data('main-class'),\n\t\t\t\t\tremovalDelay: 300,\n\t\t\t\t\tfixedContentPos: true,\n\t\t\t\t\timage: {\n\t\t\t\t\t\tverticalFit: true\n\t\t\t\t\t},\n\t\t\t\t\timage: {\n\t\t\t\t\t\ttitleSrc: function(item) {\n\t\t\t\t\t\t\tvar title = item.el.attr('title');\n\t\t\t\t\t\t\tif (item.el.data('title')) {\n\t\t\t\t\t\t\t\ttitle = item.el.data('title');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn title;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($(this).data('zoom')) {\n\t\t\t\t\toptions['zoom'] = {\n\t\t\t\t\t\tenabled: true,\n\t\t\t\t\t\tduration: 300\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ($(this).data('zoom')) {\n\t\t\t\tif (options['mainClass']) {\n\t\t\t\t\toptions['mainClass'] += ' mfp-no-margins mfp-with-zoom';\n\t\t\t\t} else {\n\t\t\t\t\toptions['mainClass'] = 'mfp-no-margins mfp-with-zoom';\n\t\t\t\t}\n\t\t\t\toptions['zoom'] = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tduration: 300\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t$(this).click(function(e) {\n\t\t\t\te.preventDefault();\n\t\t\t});\n\t\t\t$(this).magnificPopup(options);\n\t\t});\n\n\t\t$('.mgz-magnific').on('click', function() {\n\t\t\treturn false;\n\t\t});\n\n\t\t$('.mgz-element-single_image .image-content').click(function(event) {\n\t\t\t$(this).siblings('a')[0].click();\n\t\t});\n\n\t\t$('.mgz-element-single_image .mgz-single-image-inner').hover(function() {\n\t\t\tvar img = $(this).find('img');\n\t\t\tif (img.data('hover')) {\n\t\t\t\tvar src = img.attr('src');\n\t\t\t\timg.data('src', src);\n\t\t\t\timg.attr('src', img.data('hover'));\n\t\t\t}\n\t\t}, function() {\n\t\t\tvar img = $(this).find('img');\n\t\t\tif (img.data('src')) {\n\t\t\t\tvar src = img.data('src');\n\t\t\t\timg.attr('src', src);\t\n\t\t\t}\n\t\t});\n\t}\n\t$('body').on('magezonBuilderLoaded', mgzInit);\n\t$(document).on('mgz:init', mgzInit);\n\t$('body').trigger('magezonBuilderLoaded');\n\tjQuery(document).ready(function($) {\n\t\t$('.magezon-builder').removeClass('magezon-builder-preload');\n\t});\n});","Magezon_Builder/js/ui-bootstrap-tpls-2.5.0.min.js":"/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 2.5.0 - 2017-01-28\n * License: MIT\n */angular.module(\"ui.bootstrap\",[\"ui.bootstrap.tpls\",\"ui.bootstrap.collapse\",\"ui.bootstrap.tabindex\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.position\",\"ui.bootstrap.datepickerPopup\",\"ui.bootstrap.debounce\",\"ui.bootstrap.multiMap\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.paging\",\"ui.bootstrap.pager\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]),angular.module(\"ui.bootstrap.tpls\",[\"uib/template/accordion/accordion-group.html\",\"uib/template/accordion/accordion.html\",\"uib/template/alert/alert.html\",\"uib/template/carousel/carousel.html\",\"uib/template/carousel/slide.html\",\"uib/template/datepicker/datepicker.html\",\"uib/template/datepicker/day.html\",\"uib/template/datepicker/month.html\",\"uib/template/datepicker/year.html\",\"uib/template/datepickerPopup/popup.html\",\"uib/template/modal/window.html\",\"uib/template/pager/pager.html\",\"uib/template/pagination/pagination.html\",\"uib/template/tooltip/tooltip-html-popup.html\",\"uib/template/tooltip/tooltip-popup.html\",\"uib/template/tooltip/tooltip-template-popup.html\",\"uib/template/popover/popover-html.html\",\"uib/template/popover/popover-template.html\",\"uib/template/popover/popover.html\",\"uib/template/progressbar/bar.html\",\"uib/template/progressbar/progress.html\",\"uib/template/progressbar/progressbar.html\",\"uib/template/rating/rating.html\",\"uib/template/tabs/tab.html\",\"uib/template/tabs/tabset.html\",\"uib/template/timepicker/timepicker.html\",\"uib/template/typeahead/typeahead-match.html\",\"uib/template/typeahead/typeahead-popup.html\"]),angular.module(\"ui.bootstrap.collapse\",[]).directive(\"uibCollapse\",[\"$animate\",\"$q\",\"$parse\",\"$injector\",function(a,b,c,d){var e=d.has(\"$animateCss\")?d.get(\"$animateCss\"):null;return{link:function(d,f,g){function h(){r=!!(\"horizontal\"in g),r?(s={width:\"\"},t={width:\"0\"}):(s={height:\"\"},t={height:\"0\"}),d.$eval(g.uibCollapse)||f.addClass(\"in\").addClass(\"collapse\").attr(\"aria-expanded\",!0).attr(\"aria-hidden\",!1).css(s)}function i(a){return r?{width:a.scrollWidth+\"px\"}:{height:a.scrollHeight+\"px\"}}function j(){f.hasClass(\"collapse\")&&f.hasClass(\"in\")||b.resolve(n(d)).then(function(){f.removeClass(\"collapse\").addClass(\"collapsing\").attr(\"aria-expanded\",!0).attr(\"aria-hidden\",!1),e?e(f,{addClass:\"in\",easing:\"ease\",css:{overflow:\"hidden\"},to:i(f[0])}).start()[\"finally\"](k):a.addClass(f,\"in\",{css:{overflow:\"hidden\"},to:i(f[0])}).then(k)},angular.noop)}function k(){f.removeClass(\"collapsing\").addClass(\"collapse\").css(s),o(d)}function l(){return f.hasClass(\"collapse\")||f.hasClass(\"in\")?void b.resolve(p(d)).then(function(){f.css(i(f[0])).removeClass(\"collapse\").addClass(\"collapsing\").attr(\"aria-expanded\",!1).attr(\"aria-hidden\",!0),e?e(f,{removeClass:\"in\",to:t}).start()[\"finally\"](m):a.removeClass(f,\"in\",{to:t}).then(m)},angular.noop):m()}function m(){f.css(t),f.removeClass(\"collapsing\").addClass(\"collapse\"),q(d)}var n=c(g.expanding),o=c(g.expanded),p=c(g.collapsing),q=c(g.collapsed),r=!1,s={},t={};h(),d.$watch(g.uibCollapse,function(a){a?l():j()})}}}]),angular.module(\"ui.bootstrap.tabindex\",[]).directive(\"uibTabindexToggle\",function(){return{restrict:\"A\",link:function(a,b,c){c.$observe(\"disabled\",function(a){c.$set(\"tabindex\",a?-1:null)})}}}),angular.module(\"ui.bootstrap.accordion\",[\"ui.bootstrap.collapse\",\"ui.bootstrap.tabindex\"]).constant(\"uibAccordionConfig\",{closeOthers:!0}).controller(\"UibAccordionController\",[\"$scope\",\"$attrs\",\"uibAccordionConfig\",function(a,b,c){this.groups=[],this.closeOthers=function(d){var e=angular.isDefined(b.closeOthers)?a.$eval(b.closeOthers):c.closeOthers;e&&angular.forEach(this.groups,function(a){a!==d&&(a.isOpen=!1)})},this.addGroup=function(a){var b=this;this.groups.push(a),a.$on(\"$destroy\",function(c){b.removeGroup(a)})},this.removeGroup=function(a){var b=this.groups.indexOf(a);-1!==b&&this.groups.splice(b,1)}}]).directive(\"uibAccordion\",function(){return{controller:\"UibAccordionController\",controllerAs:\"accordion\",transclude:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/accordion/accordion.html\"}}}).directive(\"uibAccordionGroup\",function(){return{require:\"^uibAccordion\",transclude:!0,restrict:\"A\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/accordion/accordion-group.html\"},scope:{heading:\"@\",panelClass:\"@?\",isOpen:\"=?\",isDisabled:\"=?\"},controller:function(){this.setHeading=function(a){this.heading=a}},link:function(a,b,c,d){b.addClass(\"panel\"),d.addGroup(a),a.openClass=c.openClass||\"panel-open\",a.panelClass=c.panelClass||\"panel-default\",a.$watch(\"isOpen\",function(c){b.toggleClass(a.openClass,!!c),c&&d.closeOthers(a)}),a.toggleOpen=function(b){a.isDisabled||b&&32!==b.which||(a.isOpen=!a.isOpen)};var e=\"accordiongroup-\"+a.$id+\"-\"+Math.floor(1e4*Math.random());a.headingId=e+\"-tab\",a.panelId=e+\"-panel\"}}}).directive(\"uibAccordionHeading\",function(){return{transclude:!0,template:\"\",replace:!0,require:\"^uibAccordionGroup\",link:function(a,b,c,d,e){d.setHeading(e(a,angular.noop))}}}).directive(\"uibAccordionTransclude\",function(){function a(){return\"uib-accordion-header,data-uib-accordion-header,x-uib-accordion-header,uib\\\\:accordion-header,[uib-accordion-header],[data-uib-accordion-header],[x-uib-accordion-header]\"}return{require:\"^uibAccordionGroup\",link:function(b,c,d,e){b.$watch(function(){return e[d.uibAccordionTransclude]},function(b){if(b){var d=angular.element(c[0].querySelector(a()));d.html(\"\"),d.append(b)}})}}}),angular.module(\"ui.bootstrap.alert\",[]).controller(\"UibAlertController\",[\"$scope\",\"$element\",\"$attrs\",\"$interpolate\",\"$timeout\",function(a,b,c,d,e){a.closeable=!!c.close,b.addClass(\"alert\"),c.$set(\"role\",\"alert\"),a.closeable&&b.addClass(\"alert-dismissible\");var f=angular.isDefined(c.dismissOnTimeout)?d(c.dismissOnTimeout)(a.$parent):null;f&&e(function(){a.close()},parseInt(f,10))}]).directive(\"uibAlert\",function(){return{controller:\"UibAlertController\",controllerAs:\"alert\",restrict:\"A\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/alert/alert.html\"},transclude:!0,scope:{close:\"&\"}}}),angular.module(\"ui.bootstrap.buttons\",[]).constant(\"uibButtonConfig\",{activeClass:\"active\",toggleEvent:\"click\"}).controller(\"UibButtonsController\",[\"uibButtonConfig\",function(a){this.activeClass=a.activeClass||\"active\",this.toggleEvent=a.toggleEvent||\"click\"}]).directive(\"uibBtnRadio\",[\"$parse\",function(a){return{require:[\"uibBtnRadio\",\"ngModel\"],controller:\"UibButtonsController\",controllerAs:\"buttons\",link:function(b,c,d,e){var f=e[0],g=e[1],h=a(d.uibUncheckable);c.find(\"input\").css({display:\"none\"}),g.$render=function(){c.toggleClass(f.activeClass,angular.equals(g.$modelValue,b.$eval(d.uibBtnRadio)))},c.on(f.toggleEvent,function(){if(!d.disabled){var a=c.hasClass(f.activeClass);a&&!angular.isDefined(d.uncheckable)||b.$apply(function(){g.$setViewValue(a?null:b.$eval(d.uibBtnRadio)),g.$render()})}}),d.uibUncheckable&&b.$watch(h,function(a){d.$set(\"uncheckable\",a?\"\":void 0)})}}}]).directive(\"uibBtnCheckbox\",function(){return{require:[\"uibBtnCheckbox\",\"ngModel\"],controller:\"UibButtonsController\",controllerAs:\"button\",link:function(a,b,c,d){function e(){return g(c.btnCheckboxTrue,!0)}function f(){return g(c.btnCheckboxFalse,!1)}function g(b,c){return angular.isDefined(b)?a.$eval(b):c}var h=d[0],i=d[1];b.find(\"input\").css({display:\"none\"}),i.$render=function(){b.toggleClass(h.activeClass,angular.equals(i.$modelValue,e()))},b.on(h.toggleEvent,function(){c.disabled||a.$apply(function(){i.$setViewValue(b.hasClass(h.activeClass)?f():e()),i.$render()})})}}}),angular.module(\"ui.bootstrap.carousel\",[]).controller(\"UibCarouselController\",[\"$scope\",\"$element\",\"$interval\",\"$timeout\",\"$animate\",function(a,b,c,d,e){function f(a){for(var b=0;b<p.length;b++)p[b].slide.active=b===a}function g(c,d,g){if(!s){if(angular.extend(c,{direction:g}),angular.extend(p[r].slide||{},{direction:g}),e.enabled(b)&&!a.$currentTransition&&p[d].element&&o.slides.length>1){p[d].element.data(q,c.direction);var h=o.getCurrentIndex();angular.isNumber(h)&&p[h].element&&p[h].element.data(q,c.direction),a.$currentTransition=!0,e.on(\"addClass\",p[d].element,function(b,c){\"close\"===c&&(a.$currentTransition=null,e.off(\"addClass\",b))})}a.active=c.index,r=c.index,f(d),k()}}function h(a){for(var b=0;b<p.length;b++)if(p[b].slide===a)return b}function i(){m&&(c.cancel(m),m=null)}function j(b){b.length||(a.$currentTransition=null)}function k(){i();var b=+a.interval;!isNaN(b)&&b>0&&(m=c(l,b))}function l(){var b=+a.interval;n&&!isNaN(b)&&b>0&&p.length?a.next():a.pause()}var m,n,o=this,p=o.slides=a.slides=[],q=\"uib-slideDirection\",r=a.active,s=!1;b.addClass(\"carousel\"),o.addSlide=function(b,c){p.push({slide:b,element:c}),p.sort(function(a,b){return+a.slide.index-+b.slide.index}),(b.index===a.active||1===p.length&&!angular.isNumber(a.active))&&(a.$currentTransition&&(a.$currentTransition=null),r=b.index,a.active=b.index,f(r),o.select(p[h(b)]),1===p.length&&a.play())},o.getCurrentIndex=function(){for(var a=0;a<p.length;a++)if(p[a].slide.index===r)return a},o.next=a.next=function(){var b=(o.getCurrentIndex()+1)%p.length;return 0===b&&a.noWrap()?void a.pause():o.select(p[b],\"next\")},o.prev=a.prev=function(){var b=o.getCurrentIndex()-1<0?p.length-1:o.getCurrentIndex()-1;return a.noWrap()&&b===p.length-1?void a.pause():o.select(p[b],\"prev\")},o.removeSlide=function(b){var c=h(b);p.splice(c,1),p.length>0&&r===c?c>=p.length?(r=p.length-1,a.active=r,f(r),o.select(p[p.length-1])):(r=c,a.active=r,f(r),o.select(p[c])):r>c&&(r--,a.active=r),0===p.length&&(r=null,a.active=null)},o.select=a.select=function(b,c){var d=h(b.slide);void 0===c&&(c=d>o.getCurrentIndex()?\"next\":\"prev\"),b.slide.index===r||a.$currentTransition||g(b.slide,d,c)},a.indexOfSlide=function(a){return+a.slide.index},a.isActive=function(b){return a.active===b.slide.index},a.isPrevDisabled=function(){return 0===a.active&&a.noWrap()},a.isNextDisabled=function(){return a.active===p.length-1&&a.noWrap()},a.pause=function(){a.noPause||(n=!1,i())},a.play=function(){n||(n=!0,k())},b.on(\"mouseenter\",a.pause),b.on(\"mouseleave\",a.play),a.$on(\"$destroy\",function(){s=!0,i()}),a.$watch(\"noTransition\",function(a){e.enabled(b,!a)}),a.$watch(\"interval\",k),a.$watchCollection(\"slides\",j),a.$watch(\"active\",function(a){if(angular.isNumber(a)&&r!==a){for(var b=0;b<p.length;b++)if(p[b].slide.index===a){a=b;break}var c=p[a];c&&(f(a),o.select(p[a]),r=a)}})}]).directive(\"uibCarousel\",function(){return{transclude:!0,controller:\"UibCarouselController\",controllerAs:\"carousel\",restrict:\"A\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/carousel/carousel.html\"},scope:{active:\"=\",interval:\"=\",noTransition:\"=\",noPause:\"=\",noWrap:\"&\"}}}).directive(\"uibSlide\",[\"$animate\",function(a){return{require:\"^uibCarousel\",restrict:\"A\",transclude:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/carousel/slide.html\"},scope:{actual:\"=?\",index:\"=?\"},link:function(b,c,d,e){c.addClass(\"item\"),e.addSlide(b,c),b.$on(\"$destroy\",function(){e.removeSlide(b)}),b.$watch(\"active\",function(b){a[b?\"addClass\":\"removeClass\"](c,\"active\")})}}}]).animation(\".item\",[\"$animateCss\",function(a){function b(a,b,c){a.removeClass(b),c&&c()}var c=\"uib-slideDirection\";return{beforeAddClass:function(d,e,f){if(\"active\"===e){var g=!1,h=d.data(c),i=\"next\"===h?\"left\":\"right\",j=b.bind(this,d,i+\" \"+h,f);return d.addClass(h),a(d,{addClass:i}).start().done(j),function(){g=!0}}f()},beforeRemoveClass:function(d,e,f){if(\"active\"===e){var g=!1,h=d.data(c),i=\"next\"===h?\"left\":\"right\",j=b.bind(this,d,i,f);return a(d,{addClass:i}).start().done(j),function(){g=!0}}f()}}}]),angular.module(\"ui.bootstrap.dateparser\",[]).service(\"uibDateParser\",[\"$log\",\"$locale\",\"dateFilter\",\"orderByFilter\",\"filterFilter\",function(a,b,c,d,e){function f(a){return e(s,{key:a},!0)[0]}function g(a){var b=[],c=a.split(\"\"),e=a.indexOf(\"'\");if(e>-1){var f=!1;a=a.split(\"\");for(var g=e;g<a.length;g++)f?(\"'\"===a[g]&&(g+1<a.length&&\"'\"===a[g+1]?(a[g+1]=\"$\",c[g+1]=\"\"):(c[g]=\"\",f=!1)),a[g]=\"$\"):\"'\"===a[g]&&(a[g]=\"$\",c[g]=\"\",f=!0);a=a.join(\"\")}return angular.forEach(s,function(d){var e=a.indexOf(d.key);if(e>-1){a=a.split(\"\"),c[e]=\"(\"+d.regex+\")\",a[e]=\"$\";for(var f=e+1,g=e+d.key.length;g>f;f++)c[f]=\"\",a[f]=\"$\";a=a.join(\"\"),b.push({index:e,key:d.key,apply:d.apply,matcher:d.regex})}}),{regex:new RegExp(\"^\"+c.join(\"\")+\"$\"),map:d(b,\"index\")}}function h(a){for(var b,c,d=[],e=0;e<a.length;)if(angular.isNumber(c)){if(\"'\"===a.charAt(e))(e+1>=a.length||\"'\"!==a.charAt(e+1))&&(d.push(i(a,c,e)),c=null);else if(e===a.length)for(;c<a.length;)b=j(a,c),d.push(b),c=b.endIdx;e++}else\"'\"!==a.charAt(e)?(b=j(a,e),d.push(b.parser),e=b.endIdx):(c=e,e++);return d}function i(a,b,c){return function(){return a.substr(b+1,c-b-1)}}function j(a,b){for(var c=a.substr(b),d=0;d<s.length;d++)if(new RegExp(\"^\"+s[d].key).test(c)){var e=s[d];return{endIdx:b+e.key.length,parser:e.formatter}}return{endIdx:b+1,parser:function(){return c.charAt(0)}}}function k(a,b,c){return 1>c?!1:1===b&&c>28?29===c&&(a%4===0&&a%100!==0||a%400===0):3===b||5===b||8===b||10===b?31>c:!0}function l(a){return parseInt(a,10)}function m(a,b){return a&&b?q(a,b):a}function n(a,b){return a&&b?q(a,b,!0):a}function o(a,b){a=a.replace(/:/g,\"\");var c=Date.parse(\"Jan 01, 1970 00:00:00 \"+a)/6e4;return isNaN(c)?b:c}function p(a,b){return a=new Date(a.getTime()),a.setMinutes(a.getMinutes()+b),a}function q(a,b,c){c=c?-1:1;var d=a.getTimezoneOffset(),e=o(b,d);return p(a,c*(e-d))}var r,s,t=/[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;this.init=function(){r=b.id,this.parsers={},this.formatters={},s=[{key:\"yyyy\",regex:\"\\\\d{4}\",apply:function(a){this.year=+a},formatter:function(a){var b=new Date;return b.setFullYear(Math.abs(a.getFullYear())),c(b,\"yyyy\")}},{key:\"yy\",regex:\"\\\\d{2}\",apply:function(a){a=+a,this.year=69>a?a+2e3:a+1900},formatter:function(a){var b=new Date;return b.setFullYear(Math.abs(a.getFullYear())),c(b,\"yy\")}},{key:\"y\",regex:\"\\\\d{1,4}\",apply:function(a){this.year=+a},formatter:function(a){var b=new Date;return b.setFullYear(Math.abs(a.getFullYear())),c(b,\"y\")}},{key:\"M!\",regex:\"0?[1-9]|1[0-2]\",apply:function(a){this.month=a-1},formatter:function(a){var b=a.getMonth();return/^[0-9]$/.test(b)?c(a,\"MM\"):c(a,\"M\")}},{key:\"MMMM\",regex:b.DATETIME_FORMATS.MONTH.join(\"|\"),apply:function(a){this.month=b.DATETIME_FORMATS.MONTH.indexOf(a)},formatter:function(a){return c(a,\"MMMM\")}},{key:\"MMM\",regex:b.DATETIME_FORMATS.SHORTMONTH.join(\"|\"),apply:function(a){this.month=b.DATETIME_FORMATS.SHORTMONTH.indexOf(a)},formatter:function(a){return c(a,\"MMM\")}},{key:\"MM\",regex:\"0[1-9]|1[0-2]\",apply:function(a){this.month=a-1},formatter:function(a){return c(a,\"MM\")}},{key:\"M\",regex:\"[1-9]|1[0-2]\",apply:function(a){this.month=a-1},formatter:function(a){return c(a,\"M\")}},{key:\"d!\",regex:\"[0-2]?[0-9]{1}|3[0-1]{1}\",apply:function(a){this.date=+a},formatter:function(a){var b=a.getDate();return/^[1-9]$/.test(b)?c(a,\"dd\"):c(a,\"d\")}},{key:\"dd\",regex:\"[0-2][0-9]{1}|3[0-1]{1}\",apply:function(a){this.date=+a},formatter:function(a){return c(a,\"dd\")}},{key:\"d\",regex:\"[1-2]?[0-9]{1}|3[0-1]{1}\",apply:function(a){this.date=+a},formatter:function(a){return c(a,\"d\")}},{key:\"EEEE\",regex:b.DATETIME_FORMATS.DAY.join(\"|\"),formatter:function(a){return c(a,\"EEEE\")}},{key:\"EEE\",regex:b.DATETIME_FORMATS.SHORTDAY.join(\"|\"),formatter:function(a){return c(a,\"EEE\")}},{key:\"HH\",regex:\"(?:0|1)[0-9]|2[0-3]\",apply:function(a){this.hours=+a},formatter:function(a){return c(a,\"HH\")}},{key:\"hh\",regex:\"0[0-9]|1[0-2]\",apply:function(a){this.hours=+a},formatter:function(a){return c(a,\"hh\")}},{key:\"H\",regex:\"1?[0-9]|2[0-3]\",apply:function(a){this.hours=+a},formatter:function(a){return c(a,\"H\")}},{key:\"h\",regex:\"[0-9]|1[0-2]\",apply:function(a){this.hours=+a},formatter:function(a){return c(a,\"h\")}},{key:\"mm\",regex:\"[0-5][0-9]\",apply:function(a){this.minutes=+a},formatter:function(a){return c(a,\"mm\")}},{key:\"m\",regex:\"[0-9]|[1-5][0-9]\",apply:function(a){this.minutes=+a},formatter:function(a){return c(a,\"m\")}},{key:\"sss\",regex:\"[0-9][0-9][0-9]\",apply:function(a){this.milliseconds=+a},formatter:function(a){return c(a,\"sss\")}},{key:\"ss\",regex:\"[0-5][0-9]\",apply:function(a){this.seconds=+a},formatter:function(a){return c(a,\"ss\")}},{key:\"s\",regex:\"[0-9]|[1-5][0-9]\",apply:function(a){this.seconds=+a},formatter:function(a){return c(a,\"s\")}},{key:\"a\",regex:b.DATETIME_FORMATS.AMPMS.join(\"|\"),apply:function(a){12===this.hours&&(this.hours=0),\"PM\"===a&&(this.hours+=12)},formatter:function(a){return c(a,\"a\")}},{key:\"Z\",regex:\"[+-]\\\\d{4}\",apply:function(a){var b=a.match(/([+-])(\\d{2})(\\d{2})/),c=b[1],d=b[2],e=b[3];this.hours+=l(c+d),this.minutes+=l(c+e)},formatter:function(a){return c(a,\"Z\")}},{key:\"ww\",regex:\"[0-4][0-9]|5[0-3]\",formatter:function(a){return c(a,\"ww\")}},{key:\"w\",regex:\"[0-9]|[1-4][0-9]|5[0-3]\",formatter:function(a){return c(a,\"w\")}},{key:\"GGGG\",regex:b.DATETIME_FORMATS.ERANAMES.join(\"|\").replace(/\\s/g,\"\\\\s\"),formatter:function(a){return c(a,\"GGGG\")}},{key:\"GGG\",regex:b.DATETIME_FORMATS.ERAS.join(\"|\"),formatter:function(a){return c(a,\"GGG\")}},{key:\"GG\",regex:b.DATETIME_FORMATS.ERAS.join(\"|\"),formatter:function(a){return c(a,\"GG\")}},{key:\"G\",regex:b.DATETIME_FORMATS.ERAS.join(\"|\"),formatter:function(a){return c(a,\"G\")}}],angular.version.major>=1&&angular.version.minor>4&&s.push({key:\"LLLL\",regex:b.DATETIME_FORMATS.STANDALONEMONTH.join(\"|\"),apply:function(a){this.month=b.DATETIME_FORMATS.STANDALONEMONTH.indexOf(a)},formatter:function(a){return c(a,\"LLLL\")}})},this.init(),this.getParser=function(a){var b=f(a);return b&&b.apply||null},this.overrideParser=function(a,b){var c=f(a);c&&angular.isFunction(b)&&(this.parsers={},c.apply=b)}.bind(this),this.filter=function(a,c){if(!angular.isDate(a)||isNaN(a)||!c)return\"\";c=b.DATETIME_FORMATS[c]||c,b.id!==r&&this.init(),this.formatters[c]||(this.formatters[c]=h(c));var d=this.formatters[c];return d.reduce(function(b,c){return b+c(a)},\"\")},this.parse=function(c,d,e){if(!angular.isString(c)||!d)return c;d=b.DATETIME_FORMATS[d]||d,d=d.replace(t,\"\\\\$&\"),b.id!==r&&this.init(),this.parsers[d]||(this.parsers[d]=g(d,\"apply\"));var f=this.parsers[d],h=f.regex,i=f.map,j=c.match(h),l=!1;if(j&&j.length){var m,n;angular.isDate(e)&&!isNaN(e.getTime())?m={year:e.getFullYear(),month:e.getMonth(),date:e.getDate(),hours:e.getHours(),minutes:e.getMinutes(),seconds:e.getSeconds(),milliseconds:e.getMilliseconds()}:(e&&a.warn(\"dateparser:\",\"baseDate is not a valid date\"),m={year:1900,month:0,date:1,hours:0,minutes:0,seconds:0,milliseconds:0});for(var o=1,p=j.length;p>o;o++){var q=i[o-1];\"Z\"===q.matcher&&(l=!0),q.apply&&q.apply.call(m,j[o])}var s=l?Date.prototype.setUTCFullYear:Date.prototype.setFullYear,u=l?Date.prototype.setUTCHours:Date.prototype.setHours;return k(m.year,m.month,m.date)&&(!angular.isDate(e)||isNaN(e.getTime())||l?(n=new Date(0),s.call(n,m.year,m.month,m.date),u.call(n,m.hours||0,m.minutes||0,m.seconds||0,m.milliseconds||0)):(n=new Date(e),s.call(n,m.year,m.month,m.date),u.call(n,m.hours,m.minutes,m.seconds,m.milliseconds))),n}},this.toTimezone=m,this.fromTimezone=n,this.timezoneToOffset=o,this.addDateMinutes=p,this.convertTimezoneToLocal=q}]),angular.module(\"ui.bootstrap.isClass\",[]).directive(\"uibIsClass\",[\"$animate\",function(a){var b=/^\\s*([\\s\\S]+?)\\s+on\\s+([\\s\\S]+?)\\s*$/,c=/^\\s*([\\s\\S]+?)\\s+for\\s+([\\s\\S]+?)\\s*$/;return{restrict:\"A\",compile:function(d,e){function f(a,b,c){i.push(a),j.push({scope:a,element:b}),o.forEach(function(b,c){g(b,a)}),a.$on(\"$destroy\",h)}function g(b,d){var e=b.match(c),f=d.$eval(e[1]),g=e[2],h=k[b];if(!h){var i=function(b){var c=null;j.some(function(a){var d=a.scope.$eval(m);return d===b?(c=a,!0):void 0}),h.lastActivated!==c&&(h.lastActivated&&a.removeClass(h.lastActivated.element,f),c&&a.addClass(c.element,f),h.lastActivated=c)};k[b]=h={lastActivated:null,scope:d,watchFn:i,compareWithExp:g,watcher:d.$watch(g,i)}}h.watchFn(d.$eval(g))}function h(a){var b=a.targetScope,c=i.indexOf(b);if(i.splice(c,1),j.splice(c,1),i.length){var d=i[0];angular.forEach(k,function(a){a.scope===b&&(a.watcher=d.$watch(a.compareWithExp,a.watchFn),a.scope=d)})}else k={}}var i=[],j=[],k={},l=e.uibIsClass.match(b),m=l[2],n=l[1],o=n.split(\",\");return f}}}]),angular.module(\"ui.bootstrap.datepicker\",[\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\"]).value(\"$datepickerSuppressError\",!1).value(\"$datepickerLiteralWarning\",!0).constant(\"uibDatepickerConfig\",{datepickerMode:\"day\",formatDay:\"dd\",formatMonth:\"MMMM\",formatYear:\"yyyy\",formatDayHeader:\"EEE\",formatDayTitle:\"MMMM yyyy\",formatMonthTitle:\"yyyy\",maxDate:null,maxMode:\"year\",minDate:null,minMode:\"day\",monthColumns:3,ngModelOptions:{},shortcutPropagation:!1,showWeeks:!0,yearColumns:5,yearRows:4}).controller(\"UibDatepickerController\",[\"$scope\",\"$element\",\"$attrs\",\"$parse\",\"$interpolate\",\"$locale\",\"$log\",\"dateFilter\",\"uibDatepickerConfig\",\"$datepickerLiteralWarning\",\"$datepickerSuppressError\",\"uibDateParser\",function(a,b,c,d,e,f,g,h,i,j,k,l){function m(b){a.datepickerMode=b,a.datepickerOptions.datepickerMode=b}function n(b){var c;if(angular.version.minor<6)c=b.$options||a.datepickerOptions.ngModelOptions||i.ngModelOptions||{},c.getOption=function(a){return c[a]};else{var d=b.$options.getOption(\"timezone\")||(a.datepickerOptions.ngModelOptions?a.datepickerOptions.ngModelOptions.timezone:null)||(i.ngModelOptions?i.ngModelOptions.timezone:null);c=b.$options.createChild(i.ngModelOptions).createChild(a.datepickerOptions.ngModelOptions).createChild(b.$options).createChild({timezone:d})}return c}var o=this,p={$setViewValue:angular.noop},q={},r=[];b.addClass(\"uib-datepicker\"),c.$set(\"role\",\"application\"),a.datepickerOptions||(a.datepickerOptions={}),this.modes=[\"day\",\"month\",\"year\"],[\"customClass\",\"dateDisabled\",\"datepickerMode\",\"formatDay\",\"formatDayHeader\",\"formatDayTitle\",\"formatMonth\",\"formatMonthTitle\",\"formatYear\",\"maxDate\",\"maxMode\",\"minDate\",\"minMode\",\"monthColumns\",\"showWeeks\",\"shortcutPropagation\",\"startingDay\",\"yearColumns\",\"yearRows\"].forEach(function(b){switch(b){case\"customClass\":case\"dateDisabled\":a[b]=a.datepickerOptions[b]||angular.noop;break;case\"datepickerMode\":a.datepickerMode=angular.isDefined(a.datepickerOptions.datepickerMode)?a.datepickerOptions.datepickerMode:i.datepickerMode;break;case\"formatDay\":case\"formatDayHeader\":case\"formatDayTitle\":case\"formatMonth\":case\"formatMonthTitle\":case\"formatYear\":o[b]=angular.isDefined(a.datepickerOptions[b])?e(a.datepickerOptions[b])(a.$parent):i[b];break;case\"monthColumns\":case\"showWeeks\":case\"shortcutPropagation\":case\"yearColumns\":case\"yearRows\":o[b]=angular.isDefined(a.datepickerOptions[b])?a.datepickerOptions[b]:i[b];break;case\"startingDay\":angular.isDefined(a.datepickerOptions.startingDay)?o.startingDay=a.datepickerOptions.startingDay:angular.isNumber(i.startingDay)?o.startingDay=i.startingDay:o.startingDay=(f.DATETIME_FORMATS.FIRSTDAYOFWEEK+8)%7;break;case\"maxDate\":case\"minDate\":a.$watch(\"datepickerOptions.\"+b,function(a){a?angular.isDate(a)?o[b]=l.fromTimezone(new Date(a),q.getOption(\"timezone\")):(j&&g.warn(\"Literal date support has been deprecated, please switch to date object usage\"),o[b]=new Date(h(a,\"medium\"))):o[b]=i[b]?l.fromTimezone(new Date(i[b]),q.getOption(\"timezone\")):null,o.refreshView()});break;case\"maxMode\":case\"minMode\":a.datepickerOptions[b]?a.$watch(function(){return a.datepickerOptions[b]},function(c){o[b]=a[b]=angular.isDefined(c)?c:a.datepickerOptions[b],(\"minMode\"===b&&o.modes.indexOf(a.datepickerOptions.datepickerMode)<o.modes.indexOf(o[b])||\"maxMode\"===b&&o.modes.indexOf(a.datepickerOptions.datepickerMode)>o.modes.indexOf(o[b]))&&(a.datepickerMode=o[b],a.datepickerOptions.datepickerMode=o[b])}):o[b]=a[b]=i[b]||null}}),a.uniqueId=\"datepicker-\"+a.$id+\"-\"+Math.floor(1e4*Math.random()),a.disabled=angular.isDefined(c.disabled)||!1,angular.isDefined(c.ngDisabled)&&r.push(a.$parent.$watch(c.ngDisabled,function(b){a.disabled=b,o.refreshView()})),a.isActive=function(b){return 0===o.compare(b.date,o.activeDate)?(a.activeDateId=b.uid,!0):!1},this.init=function(b){p=b,q=n(p),a.datepickerOptions.initDate?(o.activeDate=l.fromTimezone(a.datepickerOptions.initDate,q.getOption(\"timezone\"))||new Date,a.$watch(\"datepickerOptions.initDate\",function(a){a&&(p.$isEmpty(p.$modelValue)||p.$invalid)&&(o.activeDate=l.fromTimezone(a,q.getOption(\"timezone\")),o.refreshView())})):o.activeDate=new Date;var c=p.$modelValue?new Date(p.$modelValue):new Date;this.activeDate=isNaN(c)?l.fromTimezone(new Date,q.getOption(\"timezone\")):l.fromTimezone(c,q.getOption(\"timezone\")),p.$render=function(){o.render()}},this.render=function(){if(p.$viewValue){var a=new Date(p.$viewValue),b=!isNaN(a);b?this.activeDate=l.fromTimezone(a,q.getOption(\"timezone\")):k||g.error('Datepicker directive: \"ng-model\" value must be a Date object')}this.refreshView()},this.refreshView=function(){if(this.element){a.selectedDt=null,this._refreshView(),a.activeDt&&(a.activeDateId=a.activeDt.uid);var b=p.$viewValue?new Date(p.$viewValue):null;b=l.fromTimezone(b,q.getOption(\"timezone\")),p.$setValidity(\"dateDisabled\",!b||this.element&&!this.isDisabled(b))}},this.createDateObject=function(b,c){var d=p.$viewValue?new Date(p.$viewValue):null;d=l.fromTimezone(d,q.getOption(\"timezone\"));var e=new Date;e=l.fromTimezone(e,q.getOption(\"timezone\"));var f=this.compare(b,e),g={date:b,label:l.filter(b,c),selected:d&&0===this.compare(b,d),disabled:this.isDisabled(b),past:0>f,current:0===f,future:f>0,customClass:this.customClass(b)||null};return d&&0===this.compare(b,d)&&(a.selectedDt=g),o.activeDate&&0===this.compare(g.date,o.activeDate)&&(a.activeDt=g),g},this.isDisabled=function(b){return a.disabled||this.minDate&&this.compare(b,this.minDate)<0||this.maxDate&&this.compare(b,this.maxDate)>0||a.dateDisabled&&a.dateDisabled({date:b,mode:a.datepickerMode})},this.customClass=function(b){return a.customClass({date:b,mode:a.datepickerMode})},this.split=function(a,b){for(var c=[];a.length>0;)c.push(a.splice(0,b));return c},a.select=function(b){if(a.datepickerMode===o.minMode){var c=p.$viewValue?l.fromTimezone(new Date(p.$viewValue),q.getOption(\"timezone\")):new Date(0,0,0,0,0,0,0);c.setFullYear(b.getFullYear(),b.getMonth(),b.getDate()),c=l.toTimezone(c,q.getOption(\"timezone\")),p.$setViewValue(c),p.$render()}else o.activeDate=b,m(o.modes[o.modes.indexOf(a.datepickerMode)-1]),a.$emit(\"uib:datepicker.mode\");a.$broadcast(\"uib:datepicker.focus\")},a.move=function(a){var b=o.activeDate.getFullYear()+a*(o.step.years||0),c=o.activeDate.getMonth()+a*(o.step.months||0);o.activeDate.setFullYear(b,c,1),o.refreshView()},a.toggleMode=function(b){b=b||1,a.datepickerMode===o.maxMode&&1===b||a.datepickerMode===o.minMode&&-1===b||(m(o.modes[o.modes.indexOf(a.datepickerMode)+b]),a.$emit(\"uib:datepicker.mode\"))},a.keys={13:\"enter\",32:\"space\",33:\"pageup\",34:\"pagedown\",35:\"end\",36:\"home\",37:\"left\",38:\"up\",39:\"right\",40:\"down\"};var s=function(){o.element[0].focus()};a.$on(\"uib:datepicker.focus\",s),a.keydown=function(b){var c=a.keys[b.which];if(c&&!b.shiftKey&&!b.altKey&&!a.disabled)if(b.preventDefault(),o.shortcutPropagation||b.stopPropagation(),\"enter\"===c||\"space\"===c){if(o.isDisabled(o.activeDate))return;a.select(o.activeDate)}else!b.ctrlKey||\"up\"!==c&&\"down\"!==c?(o.handleKeyDown(c,b),o.refreshView()):a.toggleMode(\"up\"===c?1:-1)},b.on(\"keydown\",function(b){a.$apply(function(){a.keydown(b)})}),a.$on(\"$destroy\",function(){for(;r.length;)r.shift()()})}]).controller(\"UibDaypickerController\",[\"$scope\",\"$element\",\"dateFilter\",function(a,b,c){function d(a,b){return 1!==b||a%4!==0||a%100===0&&a%400!==0?f[b]:29}function e(a){var b=new Date(a);b.setDate(b.getDate()+4-(b.getDay()||7));var c=b.getTime();return b.setMonth(0),b.setDate(1),Math.floor(Math.round((c-b)/864e5)/7)+1}var f=[31,28,31,30,31,30,31,31,30,31,30,31];this.step={months:1},this.element=b,this.init=function(b){angular.extend(b,this),a.showWeeks=b.showWeeks,b.refreshView()},this.getDates=function(a,b){for(var c,d=new Array(b),e=new Date(a),f=0;b>f;)c=new Date(e),d[f++]=c,e.setDate(e.getDate()+1);return d},this._refreshView=function(){var b=this.activeDate.getFullYear(),d=this.activeDate.getMonth(),f=new Date(this.activeDate);f.setFullYear(b,d,1);var g=this.startingDay-f.getDay(),h=g>0?7-g:-g,i=new Date(f);h>0&&i.setDate(-h+1);for(var j=this.getDates(i,42),k=0;42>k;k++)j[k]=angular.extend(this.createDateObject(j[k],this.formatDay),{secondary:j[k].getMonth()!==d,uid:a.uniqueId+\"-\"+k});a.labels=new Array(7);for(var l=0;7>l;l++)a.labels[l]={abbr:c(j[l].date,this.formatDayHeader),full:c(j[l].date,\"EEEE\")};if(a.title=c(this.activeDate,this.formatDayTitle),a.rows=this.split(j,7),a.showWeeks){a.weekNumbers=[];for(var m=(11-this.startingDay)%7,n=a.rows.length,o=0;n>o;o++)a.weekNumbers.push(e(a.rows[o][m].date))}},this.compare=function(a,b){var c=new Date(a.getFullYear(),a.getMonth(),a.getDate()),d=new Date(b.getFullYear(),b.getMonth(),b.getDate());return c.setFullYear(a.getFullYear()),d.setFullYear(b.getFullYear()),c-d},this.handleKeyDown=function(a,b){var c=this.activeDate.getDate();if(\"left\"===a)c-=1;else if(\"up\"===a)c-=7;else if(\"right\"===a)c+=1;else if(\"down\"===a)c+=7;else if(\"pageup\"===a||\"pagedown\"===a){var e=this.activeDate.getMonth()+(\"pageup\"===a?-1:1);this.activeDate.setMonth(e,1),c=Math.min(d(this.activeDate.getFullYear(),this.activeDate.getMonth()),c)}else\"home\"===a?c=1:\"end\"===a&&(c=d(this.activeDate.getFullYear(),this.activeDate.getMonth()));this.activeDate.setDate(c)}}]).controller(\"UibMonthpickerController\",[\"$scope\",\"$element\",\"dateFilter\",function(a,b,c){this.step={years:1},this.element=b,this.init=function(a){angular.extend(a,this),a.refreshView()},this._refreshView=function(){for(var b,d=new Array(12),e=this.activeDate.getFullYear(),f=0;12>f;f++)b=new Date(this.activeDate),b.setFullYear(e,f,1),d[f]=angular.extend(this.createDateObject(b,this.formatMonth),{uid:a.uniqueId+\"-\"+f});a.title=c(this.activeDate,this.formatMonthTitle),a.rows=this.split(d,this.monthColumns),a.yearHeaderColspan=this.monthColumns>3?this.monthColumns-2:1},this.compare=function(a,b){var c=new Date(a.getFullYear(),a.getMonth()),d=new Date(b.getFullYear(),b.getMonth());return c.setFullYear(a.getFullYear()),d.setFullYear(b.getFullYear()),c-d},this.handleKeyDown=function(a,b){var c=this.activeDate.getMonth();if(\"left\"===a)c-=1;else if(\"up\"===a)c-=this.monthColumns;else if(\"right\"===a)c+=1;else if(\"down\"===a)c+=this.monthColumns;else if(\"pageup\"===a||\"pagedown\"===a){var d=this.activeDate.getFullYear()+(\"pageup\"===a?-1:1);this.activeDate.setFullYear(d)}else\"home\"===a?c=0:\"end\"===a&&(c=11);this.activeDate.setMonth(c)}}]).controller(\"UibYearpickerController\",[\"$scope\",\"$element\",\"dateFilter\",function(a,b,c){function d(a){return parseInt((a-1)/f,10)*f+1}var e,f;this.element=b,this.yearpickerInit=function(){e=this.yearColumns,f=this.yearRows*e,this.step={years:f}},this._refreshView=function(){for(var b,c=new Array(f),g=0,h=d(this.activeDate.getFullYear());f>g;g++)b=new Date(this.activeDate),b.setFullYear(h+g,0,1),c[g]=angular.extend(this.createDateObject(b,this.formatYear),{uid:a.uniqueId+\"-\"+g});a.title=[c[0].label,c[f-1].label].join(\" - \"),a.rows=this.split(c,e),a.columns=e},this.compare=function(a,b){return a.getFullYear()-b.getFullYear()},this.handleKeyDown=function(a,b){var c=this.activeDate.getFullYear();\"left\"===a?c-=1:\"up\"===a?c-=e:\"right\"===a?c+=1:\"down\"===a?c+=e:\"pageup\"===a||\"pagedown\"===a?c+=(\"pageup\"===a?-1:1)*f:\"home\"===a?c=d(this.activeDate.getFullYear()):\"end\"===a&&(c=d(this.activeDate.getFullYear())+f-1),this.activeDate.setFullYear(c)}}]).directive(\"uibDatepicker\",function(){return{templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/datepicker.html\"},scope:{datepickerOptions:\"=?\"},require:[\"uibDatepicker\",\"^ngModel\"],restrict:\"A\",controller:\"UibDatepickerController\",controllerAs:\"datepicker\",link:function(a,b,c,d){var e=d[0],f=d[1];e.init(f)}}}).directive(\"uibDaypicker\",function(){return{templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/day.html\"},\nrequire:[\"^uibDatepicker\",\"uibDaypicker\"],restrict:\"A\",controller:\"UibDaypickerController\",link:function(a,b,c,d){var e=d[0],f=d[1];f.init(e)}}}).directive(\"uibMonthpicker\",function(){return{templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/month.html\"},require:[\"^uibDatepicker\",\"uibMonthpicker\"],restrict:\"A\",controller:\"UibMonthpickerController\",link:function(a,b,c,d){var e=d[0],f=d[1];f.init(e)}}}).directive(\"uibYearpicker\",function(){return{templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepicker/year.html\"},require:[\"^uibDatepicker\",\"uibYearpicker\"],restrict:\"A\",controller:\"UibYearpickerController\",link:function(a,b,c,d){var e=d[0];angular.extend(e,d[1]),e.yearpickerInit(),e.refreshView()}}}),angular.module(\"ui.bootstrap.position\",[]).factory(\"$uibPosition\",[\"$document\",\"$window\",function(a,b){var c,d,e={normal:/(auto|scroll)/,hidden:/(auto|scroll|hidden)/},f={auto:/\\s?auto?\\s?/i,primary:/^(top|bottom|left|right)$/,secondary:/^(top|bottom|left|right|center)$/,vertical:/^(top|bottom)$/},g=/(HTML|BODY)/;return{getRawNode:function(a){return a.nodeName?a:a[0]||a},parseStyle:function(a){return a=parseFloat(a),isFinite(a)?a:0},offsetParent:function(c){function d(a){return\"static\"===(b.getComputedStyle(a).position||\"static\")}c=this.getRawNode(c);for(var e=c.offsetParent||a[0].documentElement;e&&e!==a[0].documentElement&&d(e);)e=e.offsetParent;return e||a[0].documentElement},scrollbarWidth:function(e){if(e){if(angular.isUndefined(d)){var f=a.find(\"body\");f.addClass(\"uib-position-body-scrollbar-measure\"),d=b.innerWidth-f[0].clientWidth,d=isFinite(d)?d:0,f.removeClass(\"uib-position-body-scrollbar-measure\")}return d}if(angular.isUndefined(c)){var g=angular.element('<div class=\"uib-position-scrollbar-measure\"></div>');a.find(\"body\").append(g),c=g[0].offsetWidth-g[0].clientWidth,c=isFinite(c)?c:0,g.remove()}return c},scrollbarPadding:function(a){a=this.getRawNode(a);var c=b.getComputedStyle(a),d=this.parseStyle(c.paddingRight),e=this.parseStyle(c.paddingBottom),f=this.scrollParent(a,!1,!0),h=this.scrollbarWidth(g.test(f.tagName));return{scrollbarWidth:h,widthOverflow:f.scrollWidth>f.clientWidth,right:d+h,originalRight:d,heightOverflow:f.scrollHeight>f.clientHeight,bottom:e+h,originalBottom:e}},isScrollable:function(a,c){a=this.getRawNode(a);var d=c?e.hidden:e.normal,f=b.getComputedStyle(a);return d.test(f.overflow+f.overflowY+f.overflowX)},scrollParent:function(c,d,f){c=this.getRawNode(c);var g=d?e.hidden:e.normal,h=a[0].documentElement,i=b.getComputedStyle(c);if(f&&g.test(i.overflow+i.overflowY+i.overflowX))return c;var j=\"absolute\"===i.position,k=c.parentElement||h;if(k===h||\"fixed\"===i.position)return h;for(;k.parentElement&&k!==h;){var l=b.getComputedStyle(k);if(j&&\"static\"!==l.position&&(j=!1),!j&&g.test(l.overflow+l.overflowY+l.overflowX))break;k=k.parentElement}return k},position:function(c,d){c=this.getRawNode(c);var e=this.offset(c);if(d){var f=b.getComputedStyle(c);e.top-=this.parseStyle(f.marginTop),e.left-=this.parseStyle(f.marginLeft)}var g=this.offsetParent(c),h={top:0,left:0};return g!==a[0].documentElement&&(h=this.offset(g),h.top+=g.clientTop-g.scrollTop,h.left+=g.clientLeft-g.scrollLeft),{width:Math.round(angular.isNumber(e.width)?e.width:c.offsetWidth),height:Math.round(angular.isNumber(e.height)?e.height:c.offsetHeight),top:Math.round(e.top-h.top),left:Math.round(e.left-h.left)}},offset:function(c){c=this.getRawNode(c);var d=c.getBoundingClientRect();return{width:Math.round(angular.isNumber(d.width)?d.width:c.offsetWidth),height:Math.round(angular.isNumber(d.height)?d.height:c.offsetHeight),top:Math.round(d.top+(b.pageYOffset||a[0].documentElement.scrollTop)),left:Math.round(d.left+(b.pageXOffset||a[0].documentElement.scrollLeft))}},viewportOffset:function(c,d,e){c=this.getRawNode(c),e=e!==!1;var f=c.getBoundingClientRect(),g={top:0,left:0,bottom:0,right:0},h=d?a[0].documentElement:this.scrollParent(c),i=h.getBoundingClientRect();if(g.top=i.top+h.clientTop,g.left=i.left+h.clientLeft,h===a[0].documentElement&&(g.top+=b.pageYOffset,g.left+=b.pageXOffset),g.bottom=g.top+h.clientHeight,g.right=g.left+h.clientWidth,e){var j=b.getComputedStyle(h);g.top+=this.parseStyle(j.paddingTop),g.bottom-=this.parseStyle(j.paddingBottom),g.left+=this.parseStyle(j.paddingLeft),g.right-=this.parseStyle(j.paddingRight)}return{top:Math.round(f.top-g.top),bottom:Math.round(g.bottom-f.bottom),left:Math.round(f.left-g.left),right:Math.round(g.right-f.right)}},parsePlacement:function(a){var b=f.auto.test(a);return b&&(a=a.replace(f.auto,\"\")),a=a.split(\"-\"),a[0]=a[0]||\"top\",f.primary.test(a[0])||(a[0]=\"top\"),a[1]=a[1]||\"center\",f.secondary.test(a[1])||(a[1]=\"center\"),b?a[2]=!0:a[2]=!1,a},positionElements:function(a,c,d,e){a=this.getRawNode(a),c=this.getRawNode(c);var g=angular.isDefined(c.offsetWidth)?c.offsetWidth:c.prop(\"offsetWidth\"),h=angular.isDefined(c.offsetHeight)?c.offsetHeight:c.prop(\"offsetHeight\");d=this.parsePlacement(d);var i=e?this.offset(a):this.position(a),j={top:0,left:0,placement:\"\"};if(d[2]){var k=this.viewportOffset(a,e),l=b.getComputedStyle(c),m={width:g+Math.round(Math.abs(this.parseStyle(l.marginLeft)+this.parseStyle(l.marginRight))),height:h+Math.round(Math.abs(this.parseStyle(l.marginTop)+this.parseStyle(l.marginBottom)))};if(d[0]=\"top\"===d[0]&&m.height>k.top&&m.height<=k.bottom?\"bottom\":\"bottom\"===d[0]&&m.height>k.bottom&&m.height<=k.top?\"top\":\"left\"===d[0]&&m.width>k.left&&m.width<=k.right?\"right\":\"right\"===d[0]&&m.width>k.right&&m.width<=k.left?\"left\":d[0],d[1]=\"top\"===d[1]&&m.height-i.height>k.bottom&&m.height-i.height<=k.top?\"bottom\":\"bottom\"===d[1]&&m.height-i.height>k.top&&m.height-i.height<=k.bottom?\"top\":\"left\"===d[1]&&m.width-i.width>k.right&&m.width-i.width<=k.left?\"right\":\"right\"===d[1]&&m.width-i.width>k.left&&m.width-i.width<=k.right?\"left\":d[1],\"center\"===d[1])if(f.vertical.test(d[0])){var n=i.width/2-g/2;k.left+n<0&&m.width-i.width<=k.right?d[1]=\"left\":k.right+n<0&&m.width-i.width<=k.left&&(d[1]=\"right\")}else{var o=i.height/2-m.height/2;k.top+o<0&&m.height-i.height<=k.bottom?d[1]=\"top\":k.bottom+o<0&&m.height-i.height<=k.top&&(d[1]=\"bottom\")}}switch(d[0]){case\"top\":j.top=i.top-h;break;case\"bottom\":j.top=i.top+i.height;break;case\"left\":j.left=i.left-g;break;case\"right\":j.left=i.left+i.width}switch(d[1]){case\"top\":j.top=i.top;break;case\"bottom\":j.top=i.top+i.height-h;break;case\"left\":j.left=i.left;break;case\"right\":j.left=i.left+i.width-g;break;case\"center\":f.vertical.test(d[0])?j.left=i.left+i.width/2-g/2:j.top=i.top+i.height/2-h/2}return j.top=Math.round(j.top),j.left=Math.round(j.left),j.placement=\"center\"===d[1]?d[0]:d[0]+\"-\"+d[1],j},adjustTop:function(a,b,c,d){return-1!==a.indexOf(\"top\")&&c!==d?{top:b.top-d+\"px\"}:void 0},positionArrow:function(a,c){a=this.getRawNode(a);var d=a.querySelector(\".tooltip-inner, .popover-inner\");if(d){var e=angular.element(d).hasClass(\"tooltip-inner\"),g=e?a.querySelector(\".tooltip-arrow\"):a.querySelector(\".arrow\");if(g){var h={top:\"\",bottom:\"\",left:\"\",right:\"\"};if(c=this.parsePlacement(c),\"center\"===c[1])return void angular.element(g).css(h);var i=\"border-\"+c[0]+\"-width\",j=b.getComputedStyle(g)[i],k=\"border-\";k+=f.vertical.test(c[0])?c[0]+\"-\"+c[1]:c[1]+\"-\"+c[0],k+=\"-radius\";var l=b.getComputedStyle(e?d:a)[k];switch(c[0]){case\"top\":h.bottom=e?\"0\":\"-\"+j;break;case\"bottom\":h.top=e?\"0\":\"-\"+j;break;case\"left\":h.right=e?\"0\":\"-\"+j;break;case\"right\":h.left=e?\"0\":\"-\"+j}h[c[1]]=l,angular.element(g).css(h)}}}}}]),angular.module(\"ui.bootstrap.datepickerPopup\",[\"ui.bootstrap.datepicker\",\"ui.bootstrap.position\"]).value(\"$datepickerPopupLiteralWarning\",!0).constant(\"uibDatepickerPopupConfig\",{altInputFormats:[],appendToBody:!1,clearText:\"Clear\",closeOnDateSelection:!0,closeText:\"Done\",currentText:\"Today\",datepickerPopup:\"yyyy-MM-dd\",datepickerPopupTemplateUrl:\"uib/template/datepickerPopup/popup.html\",datepickerTemplateUrl:\"uib/template/datepicker/datepicker.html\",html5Types:{date:\"yyyy-MM-dd\",\"datetime-local\":\"yyyy-MM-ddTHH:mm:ss.sss\",month:\"yyyy-MM\"},onOpenFocus:!0,showButtonBar:!0,placement:\"auto bottom-left\"}).controller(\"UibDatepickerPopupController\",[\"$scope\",\"$element\",\"$attrs\",\"$compile\",\"$log\",\"$parse\",\"$window\",\"$document\",\"$rootScope\",\"$uibPosition\",\"dateFilter\",\"uibDateParser\",\"uibDatepickerPopupConfig\",\"$timeout\",\"uibDatepickerConfig\",\"$datepickerPopupLiteralWarning\",function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){function q(b){var c=l.parse(b,x,a.date);if(isNaN(c))for(var d=0;d<J.length;d++)if(c=l.parse(b,J[d],a.date),!isNaN(c))return c;return c}function r(a){if(angular.isNumber(a)&&(a=new Date(a)),!a)return null;if(angular.isDate(a)&&!isNaN(a))return a;if(angular.isString(a)){var b=q(a);if(!isNaN(b))return l.toTimezone(b,H.getOption(\"timezone\"))}return H.getOption(\"allowInvalid\")?a:void 0}function s(a,b){var d=a||b;return c.ngRequired||d?(angular.isNumber(d)&&(d=new Date(d)),d?angular.isDate(d)&&!isNaN(d)?!0:angular.isString(d)?!isNaN(q(d)):!1:!0):!0}function t(c){if(a.isOpen||!a.disabled){var d=I[0],e=b[0].contains(c.target),f=void 0!==d.contains&&d.contains(c.target);!a.isOpen||e||f||a.$apply(function(){a.isOpen=!1})}}function u(c){27===c.which&&a.isOpen?(c.preventDefault(),c.stopPropagation(),a.$apply(function(){a.isOpen=!1}),b[0].focus()):40!==c.which||a.isOpen||(c.preventDefault(),c.stopPropagation(),a.$apply(function(){a.isOpen=!0}))}function v(){if(a.isOpen){var d=angular.element(I[0].querySelector(\".uib-datepicker-popup\")),e=c.popupPlacement?c.popupPlacement:m.placement,f=j.positionElements(b,d,e,z);d.css({top:f.top+\"px\",left:f.left+\"px\"}),d.hasClass(\"uib-position-measure\")&&d.removeClass(\"uib-position-measure\")}}function w(a){var b;return angular.version.minor<6?(b=angular.isObject(a.$options)?a.$options:{timezone:null},b.getOption=function(a){return b[a]}):b=a.$options,b}var x,y,z,A,B,C,D,E,F,G,H,I,J,K=!1,L=[];this.init=function(e){if(G=e,H=w(G),y=angular.isDefined(c.closeOnDateSelection)?a.$parent.$eval(c.closeOnDateSelection):m.closeOnDateSelection,z=angular.isDefined(c.datepickerAppendToBody)?a.$parent.$eval(c.datepickerAppendToBody):m.appendToBody,A=angular.isDefined(c.onOpenFocus)?a.$parent.$eval(c.onOpenFocus):m.onOpenFocus,B=angular.isDefined(c.datepickerPopupTemplateUrl)?c.datepickerPopupTemplateUrl:m.datepickerPopupTemplateUrl,C=angular.isDefined(c.datepickerTemplateUrl)?c.datepickerTemplateUrl:m.datepickerTemplateUrl,J=angular.isDefined(c.altInputFormats)?a.$parent.$eval(c.altInputFormats):m.altInputFormats,a.showButtonBar=angular.isDefined(c.showButtonBar)?a.$parent.$eval(c.showButtonBar):m.showButtonBar,m.html5Types[c.type]?(x=m.html5Types[c.type],K=!0):(x=c.uibDatepickerPopup||m.datepickerPopup,c.$observe(\"uibDatepickerPopup\",function(a,b){var c=a||m.datepickerPopup;if(c!==x&&(x=c,G.$modelValue=null,!x))throw new Error(\"uibDatepickerPopup must have a date format specified.\")})),!x)throw new Error(\"uibDatepickerPopup must have a date format specified.\");if(K&&c.uibDatepickerPopup)throw new Error(\"HTML5 date input types do not support custom formats.\");D=angular.element(\"<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>\"),D.attr({\"ng-model\":\"date\",\"ng-change\":\"dateSelection(date)\",\"template-url\":B}),E=angular.element(D.children()[0]),E.attr(\"template-url\",C),a.datepickerOptions||(a.datepickerOptions={}),K&&\"month\"===c.type&&(a.datepickerOptions.datepickerMode=\"month\",a.datepickerOptions.minMode=\"month\"),E.attr(\"datepicker-options\",\"datepickerOptions\"),K?G.$formatters.push(function(b){return a.date=l.fromTimezone(b,H.getOption(\"timezone\")),b}):(G.$$parserName=\"date\",G.$validators.date=s,G.$parsers.unshift(r),G.$formatters.push(function(b){return G.$isEmpty(b)?(a.date=b,b):(angular.isNumber(b)&&(b=new Date(b)),a.date=l.fromTimezone(b,H.getOption(\"timezone\")),l.filter(a.date,x))})),G.$viewChangeListeners.push(function(){a.date=q(G.$viewValue)}),b.on(\"keydown\",u),I=d(D)(a),D.remove(),z?h.find(\"body\").append(I):b.after(I),a.$on(\"$destroy\",function(){for(a.isOpen===!0&&(i.$$phase||a.$apply(function(){a.isOpen=!1})),I.remove(),b.off(\"keydown\",u),h.off(\"click\",t),F&&F.off(\"scroll\",v),angular.element(g).off(\"resize\",v);L.length;)L.shift()()})},a.getText=function(b){return a[b+\"Text\"]||m[b+\"Text\"]},a.isDisabled=function(b){\"today\"===b&&(b=l.fromTimezone(new Date,H.getOption(\"timezone\")));var c={};return angular.forEach([\"minDate\",\"maxDate\"],function(b){a.datepickerOptions[b]?angular.isDate(a.datepickerOptions[b])?c[b]=new Date(a.datepickerOptions[b]):(p&&e.warn(\"Literal date support has been deprecated, please switch to date object usage\"),c[b]=new Date(k(a.datepickerOptions[b],\"medium\"))):c[b]=null}),a.datepickerOptions&&c.minDate&&a.compare(b,c.minDate)<0||c.maxDate&&a.compare(b,c.maxDate)>0},a.compare=function(a,b){return new Date(a.getFullYear(),a.getMonth(),a.getDate())-new Date(b.getFullYear(),b.getMonth(),b.getDate())},a.dateSelection=function(c){a.date=c;var d=a.date?l.filter(a.date,x):null;b.val(d),G.$setViewValue(d),y&&(a.isOpen=!1,b[0].focus())},a.keydown=function(c){27===c.which&&(c.stopPropagation(),a.isOpen=!1,b[0].focus())},a.select=function(b,c){if(c.stopPropagation(),\"today\"===b){var d=new Date;angular.isDate(a.date)?(b=new Date(a.date),b.setFullYear(d.getFullYear(),d.getMonth(),d.getDate())):(b=l.fromTimezone(d,H.getOption(\"timezone\")),b.setHours(0,0,0,0))}a.dateSelection(b)},a.close=function(c){c.stopPropagation(),a.isOpen=!1,b[0].focus()},a.disabled=angular.isDefined(c.disabled)||!1,c.ngDisabled&&L.push(a.$parent.$watch(f(c.ngDisabled),function(b){a.disabled=b})),a.$watch(\"isOpen\",function(d){d?a.disabled?a.isOpen=!1:n(function(){v(),A&&a.$broadcast(\"uib:datepicker.focus\"),h.on(\"click\",t);var d=c.popupPlacement?c.popupPlacement:m.placement;z||j.parsePlacement(d)[2]?(F=F||angular.element(j.scrollParent(b)),F&&F.on(\"scroll\",v)):F=null,angular.element(g).on(\"resize\",v)},0,!1):(h.off(\"click\",t),F&&F.off(\"scroll\",v),angular.element(g).off(\"resize\",v))}),a.$on(\"uib:datepicker.mode\",function(){n(v,0,!1)})}]).directive(\"uibDatepickerPopup\",function(){return{require:[\"ngModel\",\"uibDatepickerPopup\"],controller:\"UibDatepickerPopupController\",scope:{datepickerOptions:\"=?\",isOpen:\"=?\",currentText:\"@\",clearText:\"@\",closeText:\"@\"},link:function(a,b,c,d){var e=d[0],f=d[1];f.init(e)}}}).directive(\"uibDatepickerPopupWrap\",function(){return{restrict:\"A\",transclude:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/datepickerPopup/popup.html\"}}}),angular.module(\"ui.bootstrap.debounce\",[]).factory(\"$$debounce\",[\"$timeout\",function(a){return function(b,c){var d;return function(){var e=this,f=Array.prototype.slice.call(arguments);d&&a.cancel(d),d=a(function(){b.apply(e,f)},c)}}}]),angular.module(\"ui.bootstrap.multiMap\",[]).factory(\"$$multiMap\",function(){return{createNew:function(){var a={};return{entries:function(){return Object.keys(a).map(function(b){return{key:b,value:a[b]}})},get:function(b){return a[b]},hasKey:function(b){return!!a[b]},keys:function(){return Object.keys(a)},put:function(b,c){a[b]||(a[b]=[]),a[b].push(c)},remove:function(b,c){var d=a[b];if(d){var e=d.indexOf(c);-1!==e&&d.splice(e,1),d.length||delete a[b]}}}}}}),angular.module(\"ui.bootstrap.dropdown\",[\"ui.bootstrap.multiMap\",\"ui.bootstrap.position\"]).constant(\"uibDropdownConfig\",{appendToOpenClass:\"uib-dropdown-open\",openClass:\"open\"}).service(\"uibDropdownService\",[\"$document\",\"$rootScope\",\"$$multiMap\",function(a,b,c){var d=null,e=c.createNew();this.isOnlyOpen=function(a,b){var c=e.get(b);if(c){var d=c.reduce(function(b,c){return c.scope===a?c:b},{});if(d)return 1===c.length}return!1},this.open=function(b,c,g){if(d||a.on(\"click\",f),d&&d!==b&&(d.isOpen=!1),d=b,g){var h=e.get(g);if(h){var i=h.map(function(a){return a.scope});-1===i.indexOf(b)&&e.put(g,{scope:b})}else e.put(g,{scope:b})}},this.close=function(b,c,g){if(d===b&&(a.off(\"click\",f),a.off(\"keydown\",this.keybindFilter),d=null),g){var h=e.get(g);if(h){var i=h.reduce(function(a,c){return c.scope===b?c:a},{});i&&e.remove(g,i)}}};var f=function(a){if(d&&d.isOpen&&!(a&&\"disabled\"===d.getAutoClose()||a&&3===a.which)){var c=d.getToggleElement();if(!(a&&c&&c[0].contains(a.target))){var e=d.getDropdownElement();a&&\"outsideClick\"===d.getAutoClose()&&e&&e[0].contains(a.target)||(d.focusToggleElement(),d.isOpen=!1,b.$$phase||d.$apply())}}};this.keybindFilter=function(a){if(d){var b=d.getDropdownElement(),c=d.getToggleElement(),e=b&&b[0].contains(a.target),g=c&&c[0].contains(a.target);27===a.which?(a.stopPropagation(),d.focusToggleElement(),f()):d.isKeynavEnabled()&&-1!==[38,40].indexOf(a.which)&&d.isOpen&&(e||g)&&(a.preventDefault(),a.stopPropagation(),d.focusDropdownEntry(a.which))}}}]).controller(\"UibDropdownController\",[\"$scope\",\"$element\",\"$attrs\",\"$parse\",\"uibDropdownConfig\",\"uibDropdownService\",\"$animate\",\"$uibPosition\",\"$document\",\"$compile\",\"$templateRequest\",function(a,b,c,d,e,f,g,h,i,j,k){function l(){b.append(o.dropdownMenu)}var m,n,o=this,p=a.$new(),q=e.appendToOpenClass,r=e.openClass,s=angular.noop,t=c.onToggle?d(c.onToggle):angular.noop,u=!1,v=i.find(\"body\");b.addClass(\"dropdown\"),this.init=function(){c.isOpen&&(n=d(c.isOpen),s=n.assign,a.$watch(n,function(a){p.isOpen=!!a})),u=angular.isDefined(c.keyboardNav)},this.toggle=function(a){return p.isOpen=arguments.length?!!a:!p.isOpen,angular.isFunction(s)&&s(p,p.isOpen),p.isOpen},this.isOpen=function(){return p.isOpen},p.getToggleElement=function(){return o.toggleElement},p.getAutoClose=function(){return c.autoClose||\"always\"},p.getElement=function(){return b},p.isKeynavEnabled=function(){return u},p.focusDropdownEntry=function(a){var c=o.dropdownMenu?angular.element(o.dropdownMenu).find(\"a\"):b.find(\"ul\").eq(0).find(\"a\");switch(a){case 40:angular.isNumber(o.selectedOption)?o.selectedOption=o.selectedOption===c.length-1?o.selectedOption:o.selectedOption+1:o.selectedOption=0;break;case 38:angular.isNumber(o.selectedOption)?o.selectedOption=0===o.selectedOption?0:o.selectedOption-1:o.selectedOption=c.length-1}c[o.selectedOption].focus()},p.getDropdownElement=function(){return o.dropdownMenu},p.focusToggleElement=function(){o.toggleElement&&o.toggleElement[0].focus()},p.$watch(\"isOpen\",function(e,n){var u=null,w=!1;if(angular.isDefined(c.dropdownAppendTo)){var x=d(c.dropdownAppendTo)(p);x&&(u=angular.element(x))}if(angular.isDefined(c.dropdownAppendToBody)){var y=d(c.dropdownAppendToBody)(p);y!==!1&&(w=!0)}if(w&&!u&&(u=v),u&&o.dropdownMenu&&(e?(u.append(o.dropdownMenu),b.on(\"$destroy\",l)):(b.off(\"$destroy\",l),l())),u&&o.dropdownMenu){var z,A,B,C=h.positionElements(b,o.dropdownMenu,\"bottom-left\",!0),D=0;if(z={top:C.top+\"px\",display:e?\"block\":\"none\"},A=o.dropdownMenu.hasClass(\"dropdown-menu-right\"),A?(z.left=\"auto\",B=h.scrollbarPadding(u),B.heightOverflow&&B.scrollbarWidth&&(D=B.scrollbarWidth),z.right=window.innerWidth-D-(C.left+b.prop(\"offsetWidth\"))+\"px\"):(z.left=C.left+\"px\",z.right=\"auto\"),!w){var E=h.offset(u);z.top=C.top-E.top+\"px\",A?z.right=window.innerWidth-(C.left-E.left+b.prop(\"offsetWidth\"))+\"px\":z.left=C.left-E.left+\"px\"}o.dropdownMenu.css(z)}var F=u?u:b,G=u?q:r,H=F.hasClass(G),I=f.isOnlyOpen(a,u);if(H===!e){var J;J=u?I?\"removeClass\":\"addClass\":e?\"addClass\":\"removeClass\",g[J](F,G).then(function(){angular.isDefined(e)&&e!==n&&t(a,{open:!!e})})}if(e)o.dropdownMenuTemplateUrl?k(o.dropdownMenuTemplateUrl).then(function(a){m=p.$new(),j(a.trim())(m,function(a){var b=a;o.dropdownMenu.replaceWith(b),o.dropdownMenu=b,i.on(\"keydown\",f.keybindFilter)})}):i.on(\"keydown\",f.keybindFilter),p.focusToggleElement(),f.open(p,b,u);else{if(f.close(p,b,u),o.dropdownMenuTemplateUrl){m&&m.$destroy();var K=angular.element('<ul class=\"dropdown-menu\"></ul>');o.dropdownMenu.replaceWith(K),o.dropdownMenu=K}o.selectedOption=null}angular.isFunction(s)&&s(a,e)})}]).directive(\"uibDropdown\",function(){return{controller:\"UibDropdownController\",link:function(a,b,c,d){d.init()}}}).directive(\"uibDropdownMenu\",function(){return{restrict:\"A\",require:\"?^uibDropdown\",link:function(a,b,c,d){if(d&&!angular.isDefined(c.dropdownNested)){b.addClass(\"dropdown-menu\");var e=c.templateUrl;e&&(d.dropdownMenuTemplateUrl=e),d.dropdownMenu||(d.dropdownMenu=b)}}}}).directive(\"uibDropdownToggle\",function(){return{require:\"?^uibDropdown\",link:function(a,b,c,d){if(d){b.addClass(\"dropdown-toggle\"),d.toggleElement=b;var e=function(e){e.preventDefault(),b.hasClass(\"disabled\")||c.disabled||a.$apply(function(){d.toggle()})};b.on(\"click\",e),b.attr({\"aria-haspopup\":!0,\"aria-expanded\":!1}),a.$watch(d.isOpen,function(a){b.attr(\"aria-expanded\",!!a)}),a.$on(\"$destroy\",function(){b.off(\"click\",e)})}}}}),angular.module(\"ui.bootstrap.stackedMap\",[]).factory(\"$$stackedMap\",function(){return{createNew:function(){var a=[];return{add:function(b,c){a.push({key:b,value:c})},get:function(b){for(var c=0;c<a.length;c++)if(b===a[c].key)return a[c]},keys:function(){for(var b=[],c=0;c<a.length;c++)b.push(a[c].key);return b},top:function(){return a[a.length-1]},remove:function(b){for(var c=-1,d=0;d<a.length;d++)if(b===a[d].key){c=d;break}return a.splice(c,1)[0]},removeTop:function(){return a.pop()},length:function(){return a.length}}}}}),angular.module(\"ui.bootstrap.modal\",[\"ui.bootstrap.multiMap\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.position\"]).provider(\"$uibResolve\",function(){var a=this;this.resolver=null,this.setResolver=function(a){this.resolver=a},this.$get=[\"$injector\",\"$q\",function(b,c){var d=a.resolver?b.get(a.resolver):null;return{resolve:function(a,e,f,g){if(d)return d.resolve(a,e,f,g);var h=[];return angular.forEach(a,function(a){angular.isFunction(a)||angular.isArray(a)?h.push(c.resolve(b.invoke(a))):angular.isString(a)?h.push(c.resolve(b.get(a))):h.push(c.resolve(a))}),c.all(h).then(function(b){var c={},d=0;return angular.forEach(a,function(a,e){c[e]=b[d++]}),c})}}}]}).directive(\"uibModalBackdrop\",[\"$animate\",\"$injector\",\"$uibModalStack\",function(a,b,c){function d(b,d,e){e.modalInClass&&(a.addClass(d,e.modalInClass),b.$on(c.NOW_CLOSING_EVENT,function(c,f){var g=f();b.modalOptions.animation?a.removeClass(d,e.modalInClass).then(g):g()}))}return{restrict:\"A\",compile:function(a,b){return a.addClass(b.backdropClass),d}}}]).directive(\"uibModalWindow\",[\"$uibModalStack\",\"$q\",\"$animateCss\",\"$document\",function(a,b,c,d){return{scope:{index:\"@\"},restrict:\"A\",transclude:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/modal/window.html\"},link:function(e,f,g){f.addClass(g.windowTopClass||\"\"),e.size=g.size,e.close=function(b){var c=a.getTop();c&&c.value.backdrop&&\"static\"!==c.value.backdrop&&b.target===b.currentTarget&&(b.preventDefault(),b.stopPropagation(),a.dismiss(c.key,\"backdrop click\"))},f.on(\"click\",e.close),e.$isRendered=!0;var h=b.defer();e.$$postDigest(function(){h.resolve()}),h.promise.then(function(){var h=null;g.modalInClass&&(h=c(f,{addClass:g.modalInClass}).start(),e.$on(a.NOW_CLOSING_EVENT,function(a,b){var d=b();c(f,{removeClass:g.modalInClass}).start().then(d)})),b.when(h).then(function(){var b=a.getTop();if(b&&a.modalRendered(b.key),!d[0].activeElement||!f[0].contains(d[0].activeElement)){var c=f[0].querySelector(\"[autofocus]\");c?c.focus():f[0].focus()}})})}}}]).directive(\"uibModalAnimationClass\",function(){return{compile:function(a,b){b.modalAnimation&&a.addClass(b.uibModalAnimationClass)}}}).directive(\"uibModalTransclude\",[\"$animate\",function(a){return{link:function(b,c,d,e,f){f(b.$parent,function(b){c.empty(),a.enter(b,c)})}}}]).factory(\"$uibModalStack\",[\"$animate\",\"$animateCss\",\"$document\",\"$compile\",\"$rootScope\",\"$q\",\"$$multiMap\",\"$$stackedMap\",\"$uibPosition\",function(a,b,c,d,e,f,g,h,i){function j(a){var b=\"-\";return a.replace(E,function(a,c){return(c?b:\"\")+a.toLowerCase()})}function k(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)}function l(){for(var a=-1,b=x.keys(),c=0;c<b.length;c++)x.get(b[c]).value.backdrop&&(a=c);return a>-1&&A>a&&(a=A),a}function m(a,b){var c=x.get(a).value,d=c.appendTo;x.remove(a),B=x.top(),B&&(A=parseInt(B.value.modalDomEl.attr(\"index\"),10)),p(c.modalDomEl,c.modalScope,function(){var b=c.openedClass||w;y.remove(b,a);var e=y.hasKey(b);d.toggleClass(b,e),!e&&v&&v.heightOverflow&&v.scrollbarWidth&&(v.originalRight?d.css({paddingRight:v.originalRight+\"px\"}):d.css({paddingRight:\"\"}),v=null),n(!0)},c.closedDeferred),o(),b&&b.focus?b.focus():d.focus&&d.focus()}function n(a){var b;x.length()>0&&(b=x.top().value,b.modalDomEl.toggleClass(b.windowTopClass||\"\",a))}function o(){if(t&&-1===l()){var a=u;p(t,u,function(){a=null}),t=void 0,u=void 0}}function p(b,c,d,e){function g(){g.done||(g.done=!0,a.leave(b).then(function(){d&&d(),b.remove(),e&&e.resolve()}),c.$destroy())}var h,i=null,j=function(){return h||(h=f.defer(),i=h.promise),function(){h.resolve()}};return c.$broadcast(z.NOW_CLOSING_EVENT,j),f.when(i).then(g)}function q(a){if(a.isDefaultPrevented())return a;var b=x.top();if(b)switch(a.which){case 27:b.value.keyboard&&(a.preventDefault(),e.$apply(function(){z.dismiss(b.key,\"escape key press\")}));break;case 9:var c=z.loadFocusElementList(b),d=!1;a.shiftKey?(z.isFocusInFirstItem(a,c)||z.isModalFocused(a,b))&&(d=z.focusLastFocusableElement(c)):z.isFocusInLastItem(a,c)&&(d=z.focusFirstFocusableElement(c)),d&&(a.preventDefault(),a.stopPropagation())}}function r(a,b,c){return!a.value.modalScope.$broadcast(\"modal.closing\",b,c).defaultPrevented}function s(){Array.prototype.forEach.call(document.querySelectorAll(\"[\"+C+\"]\"),function(a){var b=parseInt(a.getAttribute(C),10),c=b-1;a.setAttribute(C,c),c||(a.removeAttribute(C),a.removeAttribute(\"aria-hidden\"))})}var t,u,v,w=\"modal-open\",x=h.createNew(),y=g.createNew(),z={NOW_CLOSING_EVENT:\"modal.stack.now-closing\"},A=0,B=null,C=\"data-bootstrap-modal-aria-hidden-count\",D=\"a[href], area[href], input:not([disabled]):not([tabindex='-1']), button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']), textarea:not([disabled]):not([tabindex='-1']), iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]\",E=/[A-Z]/g;return e.$watch(l,function(a){u&&(u.index=a)}),c.on(\"keydown\",q),e.$on(\"$destroy\",function(){c.off(\"keydown\",q)}),z.open=function(b,f){function g(a){function b(a){var b=a.parent()?a.parent().children():[];return Array.prototype.filter.call(b,function(b){return b!==a[0]})}if(a&&\"BODY\"!==a[0].tagName)return b(a).forEach(function(a){var b=\"true\"===a.getAttribute(\"aria-hidden\"),c=parseInt(a.getAttribute(C),10);c||(c=b?1:0),a.setAttribute(C,c+1),a.setAttribute(\"aria-hidden\",\"true\")}),g(a.parent())}var h=c[0].activeElement,k=f.openedClass||w;n(!1),B=x.top(),x.add(b,{deferred:f.deferred,renderDeferred:f.renderDeferred,closedDeferred:f.closedDeferred,modalScope:f.scope,backdrop:f.backdrop,keyboard:f.keyboard,openedClass:f.openedClass,windowTopClass:f.windowTopClass,animation:f.animation,appendTo:f.appendTo}),y.put(k,b);var m=f.appendTo,o=l();o>=0&&!t&&(u=e.$new(!0),u.modalOptions=f,u.index=o,t=angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>'),t.attr({\"class\":\"modal-backdrop\",\"ng-style\":\"{'z-index': 1040 + (index && 1 || 0) + index*10}\",\"uib-modal-animation-class\":\"fade\",\"modal-in-class\":\"in\"}),f.backdropClass&&t.addClass(f.backdropClass),f.animation&&t.attr(\"modal-animation\",\"true\"),d(t)(u),a.enter(t,m),i.isScrollable(m)&&(v=i.scrollbarPadding(m),v.heightOverflow&&v.scrollbarWidth&&m.css({paddingRight:v.right+\"px\"})));var p;f.component?(p=document.createElement(j(f.component.name)),p=angular.element(p),p.attr({resolve:\"$resolve\",\"modal-instance\":\"$uibModalInstance\",close:\"$close($value)\",dismiss:\"$dismiss($value)\"})):p=f.content,A=B?parseInt(B.value.modalDomEl.attr(\"index\"),10)+1:0;var q=angular.element('<div uib-modal-window=\"modal-window\"></div>');q.attr({\"class\":\"modal\",\"template-url\":f.windowTemplateUrl,\"window-top-class\":f.windowTopClass,role:\"dialog\",\"aria-labelledby\":f.ariaLabelledBy,\"aria-describedby\":f.ariaDescribedBy,size:f.size,index:A,animate:\"animate\",\"ng-style\":\"mgz.getModalStyle($$topModalIndex)\",tabindex:-1,\"uib-modal-animation-class\":\"fade\",\"modal-in-class\":\"in\"}).append(p),f.windowClass&&q.addClass(f.windowClass),f.animation&&q.attr(\"modal-animation\",\"true\"),m.addClass(k),f.scope&&(f.scope.$$topModalIndex=A),a.enter(d(q)(f.scope),m),x.top().value.modalDomEl=q,x.top().value.modalOpener=h,g(q)},z.close=function(a,b){var c=x.get(a);return s(),c&&r(c,b,!0)?(c.value.modalScope.$$uibDestructionScheduled=!0,c.value.deferred.resolve(b),m(a,c.value.modalOpener),!0):!c},z.dismiss=function(a,b){var c=x.get(a);return s(),c&&r(c,b,!1)?(c.value.modalScope.$$uibDestructionScheduled=!0,c.value.deferred.reject(b),m(a,c.value.modalOpener),!0):!c},z.dismissAll=function(a){for(var b=this.getTop();b&&this.dismiss(b.key,a);)b=this.getTop()},z.getTop=function(){return x.top()},z.modalRendered=function(a){var b=x.get(a);b&&b.value.renderDeferred.resolve()},z.focusFirstFocusableElement=function(a){return a.length>0?(a[0].focus(),!0):!1},z.focusLastFocusableElement=function(a){return a.length>0?(a[a.length-1].focus(),!0):!1},z.isModalFocused=function(a,b){if(a&&b){var c=b.value.modalDomEl;if(c&&c.length)return(a.target||a.srcElement)===c[0]}return!1},z.isFocusInFirstItem=function(a,b){return b.length>0?(a.target||a.srcElement)===b[0]:!1},z.isFocusInLastItem=function(a,b){return b.length>0?(a.target||a.srcElement)===b[b.length-1]:!1},z.loadFocusElementList=function(a){if(a){var b=a.value.modalDomEl;if(b&&b.length){var c=b[0].querySelectorAll(D);return c?Array.prototype.filter.call(c,function(a){return k(a)}):c}}},z}]).provider(\"$uibModal\",function(){var a={options:{animation:!0,backdrop:!0,keyboard:!0},$get:[\"$rootScope\",\"$q\",\"$document\",\"$templateRequest\",\"$controller\",\"$uibResolve\",\"$uibModalStack\",function(b,c,d,e,f,g,h){function i(a){return a.template?c.when(a.template):e(angular.isFunction(a.templateUrl)?a.templateUrl():a.templateUrl)}var j={},k=null;return j.getPromiseChain=function(){return k},j.open=function(e){function j(){return q}var l=c.defer(),m=c.defer(),n=c.defer(),o=c.defer(),p={result:l.promise,opened:m.promise,closed:n.promise,rendered:o.promise,close:function(a){return h.close(p,a)},dismiss:function(a){return h.dismiss(p,a)}};if(e=angular.extend({},a.options,e),e.resolve=e.resolve||{},e.appendTo=e.appendTo||d.find(\"body\").eq(0),!e.appendTo.length)throw new Error(\"appendTo element not found. Make sure that the element passed is in DOM.\");if(!e.component&&!e.template&&!e.templateUrl)throw new Error(\"One of component or template or templateUrl options is required.\");var q;q=e.component?c.when(g.resolve(e.resolve,{},null,null)):c.all([i(e),g.resolve(e.resolve,{},null,null)]);var r;return r=k=c.all([k]).then(j,j).then(function(a){function c(b,c,d,e){b.$scope=g,b.$scope.$resolve={},d?b.$scope.$uibModalInstance=p:b.$uibModalInstance=p;var f=c?a[1]:a;angular.forEach(f,function(a,c){e&&(b[c]=a),b.$scope.$resolve[c]=a})}var d=e.scope||b,g=d.$new();g.$close=p.close,g.$dismiss=p.dismiss,g.$on(\"$destroy\",function(){g.$$uibDestructionScheduled||g.$dismiss(\"$uibUnscheduledDestruction\")});var i,j,k={scope:g,deferred:l,renderDeferred:o,closedDeferred:n,animation:e.animation,backdrop:e.backdrop,keyboard:e.keyboard,backdropClass:e.backdropClass,windowTopClass:e.windowTopClass,windowClass:e.windowClass,windowTemplateUrl:e.windowTemplateUrl,ariaLabelledBy:e.ariaLabelledBy,ariaDescribedBy:e.ariaDescribedBy,size:e.size,openedClass:e.openedClass,appendTo:e.appendTo},q={},r={};e.component?(c(q,!1,!0,!1),q.name=e.component,k.component=q):e.controller&&(c(r,!0,!1,!0),j=f(e.controller,r,!0,e.controllerAs),e.controllerAs&&e.bindToController&&(i=j.instance,i.$close=g.$close,i.$dismiss=g.$dismiss,angular.extend(i,{$resolve:r.$scope.$resolve},d)),i=j(),angular.isFunction(i.$onInit)&&i.$onInit()),e.component||(k.content=a[0]),h.open(p,k),m.resolve(!0)},function(a){m.reject(a),l.reject(a)})[\"finally\"](function(){k===r&&(k=null)}),p},j}]};return a}),angular.module(\"ui.bootstrap.paging\",[]).factory(\"uibPaging\",[\"$parse\",function(a){return{create:function(b,c,d){b.setNumPages=d.numPages?a(d.numPages).assign:angular.noop,b.ngModelCtrl={$setViewValue:angular.noop},b._watchers=[],b.init=function(a,e){b.ngModelCtrl=a,b.config=e,a.$render=function(){b.render()},d.itemsPerPage?b._watchers.push(c.$parent.$watch(d.itemsPerPage,function(a){\nb.itemsPerPage=parseInt(a,10),c.totalPages=b.calculateTotalPages(),b.updatePage()})):b.itemsPerPage=e.itemsPerPage,c.$watch(\"totalItems\",function(a,d){(angular.isDefined(a)||a!==d)&&(c.totalPages=b.calculateTotalPages(),b.updatePage())})},b.calculateTotalPages=function(){var a=b.itemsPerPage<1?1:Math.ceil(c.totalItems/b.itemsPerPage);return Math.max(a||0,1)},b.render=function(){c.page=parseInt(b.ngModelCtrl.$viewValue,10)||1},c.selectPage=function(a,d){d&&d.preventDefault();var e=!c.ngDisabled||!d;e&&c.page!==a&&a>0&&a<=c.totalPages&&(d&&d.target&&d.target.blur(),b.ngModelCtrl.$setViewValue(a),b.ngModelCtrl.$render())},c.getText=function(a){return c[a+\"Text\"]||b.config[a+\"Text\"]},c.noPrevious=function(){return 1===c.page},c.noNext=function(){return c.page===c.totalPages},b.updatePage=function(){b.setNumPages(c.$parent,c.totalPages),c.page>c.totalPages?c.selectPage(c.totalPages):b.ngModelCtrl.$render()},c.$on(\"$destroy\",function(){for(;b._watchers.length;)b._watchers.shift()()})}}}]),angular.module(\"ui.bootstrap.pager\",[\"ui.bootstrap.paging\",\"ui.bootstrap.tabindex\"]).controller(\"UibPagerController\",[\"$scope\",\"$attrs\",\"uibPaging\",\"uibPagerConfig\",function(a,b,c,d){a.align=angular.isDefined(b.align)?a.$parent.$eval(b.align):d.align,c.create(this,a,b)}]).constant(\"uibPagerConfig\",{itemsPerPage:10,previousText:\"\u00ab Previous\",nextText:\"Next \u00bb\",align:!0}).directive(\"uibPager\",[\"uibPagerConfig\",function(a){return{scope:{totalItems:\"=\",previousText:\"@\",nextText:\"@\",ngDisabled:\"=\"},require:[\"uibPager\",\"?ngModel\"],restrict:\"A\",controller:\"UibPagerController\",controllerAs:\"pager\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/pager/pager.html\"},link:function(b,c,d,e){c.addClass(\"pager\");var f=e[0],g=e[1];g&&f.init(g,a)}}}]),angular.module(\"ui.bootstrap.pagination\",[\"ui.bootstrap.paging\",\"ui.bootstrap.tabindex\"]).controller(\"UibPaginationController\",[\"$scope\",\"$attrs\",\"$parse\",\"uibPaging\",\"uibPaginationConfig\",function(a,b,c,d,e){function f(a,b,c){return{number:a,text:b,active:c}}function g(a,b){var c=[],d=1,e=b,g=angular.isDefined(i)&&b>i;g&&(j?(d=Math.max(a-Math.floor(i/2),1),e=d+i-1,e>b&&(e=b,d=e-i+1)):(d=(Math.ceil(a/i)-1)*i+1,e=Math.min(d+i-1,b)));for(var h=d;e>=h;h++){var n=f(h,m(h),h===a);c.push(n)}if(g&&i>0&&(!j||k||l)){if(d>1){if(!l||d>3){var o=f(d-1,\"...\",!1);c.unshift(o)}if(l){if(3===d){var p=f(2,\"2\",!1);c.unshift(p)}var q=f(1,\"1\",!1);c.unshift(q)}}if(b>e){if(!l||b-2>e){var r=f(e+1,\"...\",!1);c.push(r)}if(l){if(e===b-2){var s=f(b-1,b-1,!1);c.push(s)}var t=f(b,b,!1);c.push(t)}}}return c}var h=this,i=angular.isDefined(b.maxSize)?a.$parent.$eval(b.maxSize):e.maxSize,j=angular.isDefined(b.rotate)?a.$parent.$eval(b.rotate):e.rotate,k=angular.isDefined(b.forceEllipses)?a.$parent.$eval(b.forceEllipses):e.forceEllipses,l=angular.isDefined(b.boundaryLinkNumbers)?a.$parent.$eval(b.boundaryLinkNumbers):e.boundaryLinkNumbers,m=angular.isDefined(b.pageLabel)?function(c){return a.$parent.$eval(b.pageLabel,{$page:c})}:angular.identity;a.boundaryLinks=angular.isDefined(b.boundaryLinks)?a.$parent.$eval(b.boundaryLinks):e.boundaryLinks,a.directionLinks=angular.isDefined(b.directionLinks)?a.$parent.$eval(b.directionLinks):e.directionLinks,b.$set(\"role\",\"menu\"),d.create(this,a,b),b.maxSize&&h._watchers.push(a.$parent.$watch(c(b.maxSize),function(a){i=parseInt(a,10),h.render()}));var n=this.render;this.render=function(){n(),a.page>0&&a.page<=a.totalPages&&(a.pages=g(a.page,a.totalPages))}}]).constant(\"uibPaginationConfig\",{itemsPerPage:10,boundaryLinks:!1,boundaryLinkNumbers:!1,directionLinks:!0,firstText:\"First\",previousText:\"Previous\",nextText:\"Next\",lastText:\"Last\",rotate:!0,forceEllipses:!1}).directive(\"uibPagination\",[\"$parse\",\"uibPaginationConfig\",function(a,b){return{scope:{totalItems:\"=\",firstText:\"@\",previousText:\"@\",nextText:\"@\",lastText:\"@\",ngDisabled:\"=\"},require:[\"uibPagination\",\"?ngModel\"],restrict:\"A\",controller:\"UibPaginationController\",controllerAs:\"pagination\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/pagination/pagination.html\"},link:function(a,c,d,e){c.addClass(\"pagination\");var f=e[0],g=e[1];g&&f.init(g,b)}}}]),angular.module(\"ui.bootstrap.tooltip\",[\"ui.bootstrap.position\",\"ui.bootstrap.stackedMap\"]).provider(\"$uibTooltip\",function(){function a(a){var b=/[A-Z]/g,c=\"-\";return a.replace(b,function(a,b){return(b?c:\"\")+a.toLowerCase()})}var b={placement:\"top\",placementClassPrefix:\"\",animation:!0,popupDelay:0,popupCloseDelay:0,useContentExp:!1},c={mouseenter:\"mouseleave\",click:\"click\",outsideClick:\"outsideClick\",focus:\"blur\",none:\"\"},d={};this.options=function(a){angular.extend(d,a)},this.setTriggers=function(a){angular.extend(c,a)},this.$get=[\"$window\",\"$compile\",\"$timeout\",\"$document\",\"$uibPosition\",\"$interpolate\",\"$rootScope\",\"$parse\",\"$$stackedMap\",function(e,f,g,h,i,j,k,l,m){function n(a){if(27===a.which){var b=o.top();b&&(b.value.close(),b=null)}}var o=m.createNew();return h.on(\"keyup\",n),k.$on(\"$destroy\",function(){h.off(\"keyup\",n)}),function(e,k,m,n){function p(a){var b=(a||n.trigger||m).split(\" \"),d=b.map(function(a){return c[a]||a});return{show:b,hide:d}}n=angular.extend({},b,d,n);var q=a(e),r=j.startSymbol(),s=j.endSymbol(),t=\"<div \"+q+'-popup uib-title=\"'+r+\"title\"+s+'\" '+(n.useContentExp?'content-exp=\"contentExp()\" ':'content=\"'+r+\"content\"+s+'\" ')+'origin-scope=\"origScope\" class=\"uib-position-measure '+k+'\" tooltip-animation-class=\"fade\"uib-tooltip-classes ng-class=\"{ in: isOpen }\" ></div>';return{compile:function(a,b){var c=f(t);return function(a,b,d,f){function j(){P.isOpen?q():m()}function m(){O&&!a.$eval(d[k+\"Enable\"])||(u(),x(),P.popupDelay?H||(H=g(r,P.popupDelay,!1)):r())}function q(){s(),P.popupCloseDelay?I||(I=g(t,P.popupCloseDelay,!1)):t()}function r(){return s(),u(),P.content?(v(),void P.$evalAsync(function(){P.isOpen=!0,y(!0),U()})):angular.noop}function s(){H&&(g.cancel(H),H=null),J&&(g.cancel(J),J=null)}function t(){P&&P.$evalAsync(function(){P&&(P.isOpen=!1,y(!1),P.animation?G||(G=g(w,150,!1)):w())})}function u(){I&&(g.cancel(I),I=null),G&&(g.cancel(G),G=null)}function v(){E||(F=P.$new(),E=c(F,function(a){M?h.find(\"body\").append(a):b.after(a)}),o.add(P,{close:t}),z())}function w(){s(),u(),A(),E&&(E.remove(),E=null,K&&g.cancel(K)),o.remove(P),F&&(F.$destroy(),F=null)}function x(){P.title=d[k+\"Title\"],S?P.content=S(a):P.content=d[e],P.popupClass=d[k+\"Class\"],P.placement=angular.isDefined(d[k+\"Placement\"])?d[k+\"Placement\"]:n.placement;var b=i.parsePlacement(P.placement);L=b[1]?b[0]+\"-\"+b[1]:b[0];var c=parseInt(d[k+\"PopupDelay\"],10),f=parseInt(d[k+\"PopupCloseDelay\"],10);P.popupDelay=isNaN(c)?n.popupDelay:c,P.popupCloseDelay=isNaN(f)?n.popupCloseDelay:f}function y(b){R&&angular.isFunction(R.assign)&&R.assign(a,b)}function z(){T.length=0,S?(T.push(a.$watch(S,function(a){P.content=a,!a&&P.isOpen&&t()})),T.push(F.$watch(function(){Q||(Q=!0,F.$$postDigest(function(){Q=!1,P&&P.isOpen&&U()}))}))):T.push(d.$observe(e,function(a){P.content=a,!a&&P.isOpen?t():U()})),T.push(d.$observe(k+\"Title\",function(a){P.title=a,P.isOpen&&U()})),T.push(d.$observe(k+\"Placement\",function(a){P.placement=a?a:n.placement,P.isOpen&&U()}))}function A(){T.length&&(angular.forEach(T,function(a){a()}),T.length=0)}function B(a){P&&P.isOpen&&E&&(b[0].contains(a.target)||E[0].contains(a.target)||q())}function C(a){27===a.which&&q()}function D(){var c=[],e=[],f=a.$eval(d[k+\"Trigger\"]);V(),angular.isObject(f)?(Object.keys(f).forEach(function(a){c.push(a),e.push(f[a])}),N={show:c,hide:e}):N=p(f),\"none\"!==N.show&&N.show.forEach(function(a,c){\"outsideClick\"===a?(b.on(\"click\",j),h.on(\"click\",B)):a===N.hide[c]?b.on(a,j):a&&(b.on(a,m),b.on(N.hide[c],q)),b.on(\"keypress\",C)})}var E,F,G,H,I,J,K,L,M=angular.isDefined(n.appendToBody)?n.appendToBody:!1,N=p(void 0),O=angular.isDefined(d[k+\"Enable\"]),P=a.$new(!0),Q=!1,R=angular.isDefined(d[k+\"IsOpen\"])?l(d[k+\"IsOpen\"]):!1,S=n.useContentExp?l(d[e]):!1,T=[],U=function(){E&&E.html()&&(J||(J=g(function(){var a=i.positionElements(b,E,P.placement,M),c=angular.isDefined(E.offsetHeight)?E.offsetHeight:E.prop(\"offsetHeight\"),d=M?i.offset(b):i.position(b);E.css({top:a.top+\"px\",left:a.left+\"px\"});var e=a.placement.split(\"-\");E.hasClass(e[0])||(E.removeClass(L.split(\"-\")[0]),E.addClass(e[0])),E.hasClass(n.placementClassPrefix+a.placement)||(E.removeClass(n.placementClassPrefix+L),E.addClass(n.placementClassPrefix+a.placement)),K=g(function(){var a=angular.isDefined(E.offsetHeight)?E.offsetHeight:E.prop(\"offsetHeight\"),b=i.adjustTop(e,d,c,a);b&&E.css(b),K=null},0,!1),E.hasClass(\"uib-position-measure\")?(i.positionArrow(E,a.placement),E.removeClass(\"uib-position-measure\")):L!==a.placement&&i.positionArrow(E,a.placement),L=a.placement,J=null},0,!1)))};P.origScope=a,P.isOpen=!1,P.contentExp=function(){return P.content},d.$observe(\"disabled\",function(a){a&&s(),a&&P.isOpen&&t()}),R&&a.$watch(R,function(a){P&&!a===P.isOpen&&j()});var V=function(){N.show.forEach(function(a){\"outsideClick\"===a?b.off(\"click\",j):(b.off(a,m),b.off(a,j)),b.off(\"keypress\",C)}),N.hide.forEach(function(a){\"outsideClick\"===a?h.off(\"click\",B):b.off(a,q)})};D();var W=a.$eval(d[k+\"Animation\"]);P.animation=angular.isDefined(W)?!!W:n.animation;var X,Y=k+\"AppendToBody\";X=Y in d&&void 0===d[Y]?!0:a.$eval(d[Y]),M=angular.isDefined(X)?X:M,a.$on(\"$destroy\",function(){V(),w(),P=null})}}}}}]}).directive(\"uibTooltipTemplateTransclude\",[\"$animate\",\"$sce\",\"$compile\",\"$templateRequest\",function(a,b,c,d){return{link:function(e,f,g){var h,i,j,k=e.$eval(g.tooltipTemplateTranscludeScope),l=0,m=function(){i&&(i.remove(),i=null),h&&(h.$destroy(),h=null),j&&(a.leave(j).then(function(){i=null}),i=j,j=null)};e.$watch(b.parseAsResourceUrl(g.uibTooltipTemplateTransclude),function(b){var g=++l;b?(d(b,!0).then(function(d){if(g===l){var e=k.$new(),i=d,n=c(i)(e,function(b){m(),a.enter(b,f)});h=e,j=n,h.$emit(\"$includeContentLoaded\",b)}},function(){g===l&&(m(),e.$emit(\"$includeContentError\",b))}),e.$emit(\"$includeContentRequested\",b)):m()}),e.$on(\"$destroy\",m)}}}]).directive(\"uibTooltipClasses\",[\"$uibPosition\",function(a){return{restrict:\"A\",link:function(b,c,d){if(b.placement){var e=a.parsePlacement(b.placement);c.addClass(e[0])}b.popupClass&&c.addClass(b.popupClass),b.animation&&c.addClass(d.tooltipAnimationClass)}}}]).directive(\"uibTooltipPopup\",function(){return{restrict:\"A\",scope:{content:\"@\"},templateUrl:\"uib/template/tooltip/tooltip-popup.html\"}}).directive(\"uibTooltip\",[\"$uibTooltip\",function(a){return a(\"uibTooltip\",\"tooltip\",\"mouseenter\")}]).directive(\"uibTooltipTemplatePopup\",function(){return{restrict:\"A\",scope:{contentExp:\"&\",originScope:\"&\"},templateUrl:\"uib/template/tooltip/tooltip-template-popup.html\"}}).directive(\"uibTooltipTemplate\",[\"$uibTooltip\",function(a){return a(\"uibTooltipTemplate\",\"tooltip\",\"mouseenter\",{useContentExp:!0})}]).directive(\"uibTooltipHtmlPopup\",function(){return{restrict:\"A\",scope:{contentExp:\"&\"},templateUrl:\"uib/template/tooltip/tooltip-html-popup.html\"}}).directive(\"uibTooltipHtml\",[\"$uibTooltip\",function(a){return a(\"uibTooltipHtml\",\"tooltip\",\"mouseenter\",{useContentExp:!0})}]),angular.module(\"ui.bootstrap.popover\",[\"ui.bootstrap.tooltip\"]).directive(\"uibPopoverTemplatePopup\",function(){return{restrict:\"A\",scope:{uibTitle:\"@\",contentExp:\"&\",originScope:\"&\"},templateUrl:\"uib/template/popover/popover-template.html\"}}).directive(\"uibPopoverTemplate\",[\"$uibTooltip\",function(a){return a(\"uibPopoverTemplate\",\"popover\",\"click\",{useContentExp:!0})}]).directive(\"uibPopoverHtmlPopup\",function(){return{restrict:\"A\",scope:{contentExp:\"&\",uibTitle:\"@\"},templateUrl:\"uib/template/popover/popover-html.html\"}}).directive(\"uibPopoverHtml\",[\"$uibTooltip\",function(a){return a(\"uibPopoverHtml\",\"popover\",\"click\",{useContentExp:!0})}]).directive(\"uibPopoverPopup\",function(){return{restrict:\"A\",scope:{uibTitle:\"@\",content:\"@\"},templateUrl:\"uib/template/popover/popover.html\"}}).directive(\"uibPopover\",[\"$uibTooltip\",function(a){return a(\"uibPopover\",\"popover\",\"click\")}]),angular.module(\"ui.bootstrap.progressbar\",[]).constant(\"uibProgressConfig\",{animate:!0,max:100}).controller(\"UibProgressController\",[\"$scope\",\"$attrs\",\"uibProgressConfig\",function(a,b,c){function d(){return angular.isDefined(a.maxParam)?a.maxParam:c.max}var e=this,f=angular.isDefined(b.animate)?a.$parent.$eval(b.animate):c.animate;this.bars=[],a.max=d(),this.addBar=function(a,b,c){f||b.css({transition:\"none\"}),this.bars.push(a),a.max=d(),a.title=c&&angular.isDefined(c.title)?c.title:\"progressbar\",a.$watch(\"value\",function(b){a.recalculatePercentage()}),a.recalculatePercentage=function(){var b=e.bars.reduce(function(a,b){return b.percent=+(100*b.value/b.max).toFixed(2),a+b.percent},0);b>100&&(a.percent-=b-100)},a.$on(\"$destroy\",function(){b=null,e.removeBar(a)})},this.removeBar=function(a){this.bars.splice(this.bars.indexOf(a),1),this.bars.forEach(function(a){a.recalculatePercentage()})},a.$watch(\"maxParam\",function(a){e.bars.forEach(function(a){a.max=d(),a.recalculatePercentage()})})}]).directive(\"uibProgress\",function(){return{replace:!0,transclude:!0,controller:\"UibProgressController\",require:\"uibProgress\",scope:{maxParam:\"=?max\"},templateUrl:\"uib/template/progressbar/progress.html\"}}).directive(\"uibBar\",function(){return{replace:!0,transclude:!0,require:\"^uibProgress\",scope:{value:\"=\",type:\"@\"},templateUrl:\"uib/template/progressbar/bar.html\",link:function(a,b,c,d){d.addBar(a,b,c)}}}).directive(\"uibProgressbar\",function(){return{replace:!0,transclude:!0,controller:\"UibProgressController\",scope:{value:\"=\",maxParam:\"=?max\",type:\"@\"},templateUrl:\"uib/template/progressbar/progressbar.html\",link:function(a,b,c,d){d.addBar(a,angular.element(b.children()[0]),{title:c.title})}}}),angular.module(\"ui.bootstrap.rating\",[]).constant(\"uibRatingConfig\",{max:5,stateOn:null,stateOff:null,enableReset:!0,titles:[\"one\",\"two\",\"three\",\"four\",\"five\"]}).controller(\"UibRatingController\",[\"$scope\",\"$attrs\",\"uibRatingConfig\",function(a,b,c){var d={$setViewValue:angular.noop},e=this;this.init=function(e){d=e,d.$render=this.render,d.$formatters.push(function(a){return angular.isNumber(a)&&a<<0!==a&&(a=Math.round(a)),a}),this.stateOn=angular.isDefined(b.stateOn)?a.$parent.$eval(b.stateOn):c.stateOn,this.stateOff=angular.isDefined(b.stateOff)?a.$parent.$eval(b.stateOff):c.stateOff,this.enableReset=angular.isDefined(b.enableReset)?a.$parent.$eval(b.enableReset):c.enableReset;var f=angular.isDefined(b.titles)?a.$parent.$eval(b.titles):c.titles;this.titles=angular.isArray(f)&&f.length>0?f:c.titles;var g=angular.isDefined(b.ratingStates)?a.$parent.$eval(b.ratingStates):new Array(angular.isDefined(b.max)?a.$parent.$eval(b.max):c.max);a.range=this.buildTemplateObjects(g)},this.buildTemplateObjects=function(a){for(var b=0,c=a.length;c>b;b++)a[b]=angular.extend({index:b},{stateOn:this.stateOn,stateOff:this.stateOff,title:this.getTitle(b)},a[b]);return a},this.getTitle=function(a){return a>=this.titles.length?a+1:this.titles[a]},a.rate=function(b){if(!a.readonly&&b>=0&&b<=a.range.length){var c=e.enableReset&&d.$viewValue===b?0:b;d.$setViewValue(c),d.$render()}},a.enter=function(b){a.readonly||(a.value=b),a.onHover({value:b})},a.reset=function(){a.value=d.$viewValue,a.onLeave()},a.onKeydown=function(b){/(37|38|39|40)/.test(b.which)&&(b.preventDefault(),b.stopPropagation(),a.rate(a.value+(38===b.which||39===b.which?1:-1)))},this.render=function(){a.value=d.$viewValue,a.title=e.getTitle(a.value-1)}}]).directive(\"uibRating\",function(){return{require:[\"uibRating\",\"ngModel\"],restrict:\"A\",scope:{readonly:\"=?readOnly\",onHover:\"&\",onLeave:\"&\"},controller:\"UibRatingController\",templateUrl:\"uib/template/rating/rating.html\",link:function(a,b,c,d){var e=d[0],f=d[1];e.init(f)}}}),angular.module(\"ui.bootstrap.tabs\",[]).controller(\"UibTabsetController\",[\"$scope\",function(a){function b(a){for(var b=0;b<d.tabs.length;b++)if(d.tabs[b].index===a)return b}var c,d=this;d.tabs=[],d.select=function(a,f){if(!e){var g=b(c),h=d.tabs[g];if(h){if(h.tab.onDeselect({$event:f,$selectedIndex:a}),f&&f.isDefaultPrevented())return;h.tab.active=!1}var i=d.tabs[a];i?(i.tab.onSelect({$event:f}),i.tab.active=!0,d.active=i.index,c=i.index):!i&&angular.isDefined(c)&&(d.active=null,c=null)}},d.addTab=function(a){if(d.tabs.push({tab:a,index:a.index}),d.tabs.sort(function(a,b){return a.index>b.index?1:a.index<b.index?-1:0}),a.index===d.active||!angular.isDefined(d.active)&&1===d.tabs.length){var c=b(a.index);d.select(c)}},d.removeTab=function(a){for(var b,c=0;c<d.tabs.length;c++)if(d.tabs[c].tab===a){b=c;break}if(d.tabs[b].index===d.active){var e=b===d.tabs.length-1?b-1:b+1%d.tabs.length;d.select(e)}d.tabs.splice(b,1)},a.$watch(\"tabset.active\",function(a){angular.isDefined(a)&&a!==c&&d.select(b(a))});var e;a.$on(\"$destroy\",function(){e=!0})}]).directive(\"uibTabset\",function(){return{transclude:!0,replace:!0,scope:{},bindToController:{active:\"=?\",type:\"@\"},controller:\"UibTabsetController\",controllerAs:\"tabset\",templateUrl:function(a,b){return b.templateUrl||\"uib/template/tabs/tabset.html\"},link:function(a,b,c){a.vertical=angular.isDefined(c.vertical)?a.$parent.$eval(c.vertical):!1,a.justified=angular.isDefined(c.justified)?a.$parent.$eval(c.justified):!1}}}).directive(\"uibTab\",[\"$parse\",function(a){return{require:\"^uibTabset\",replace:!0,templateUrl:function(a,b){return b.templateUrl||\"uib/template/tabs/tab.html\"},transclude:!0,scope:{heading:\"@\",index:\"=?\",classes:\"@?\",onSelect:\"&select\",onDeselect:\"&deselect\"},controller:function(){},controllerAs:\"tab\",link:function(b,c,d,e,f){b.disabled=!1,d.disable&&b.$parent.$watch(a(d.disable),function(a){b.disabled=!!a}),angular.isUndefined(d.index)&&(e.tabs&&e.tabs.length?b.index=Math.max.apply(null,e.tabs.map(function(a){return a.index}))+1:b.index=0),angular.isUndefined(d.classes)&&(b.classes=\"\"),b.select=function(a){if(!b.disabled){for(var c,d=0;d<e.tabs.length;d++)if(e.tabs[d].tab===b){c=d;break}e.select(c,a)}},e.addTab(b),b.$on(\"$destroy\",function(){e.removeTab(b)}),b.$transcludeFn=f}}}]).directive(\"uibTabHeadingTransclude\",function(){return{restrict:\"A\",require:\"^uibTab\",link:function(a,b){a.$watch(\"headingElement\",function(a){a&&(b.html(\"\"),b.append(a))})}}}).directive(\"uibTabContentTransclude\",function(){function a(a){return a.tagName&&(a.hasAttribute(\"uib-tab-heading\")||a.hasAttribute(\"data-uib-tab-heading\")||a.hasAttribute(\"x-uib-tab-heading\")||\"uib-tab-heading\"===a.tagName.toLowerCase()||\"data-uib-tab-heading\"===a.tagName.toLowerCase()||\"x-uib-tab-heading\"===a.tagName.toLowerCase()||\"uib:tab-heading\"===a.tagName.toLowerCase())}return{restrict:\"A\",require:\"^uibTabset\",link:function(b,c,d){var e=b.$eval(d.uibTabContentTransclude).tab;e.$transcludeFn(e.$parent,function(b){angular.forEach(b,function(b){a(b)?e.headingElement=b:c.append(b)})})}}}),angular.module(\"ui.bootstrap.timepicker\",[]).constant(\"uibTimepickerConfig\",{hourStep:1,minuteStep:1,secondStep:1,showMeridian:!0,showSeconds:!1,meridians:null,readonlyInput:!1,mousewheel:!0,arrowkeys:!0,showSpinners:!0,templateUrl:\"uib/template/timepicker/timepicker.html\"}).controller(\"UibTimepickerController\",[\"$scope\",\"$element\",\"$attrs\",\"$parse\",\"$log\",\"$locale\",\"uibTimepickerConfig\",function(a,b,c,d,e,f,g){function h(){var b=+a.hours,c=a.showMeridian?b>0&&13>b:b>=0&&24>b;return c&&\"\"!==a.hours?(a.showMeridian&&(12===b&&(b=0),a.meridian===y[1]&&(b+=12)),b):void 0}function i(){var b=+a.minutes,c=b>=0&&60>b;return c&&\"\"!==a.minutes?b:void 0}function j(){var b=+a.seconds;return b>=0&&60>b?b:void 0}function k(a,b){return null===a?\"\":angular.isDefined(a)&&a.toString().length<2&&!b?\"0\"+a:a.toString()}function l(a){m(),x.$setViewValue(new Date(v)),n(a)}function m(){s&&s.$setValidity(\"hours\",!0),t&&t.$setValidity(\"minutes\",!0),u&&u.$setValidity(\"seconds\",!0),x.$setValidity(\"time\",!0),a.invalidHours=!1,a.invalidMinutes=!1,a.invalidSeconds=!1}function n(b){if(x.$modelValue){var c=v.getHours(),d=v.getMinutes(),e=v.getSeconds();a.showMeridian&&(c=0===c||12===c?12:c%12),a.hours=\"h\"===b?c:k(c,!z),\"m\"!==b&&(a.minutes=k(d)),a.meridian=v.getHours()<12?y[0]:y[1],\"s\"!==b&&(a.seconds=k(e)),a.meridian=v.getHours()<12?y[0]:y[1]}else a.hours=null,a.minutes=null,a.seconds=null,a.meridian=y[0]}function o(a){v=q(v,a),l()}function p(a,b){return q(a,60*b)}function q(a,b){var c=new Date(a.getTime()+1e3*b),d=new Date(a);return d.setHours(c.getHours(),c.getMinutes(),c.getSeconds()),d}function r(){return(null===a.hours||\"\"===a.hours)&&(null===a.minutes||\"\"===a.minutes)&&(!a.showSeconds||a.showSeconds&&(null===a.seconds||\"\"===a.seconds))}var s,t,u,v=new Date,w=[],x={$setViewValue:angular.noop},y=angular.isDefined(c.meridians)?a.$parent.$eval(c.meridians):g.meridians||f.DATETIME_FORMATS.AMPMS,z=angular.isDefined(c.padHours)?a.$parent.$eval(c.padHours):!0;a.tabindex=angular.isDefined(c.tabindex)?c.tabindex:0,b.removeAttr(\"tabindex\"),this.init=function(b,d){x=b,x.$render=this.render,x.$formatters.unshift(function(a){return a?new Date(a):null});var e=d.eq(0),f=d.eq(1),h=d.eq(2);s=e.controller(\"ngModel\"),t=f.controller(\"ngModel\"),u=h.controller(\"ngModel\");var i=angular.isDefined(c.mousewheel)?a.$parent.$eval(c.mousewheel):g.mousewheel;i&&this.setupMousewheelEvents(e,f,h);var j=angular.isDefined(c.arrowkeys)?a.$parent.$eval(c.arrowkeys):g.arrowkeys;j&&this.setupArrowkeyEvents(e,f,h),a.readonlyInput=angular.isDefined(c.readonlyInput)?a.$parent.$eval(c.readonlyInput):g.readonlyInput,this.setupInputEvents(e,f,h)};var A=g.hourStep;c.hourStep&&w.push(a.$parent.$watch(d(c.hourStep),function(a){A=+a}));var B=g.minuteStep;c.minuteStep&&w.push(a.$parent.$watch(d(c.minuteStep),function(a){B=+a}));var C;w.push(a.$parent.$watch(d(c.min),function(a){var b=new Date(a);C=isNaN(b)?void 0:b}));var D;w.push(a.$parent.$watch(d(c.max),function(a){var b=new Date(a);D=isNaN(b)?void 0:b}));var E=!1;c.ngDisabled&&w.push(a.$parent.$watch(d(c.ngDisabled),function(a){E=a})),a.noIncrementHours=function(){var a=p(v,60*A);return E||a>D||v>a&&C>a},a.noDecrementHours=function(){var a=p(v,60*-A);return E||C>a||a>v&&a>D},a.noIncrementMinutes=function(){var a=p(v,B);return E||a>D||v>a&&C>a},a.noDecrementMinutes=function(){var a=p(v,-B);return E||C>a||a>v&&a>D},a.noIncrementSeconds=function(){var a=q(v,F);return E||a>D||v>a&&C>a},a.noDecrementSeconds=function(){var a=q(v,-F);return E||C>a||a>v&&a>D},a.noToggleMeridian=function(){return v.getHours()<12?E||p(v,720)>D:E||p(v,-720)<C};var F=g.secondStep;c.secondStep&&w.push(a.$parent.$watch(d(c.secondStep),function(a){F=+a})),a.showSeconds=g.showSeconds,c.showSeconds&&w.push(a.$parent.$watch(d(c.showSeconds),function(b){a.showSeconds=!!b})),a.showMeridian=g.showMeridian,c.showMeridian&&w.push(a.$parent.$watch(d(c.showMeridian),function(b){if(a.showMeridian=!!b,x.$error.time){var c=h(),d=i();angular.isDefined(c)&&angular.isDefined(d)&&(v.setHours(c),l())}else n()})),this.setupMousewheelEvents=function(b,c,d){var e=function(a){a.originalEvent&&(a=a.originalEvent);var b=a.wheelDelta?a.wheelDelta:-a.deltaY;return a.detail||b>0};b.on(\"mousewheel wheel\",function(b){E||a.$apply(e(b)?a.incrementHours():a.decrementHours()),b.preventDefault()}),c.on(\"mousewheel wheel\",function(b){E||a.$apply(e(b)?a.incrementMinutes():a.decrementMinutes()),b.preventDefault()}),d.on(\"mousewheel wheel\",function(b){E||a.$apply(e(b)?a.incrementSeconds():a.decrementSeconds()),b.preventDefault()})},this.setupArrowkeyEvents=function(b,c,d){b.on(\"keydown\",function(b){E||(38===b.which?(b.preventDefault(),a.incrementHours(),a.$apply()):40===b.which&&(b.preventDefault(),a.decrementHours(),a.$apply()))}),c.on(\"keydown\",function(b){E||(38===b.which?(b.preventDefault(),a.incrementMinutes(),a.$apply()):40===b.which&&(b.preventDefault(),a.decrementMinutes(),a.$apply()))}),d.on(\"keydown\",function(b){E||(38===b.which?(b.preventDefault(),a.incrementSeconds(),a.$apply()):40===b.which&&(b.preventDefault(),a.decrementSeconds(),a.$apply()))})},this.setupInputEvents=function(b,c,d){if(a.readonlyInput)return a.updateHours=angular.noop,a.updateMinutes=angular.noop,void(a.updateSeconds=angular.noop);var e=function(b,c,d){x.$setViewValue(null),x.$setValidity(\"time\",!1),angular.isDefined(b)&&(a.invalidHours=b,s&&s.$setValidity(\"hours\",!1)),angular.isDefined(c)&&(a.invalidMinutes=c,t&&t.$setValidity(\"minutes\",!1)),angular.isDefined(d)&&(a.invalidSeconds=d,u&&u.$setValidity(\"seconds\",!1))};a.updateHours=function(){var a=h(),b=i();x.$setDirty(),angular.isDefined(a)&&angular.isDefined(b)?(v.setHours(a),v.setMinutes(b),C>v||v>D?e(!0):l(\"h\")):e(!0)},b.on(\"blur\",function(b){x.$setTouched(),r()?m():null===a.hours||\"\"===a.hours?e(!0):!a.invalidHours&&a.hours<10&&a.$apply(function(){a.hours=k(a.hours,!z)})}),a.updateMinutes=function(){var a=i(),b=h();x.$setDirty(),angular.isDefined(a)&&angular.isDefined(b)?(v.setHours(b),v.setMinutes(a),C>v||v>D?e(void 0,!0):l(\"m\")):e(void 0,!0)},c.on(\"blur\",function(b){x.$setTouched(),r()?m():null===a.minutes?e(void 0,!0):!a.invalidMinutes&&a.minutes<10&&a.$apply(function(){a.minutes=k(a.minutes)})}),a.updateSeconds=function(){var a=j();x.$setDirty(),angular.isDefined(a)?(v.setSeconds(a),l(\"s\")):e(void 0,void 0,!0)},d.on(\"blur\",function(b){r()?m():!a.invalidSeconds&&a.seconds<10&&a.$apply(function(){a.seconds=k(a.seconds)})})},this.render=function(){var b=x.$viewValue;isNaN(b)?(x.$setValidity(\"time\",!1),e.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')):(b&&(v=b),C>v||v>D?(x.$setValidity(\"time\",!1),a.invalidHours=!0,a.invalidMinutes=!0):m(),n())},a.showSpinners=angular.isDefined(c.showSpinners)?a.$parent.$eval(c.showSpinners):g.showSpinners,a.incrementHours=function(){a.noIncrementHours()||o(60*A*60)},a.decrementHours=function(){a.noDecrementHours()||o(60*-A*60)},a.incrementMinutes=function(){a.noIncrementMinutes()||o(60*B)},a.decrementMinutes=function(){a.noDecrementMinutes()||o(60*-B)},a.incrementSeconds=function(){a.noIncrementSeconds()||o(F)},a.decrementSeconds=function(){a.noDecrementSeconds()||o(-F)},a.toggleMeridian=function(){var b=i(),c=h();a.noToggleMeridian()||(angular.isDefined(b)&&angular.isDefined(c)?o(720*(v.getHours()<12?60:-60)):a.meridian=a.meridian===y[0]?y[1]:y[0])},a.blur=function(){x.$setTouched()},a.$on(\"$destroy\",function(){for(;w.length;)w.shift()()})}]).directive(\"uibTimepicker\",[\"uibTimepickerConfig\",function(a){return{require:[\"uibTimepicker\",\"?^ngModel\"],restrict:\"A\",controller:\"UibTimepickerController\",controllerAs:\"timepicker\",scope:{},templateUrl:function(b,c){return c.templateUrl||a.templateUrl},link:function(a,b,c,d){var e=d[0],f=d[1];f&&e.init(f,b.find(\"input\"))}}}]),angular.module(\"ui.bootstrap.typeahead\",[\"ui.bootstrap.debounce\",\"ui.bootstrap.position\"]).factory(\"uibTypeaheadParser\",[\"$parse\",function(a){var b=/^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;return{parse:function(c){var d=c.match(b);if(!d)throw new Error('Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\" but got \"'+c+'\".');return{itemName:d[3],source:a(d[4]),viewMapper:a(d[2]||d[1]),modelMapper:a(d[1])}}}}]).controller(\"UibTypeaheadController\",[\"$scope\",\"$element\",\"$attrs\",\"$compile\",\"$parse\",\"$q\",\"$timeout\",\"$document\",\"$window\",\"$rootScope\",\"$$debounce\",\"$uibPosition\",\"uibTypeaheadParser\",function(a,b,c,d,e,f,g,h,i,j,k,l,m){function n(){P.moveInProgress||(P.moveInProgress=!0,P.$digest()),$()}function o(){P.position=F?l.offset(b):l.position(b),P.position.top+=b.prop(\"offsetHeight\")}function p(a){var b;return angular.version.minor<6?(b=a.$options||{},b.getOption=function(a){return b[a]}):b=a.$options,b}var q,r,s=[9,13,27,38,40],t=200,u=a.$eval(c.typeaheadMinLength);u||0===u||(u=1),a.$watch(c.typeaheadMinLength,function(a){u=a||0===a?a:1});var v=a.$eval(c.typeaheadWaitMs)||0,w=a.$eval(c.typeaheadEditable)!==!1;a.$watch(c.typeaheadEditable,function(a){w=a!==!1});var x,y,z=e(c.typeaheadLoading).assign||angular.noop,A=c.typeaheadShouldSelect?e(c.typeaheadShouldSelect):function(a,b){var c=b.$event;return 13===c.which||9===c.which},B=e(c.typeaheadOnSelect),C=angular.isDefined(c.typeaheadSelectOnBlur)?a.$eval(c.typeaheadSelectOnBlur):!1,D=e(c.typeaheadNoResults).assign||angular.noop,E=c.typeaheadInputFormatter?e(c.typeaheadInputFormatter):void 0,F=c.typeaheadAppendToBody?a.$eval(c.typeaheadAppendToBody):!1,G=c.typeaheadAppendTo?a.$eval(c.typeaheadAppendTo):null,H=a.$eval(c.typeaheadFocusFirst)!==!1,I=c.typeaheadSelectOnExact?a.$eval(c.typeaheadSelectOnExact):!1,J=e(c.typeaheadIsOpen).assign||angular.noop,K=a.$eval(c.typeaheadShowHint)||!1,L=e(c.ngModel),M=e(c.ngModel+\"($$$p)\"),N=function(b,c){return angular.isFunction(L(a))&&r.getOption(\"getterSetter\")?M(b,{$$$p:c}):L.assign(b,c)},O=m.parse(c.uibTypeahead),P=a.$new(),Q=a.$on(\"$destroy\",function(){P.$destroy()});P.$on(\"$destroy\",Q);var R=\"typeahead-\"+P.$id+\"-\"+Math.floor(1e4*Math.random());b.attr({\"aria-autocomplete\":\"list\",\"aria-expanded\":!1,\"aria-owns\":R});var S,T;K&&(S=angular.element(\"<div></div>\"),S.css(\"position\",\"relative\"),b.after(S),T=b.clone(),T.attr(\"placeholder\",\"\"),T.attr(\"tabindex\",\"-1\"),T.val(\"\"),T.css({position:\"absolute\",top:\"0px\",left:\"0px\",\"border-color\":\"transparent\",\"box-shadow\":\"none\",opacity:1,background:\"none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)\",color:\"#999\"}),b.css({position:\"relative\",\"vertical-align\":\"top\",\"background-color\":\"transparent\"}),T.attr(\"id\")&&T.removeAttr(\"id\"),S.append(T),T.after(b));var U=angular.element(\"<div uib-typeahead-popup></div>\");U.attr({id:R,matches:\"matches\",active:\"activeIdx\",select:\"select(activeIdx, evt)\",\"move-in-progress\":\"moveInProgress\",query:\"query\",position:\"position\",\"assign-is-open\":\"assignIsOpen(isOpen)\",debounce:\"debounceUpdate\"}),angular.isDefined(c.typeaheadTemplateUrl)&&U.attr(\"template-url\",c.typeaheadTemplateUrl),angular.isDefined(c.typeaheadPopupTemplateUrl)&&U.attr(\"popup-template-url\",c.typeaheadPopupTemplateUrl);var V=function(){K&&T.val(\"\")},W=function(){P.matches=[],P.activeIdx=-1,b.attr(\"aria-expanded\",!1),V()},X=function(a){return R+\"-option-\"+a};P.$watch(\"activeIdx\",function(a){0>a?b.removeAttr(\"aria-activedescendant\"):b.attr(\"aria-activedescendant\",X(a))});var Y=function(a,b){return P.matches.length>b&&a?a.toUpperCase()===P.matches[b].label.toUpperCase():!1},Z=function(c,d){var e={$viewValue:c};z(a,!0),D(a,!1),f.when(O.source(a,e)).then(function(f){var g=c===q.$viewValue;if(g&&x)if(f&&f.length>0){P.activeIdx=H?0:-1,D(a,!1),P.matches.length=0;for(var h=0;h<f.length;h++)e[O.itemName]=f[h],P.matches.push({id:X(h),label:O.viewMapper(P,e),model:f[h]});if(P.query=c,o(),b.attr(\"aria-expanded\",!0),I&&1===P.matches.length&&Y(c,0)&&(angular.isNumber(P.debounceUpdate)||angular.isObject(P.debounceUpdate)?k(function(){P.select(0,d)},angular.isNumber(P.debounceUpdate)?P.debounceUpdate:P.debounceUpdate[\"default\"]):P.select(0,d)),K){var i=P.matches[0].label;angular.isString(c)&&c.length>0&&i.slice(0,c.length).toUpperCase()===c.toUpperCase()?T.val(c+i.slice(c.length)):T.val(\"\")}}else W(),D(a,!0);g&&z(a,!1)},function(){W(),z(a,!1),D(a,!0)})};F&&(angular.element(i).on(\"resize\",n),h.find(\"body\").on(\"scroll\",n));var $=k(function(){P.matches.length&&o(),P.moveInProgress=!1},t);P.moveInProgress=!1,P.query=void 0;var _,aa=function(a){_=g(function(){Z(a)},v)},ba=function(){_&&g.cancel(_)};W(),P.assignIsOpen=function(b){J(a,b)},P.select=function(d,e){var f,h,i={};y=!0,i[O.itemName]=h=P.matches[d].model,f=O.modelMapper(a,i),N(a,f),q.$setValidity(\"editable\",!0),q.$setValidity(\"parse\",!0),B(a,{$item:h,$model:f,$label:O.viewMapper(a,i),$event:e}),W(),P.$eval(c.typeaheadFocusOnSelect)!==!1&&g(function(){b[0].focus()},0,!1)},b.on(\"keydown\",function(b){if(0!==P.matches.length&&-1!==s.indexOf(b.which)){var c=A(a,{$event:b});if(-1===P.activeIdx&&c||9===b.which&&b.shiftKey)return W(),void P.$digest();b.preventDefault();var d;switch(b.which){case 27:b.stopPropagation(),W(),a.$digest();break;case 38:P.activeIdx=(P.activeIdx>0?P.activeIdx:P.matches.length)-1,P.$digest(),d=U[0].querySelectorAll(\".uib-typeahead-match\")[P.activeIdx],d.parentNode.scrollTop=d.offsetTop;break;case 40:P.activeIdx=(P.activeIdx+1)%P.matches.length,P.$digest(),d=U[0].querySelectorAll(\".uib-typeahead-match\")[P.activeIdx],\nd.parentNode.scrollTop=d.offsetTop;break;default:c&&P.$apply(function(){angular.isNumber(P.debounceUpdate)||angular.isObject(P.debounceUpdate)?k(function(){P.select(P.activeIdx,b)},angular.isNumber(P.debounceUpdate)?P.debounceUpdate:P.debounceUpdate[\"default\"]):P.select(P.activeIdx,b)})}}}),b.on(\"focus\",function(a){x=!0,0!==u||q.$viewValue||g(function(){Z(q.$viewValue,a)},0)}),b.on(\"blur\",function(a){C&&P.matches.length&&-1!==P.activeIdx&&!y&&(y=!0,P.$apply(function(){angular.isObject(P.debounceUpdate)&&angular.isNumber(P.debounceUpdate.blur)?k(function(){P.select(P.activeIdx,a)},P.debounceUpdate.blur):P.select(P.activeIdx,a)})),!w&&q.$error.editable&&(q.$setViewValue(),P.$apply(function(){q.$setValidity(\"editable\",!0),q.$setValidity(\"parse\",!0)}),b.val(\"\")),x=!1,y=!1});var ca=function(c){b[0]!==c.target&&3!==c.which&&0!==P.matches.length&&(W(),j.$$phase||a.$digest())};h.on(\"click\",ca),a.$on(\"$destroy\",function(){h.off(\"click\",ca),(F||G)&&da.remove(),F&&(angular.element(i).off(\"resize\",n),h.find(\"body\").off(\"scroll\",n)),U.remove(),K&&S.remove()});var da=d(U)(P);F?h.find(\"body\").append(da):G?angular.element(G).eq(0).append(da):b.after(da),this.init=function(b){q=b,r=p(q),P.debounceUpdate=e(r.getOption(\"debounce\"))(a),q.$parsers.unshift(function(b){return x=!0,0===u||b&&b.length>=u?v>0?(ba(),aa(b)):Z(b):(z(a,!1),ba(),W()),w?b:b?void q.$setValidity(\"editable\",!1):(q.$setValidity(\"editable\",!0),null)}),q.$formatters.push(function(b){var c,d,e={};return w||q.$setValidity(\"editable\",!0),E?(e.$model=b,E(a,e)):(e[O.itemName]=b,c=O.viewMapper(a,e),e[O.itemName]=void 0,d=O.viewMapper(a,e),c!==d?c:b)})}}]).directive(\"uibTypeahead\",function(){return{controller:\"UibTypeaheadController\",require:[\"ngModel\",\"uibTypeahead\"],link:function(a,b,c,d){d[1].init(d[0])}}}).directive(\"uibTypeaheadPopup\",[\"$$debounce\",function(a){return{scope:{matches:\"=\",query:\"=\",active:\"=\",position:\"&\",moveInProgress:\"=\",select:\"&\",assignIsOpen:\"&\",debounce:\"&\"},replace:!0,templateUrl:function(a,b){return b.popupTemplateUrl||\"uib/template/typeahead/typeahead-popup.html\"},link:function(b,c,d){b.templateUrl=d.templateUrl,b.isOpen=function(){var a=b.matches.length>0;return b.assignIsOpen({isOpen:a}),a},b.isActive=function(a){return b.active===a},b.selectActive=function(a){b.active=a},b.selectMatch=function(c,d){var e=b.debounce();angular.isNumber(e)||angular.isObject(e)?a(function(){b.select({activeIdx:c,evt:d})},angular.isNumber(e)?e:e[\"default\"]):b.select({activeIdx:c,evt:d})}}}}]).directive(\"uibTypeaheadMatch\",[\"$templateRequest\",\"$compile\",\"$parse\",function(a,b,c){return{scope:{index:\"=\",match:\"=\",query:\"=\"},link:function(d,e,f){var g=c(f.templateUrl)(d.$parent)||\"uib/template/typeahead/typeahead-match.html\";a(g).then(function(a){var c=angular.element(a.trim());e.replaceWith(c),b(c)(d)})}}}]).filter(\"uibTypeaheadHighlight\",[\"$sce\",\"$injector\",\"$log\",function(a,b,c){function d(a){return a.replace(/([.?*+^$[\\]\\\\(){}|-])/g,\"\\\\$1\")}function e(a){return/<.*>/g.test(a)}var f;return f=b.has(\"$sanitize\"),function(b,g){return!f&&e(b)&&c.warn(\"Unsafe use of typeahead please use ngSanitize\"),b=g?(\"\"+b).replace(new RegExp(d(g),\"gi\"),\"<strong>$&</strong>\"):b,f||(b=a.trustAsHtml(b)),b}}]),angular.module(\"uib/template/accordion/accordion-group.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/accordion/accordion-group.html\",'<div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"mgz-tab-panel-heading\" ng-keypress=\"toggleOpen($event)\">\\n  <h4 class=\"mgz-tab-panel-title\">\\n    <a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\" ng-disabled=\"isDisabled\" uib-tabindex-toggle><span uib-accordion-header ng-class=\"{\\'text-muted\\': isDisabled}\">{{heading}}</span></a>\\n  </h4>\\n</div>\\n<div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"mgz-tab-panel-collapse collapse\" uib-collapse=\"!isOpen\">\\n  <div class=\"mgz-tab-panel-body\" ng-transclude></div>\\n</div>\\n')}]),angular.module(\"uib/template/accordion/accordion.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/accordion/accordion.html\",'<div role=\"tablist\" class=\"panel-group\" ng-transclude></div>')}]),angular.module(\"uib/template/alert/alert.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/alert/alert.html\",'<button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\\n  <span aria-hidden=\"true\">&times;</span>\\n  <span class=\"sr-only\">Close</span>\\n</button>\\n<div ng-transclude></div>\\n')}]),angular.module(\"uib/template/carousel/carousel.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/carousel/carousel.html\",'<div class=\"carousel-inner\" ng-transclude></div>\\n<a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\\n  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\\n  <span class=\"sr-only\">previous</span>\\n</a>\\n<a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\\n  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\\n  <span class=\"sr-only\">next</span>\\n</a>\\n<ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\\n  <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\\n    <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\\n  </li>\\n</ol>\\n')}]),angular.module(\"uib/template/carousel/slide.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/carousel/slide.html\",'<div class=\"text-center\" ng-transclude></div>\\n')}]),angular.module(\"uib/template/datepicker/datepicker.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/datepicker/datepicker.html\",'<div ng-switch=\"datepickerMode\">\\n  <div uib-daypicker ng-switch-when=\"day\" tabindex=\"0\" class=\"uib-daypicker\"></div>\\n  <div uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\" class=\"uib-monthpicker\"></div>\\n  <div uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\" class=\"uib-yearpicker\"></div>\\n</div>\\n')}]),angular.module(\"uib/template/datepicker/day.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/datepicker/day.html\",'<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\\n  <thead>\\n    <tr>\\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\\n      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\\n    </tr>\\n    <tr>\\n      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\\n      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\\n    </tr>\\n  </thead>\\n  <tbody>\\n    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\" role=\"row\">\\n      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\\n      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\\n        id=\"{{::dt.uid}}\"\\n        ng-class=\"::dt.customClass\">\\n        <button type=\"button\" class=\"btn btn-default btn-sm\"\\n          uib-is-class=\"\\n            \\'btn-info\\' for selectedDt,\\n            \\'active\\' for activeDt\\n            on dt\"\\n          ng-click=\"select(dt.date)\"\\n          ng-disabled=\"::dt.disabled\"\\n          tabindex=\"-1\"><span ng-class=\"::{\\'text-muted\\': dt.secondary, \\'text-info\\': dt.current}\">{{::dt.label}}</span></button>\\n      </td>\\n    </tr>\\n  </tbody>\\n</table>\\n')}]),angular.module(\"uib/template/datepicker/month.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/datepicker/month.html\",'<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\\n  <thead>\\n    <tr>\\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\\n      <th colspan=\"{{::yearHeaderColspan}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></i></button></th>\\n    </tr>\\n  </thead>\\n  <tbody>\\n    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\" role=\"row\">\\n      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\\n        id=\"{{::dt.uid}}\"\\n        ng-class=\"::dt.customClass\">\\n        <button type=\"button\" class=\"btn btn-default\"\\n          uib-is-class=\"\\n            \\'btn-info\\' for selectedDt,\\n            \\'active\\' for activeDt\\n            on dt\"\\n          ng-click=\"select(dt.date)\"\\n          ng-disabled=\"::dt.disabled\"\\n          tabindex=\"-1\"><span ng-class=\"::{\\'text-info\\': dt.current}\">{{::dt.label}}</span></button>\\n      </td>\\n    </tr>\\n  </tbody>\\n</table>\\n')}]),angular.module(\"uib/template/datepicker/year.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/datepicker/year.html\",'<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\\n  <thead>\\n    <tr>\\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></i><span class=\"sr-only\">previous</span></button></th>\\n      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\"><strong>{{title}}</strong></button></th>\\n      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></i><span class=\"sr-only\">next</span></button></th>\\n    </tr>\\n  </thead>\\n  <tbody>\\n    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\" role=\"row\">\\n      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\\n        id=\"{{::dt.uid}}\"\\n        ng-class=\"::dt.customClass\">\\n        <button type=\"button\" class=\"btn btn-default\"\\n          uib-is-class=\"\\n            \\'btn-info\\' for selectedDt,\\n            \\'active\\' for activeDt\\n            on dt\"\\n          ng-click=\"select(dt.date)\"\\n          ng-disabled=\"::dt.disabled\"\\n          tabindex=\"-1\"><span ng-class=\"::{\\'text-info\\': dt.current}\">{{::dt.label}}</span></button>\\n      </td>\\n    </tr>\\n  </tbody>\\n</table>\\n')}]),angular.module(\"uib/template/datepickerPopup/popup.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/datepickerPopup/popup.html\",'<ul role=\"presentation\" class=\"uib-datepicker-popup dropdown-menu uib-position-measure\" dropdown-nested ng-if=\"isOpen\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\\n  <li ng-transclude></li>\\n  <li ng-if=\"showButtonBar\" class=\"uib-button-bar\">\\n    <span class=\"btn-group pull-left\">\\n      <button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select(\\'today\\', $event)\" ng-disabled=\"isDisabled(\\'today\\')\">{{ getText(\\'current\\') }}</button>\\n      <button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null, $event)\">{{ getText(\\'clear\\') }}</button>\\n    </span>\\n    <button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close($event)\">{{ getText(\\'close\\') }}</button>\\n  </li>\\n</ul>\\n')}]),angular.module(\"uib/template/modal/window.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/modal/window.html\",\"<div class=\\\"modal-dialog {{size ? 'modal-' + size : ''}}\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\")}]),angular.module(\"uib/template/pager/pager.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/pager/pager.html\",'<li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText(\\'previous\\')}}</a></li>\\n<li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText(\\'next\\')}}</a></li>\\n')}]),angular.module(\"uib/template/pagination/pagination.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/pagination/pagination.html\",'<li role=\"menuitem\" ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText(\\'first\\')}}</a></li>\\n<li role=\"menuitem\" ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\" ng-disabled=\"noPrevious()||ngDisabled\" uib-tabindex-toggle>{{::getText(\\'previous\\')}}</a></li>\\n<li role=\"menuitem\" ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\" ng-disabled=\"ngDisabled&&!page.active\" uib-tabindex-toggle>{{page.text}}</a></li>\\n<li role=\"menuitem\" ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText(\\'next\\')}}</a></li>\\n<li role=\"menuitem\" ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\" ng-disabled=\"noNext()||ngDisabled\" uib-tabindex-toggle>{{::getText(\\'last\\')}}</a></li>\\n')}]),angular.module(\"uib/template/tooltip/tooltip-html-popup.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/tooltip/tooltip-html-popup.html\",'<div class=\"tooltip-arrow\"></div>\\n<div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\\n')}]),angular.module(\"uib/template/tooltip/tooltip-popup.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/tooltip/tooltip-popup.html\",'<div class=\"tooltip-arrow\"></div>\\n<div class=\"tooltip-inner\" ng-bind=\"content\"></div>\\n')}]),angular.module(\"uib/template/tooltip/tooltip-template-popup.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/tooltip/tooltip-template-popup.html\",'<div class=\"tooltip-arrow\"></div>\\n<div class=\"tooltip-inner\"\\n  uib-tooltip-template-transclude=\"contentExp()\"\\n  tooltip-template-transclude-scope=\"originScope()\"></div>\\n')}]),angular.module(\"uib/template/popover/popover-html.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/popover/popover-html.html\",'<div class=\"arrow\"></div>\\n\\n<div class=\"popover-inner\">\\n    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\\n    <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\\n</div>\\n')}]),angular.module(\"uib/template/popover/popover-template.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/popover/popover-template.html\",'<div class=\"arrow\"></div>\\n\\n<div class=\"popover-inner\">\\n    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\\n    <div class=\"popover-content\"\\n      uib-tooltip-template-transclude=\"contentExp()\"\\n      tooltip-template-transclude-scope=\"originScope()\"></div>\\n</div>\\n')}]),angular.module(\"uib/template/popover/popover.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/popover/popover.html\",'<div class=\"arrow\"></div>\\n\\n<div class=\"popover-inner\">\\n    <h3 class=\"popover-title\" ng-bind=\"uibTitle\" ng-if=\"uibTitle\"></h3>\\n    <div class=\"popover-content\" ng-bind=\"content\"></div>\\n</div>\\n')}]),angular.module(\"uib/template/progressbar/bar.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/progressbar/bar.html\",'<div class=\"progress-bar\" ng-class=\"type && \\'progress-bar-\\' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + \\'%\\'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\\n')}]),angular.module(\"uib/template/progressbar/progress.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/progressbar/progress.html\",'<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>')}]),angular.module(\"uib/template/progressbar/progressbar.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/progressbar/progressbar.html\",'<div class=\"progress\">\\n  <div class=\"progress-bar\" ng-class=\"type && \\'progress-bar-\\' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + \\'%\\'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\\n</div>\\n')}]),angular.module(\"uib/template/rating/rating.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/rating/rating.html\",'<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\" aria-valuetext=\"{{title}}\">\\n    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? \\'*\\' : \\' \\' }})</span>\\n    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || \\'glyphicon-star\\') || (r.stateOff || \\'glyphicon-star-empty\\')\" ng-attr-title=\"{{r.title}}\"></i>\\n</span>\\n')}]),angular.module(\"uib/template/tabs/tab.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/tabs/tab.html\",'<li ng-class=\"[{active: active, disabled: disabled}, classes]\" class=\"uib-tab nav-item\">\\n  <a href ng-click=\"select($event)\" class=\"nav-link\" uib-tab-heading-transclude>{{heading}}</a>\\n</li>\\n')}]),angular.module(\"uib/template/tabs/tabset.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/tabs/tabset.html\",'<div>\\n  <ul class=\"nav nav-{{tabset.type || \\'tabs\\'}}\" ng-class=\"{\\'nav-stacked\\': vertical, \\'nav-justified\\': justified}\" ng-transclude></ul>\\n  <div class=\"tab-content\">\\n    <div class=\"tab-pane\"\\n         ng-repeat=\"tab in tabset.tabs\"\\n         ng-class=\"{active: tabset.active === tab.index}\"\\n         uib-tab-content-transclude=\"tab\">\\n    </div>\\n  </div>\\n</div>\\n')}]),angular.module(\"uib/template/timepicker/timepicker.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/timepicker/timepicker.html\",'<table class=\"uib-timepicker\">\\n  <tbody>\\n    <tr class=\"text-center\" ng-show=\"::showSpinners\">\\n      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\\n      <td>&nbsp;</td>\\n      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\\n      <td ng-show=\"showSeconds\">&nbsp;</td>\\n      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\\n      <td ng-show=\"showMeridian\"></td>\\n    </tr>\\n    <tr>\\n      <td class=\"form-group uib-time hours\" ng-class=\"{\\'has-error\\': invalidHours}\">\\n        <input type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementHours()\" ng-blur=\"blur()\">\\n      </td>\\n      <td class=\"uib-separator\">:</td>\\n      <td class=\"form-group uib-time minutes\" ng-class=\"{\\'has-error\\': invalidMinutes}\">\\n        <input type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementMinutes()\" ng-blur=\"blur()\">\\n      </td>\\n      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\\n      <td class=\"form-group uib-time seconds\" ng-class=\"{\\'has-error\\': invalidSeconds}\" ng-show=\"showSeconds\">\\n        <input type=\"text\" placeholder=\"SS\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"noIncrementSeconds()\" ng-blur=\"blur()\">\\n      </td>\\n      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\\n    </tr>\\n    <tr class=\"text-center\" ng-show=\"::showSpinners\">\\n      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\\n      <td>&nbsp;</td>\\n      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\\n      <td ng-show=\"showSeconds\">&nbsp;</td>\\n      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"-1\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\\n      <td ng-show=\"showMeridian\"></td>\\n    </tr>\\n  </tbody>\\n</table>\\n')}]),angular.module(\"uib/template/typeahead/typeahead-match.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/typeahead/typeahead-match.html\",'<a href\\n   tabindex=\"-1\"\\n   ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"\\n   ng-attr-title=\"{{match.label}}\"></a>\\n')}]),angular.module(\"uib/template/typeahead/typeahead-popup.html\",[]).run([\"$templateCache\",function(a){a.put(\"uib/template/typeahead/typeahead-popup.html\",'<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+\\'px\\', left: position().left+\\'px\\'}\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\\n    <li class=\"uib-typeahead-match\" ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\\n        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\\n    </li>\\n</ul>\\n')}]),angular.module(\"ui.bootstrap.carousel\").run(function(){!angular.$$csp().noInlineStyle&&!angular.$$uibCarouselCss&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'),angular.$$uibCarouselCss=!0}),angular.module(\"ui.bootstrap.datepicker\").run(function(){!angular.$$csp().noInlineStyle&&!angular.$$uibDatepickerCss&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'),angular.$$uibDatepickerCss=!0}),angular.module(\"ui.bootstrap.position\").run(function(){!angular.$$csp().noInlineStyle&&!angular.$$uibPositionCss&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'),angular.$$uibPositionCss=!0}),angular.module(\"ui.bootstrap.datepickerPopup\").run(function(){!angular.$$csp().noInlineStyle&&!angular.$$uibDatepickerpopupCss&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'),angular.$$uibDatepickerpopupCss=!0}),angular.module(\"ui.bootstrap.tooltip\").run(function(){!angular.$$csp().noInlineStyle&&!angular.$$uibTooltipCss&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'),angular.$$uibTooltipCss=!0}),angular.module(\"ui.bootstrap.timepicker\").run(function(){!angular.$$csp().noInlineStyle&&!angular.$$uibTimepickerCss&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">.uib-time input{width:50px;}</style>'),angular.$$uibTimepickerCss=!0}),angular.module(\"ui.bootstrap.typeahead\").run(function(){!angular.$$csp().noInlineStyle&&!angular.$$uibTypeaheadCss&&angular.element(document).find(\"head\").prepend('<style type=\"text/css\">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'),angular.$$uibTypeaheadCss=!0});","Magezon_Builder/js/countdown.js":"define([\n    'jquery',\n    'jquery-ui-modules/widget',\n    'Magezon_Builder/js/waypoints/jquery.waypoints'\n], function ($) {\n    'use strict';\n\n    $.widget('magezon.countdown', {\n        options: {\n            nodeClass: '',\n            wrapperClass: '',\n            countdown: '',\n            dateWrapper: '',\n            dateLabel: '',\n            hoursWrapper: '',\n            hoursLabel: '',\n            minutesWrapper: '',\n            minutesLabel: '',\n            secondsWrapper: '',\n            secondsLabel: '',\n            time: '2019-02-28T01:00:00+00:00',\n            _timeInterval: '',\n        },\n\n        _create: function () {\n            this.dateWrapper    = this.element.find('.mgz-countdown-days');\n            this.dateLabel      = this.dateWrapper.find('.mgz-countdown-unit-label').data('label');\n            this.hoursWrapper   = this.element.find('.mgz-countdown-hours');\n            this.hoursLabel     = this.hoursWrapper.find('.mgz-countdown-unit-label').data('label');\n            this.minutesWrapper = this.element.find('.mgz-countdown-minutes');\n            this.minutesLabel   = this.minutesWrapper.find('.mgz-countdown-unit-label').data('label');\n            this.secondsWrapper = this.element.find('.mgz-countdown-seconds');\n            this.secondsLabel   = this.secondsWrapper.find('.mgz-countdown-unit-label').data('label');\n\n            this._initCountdown();\n        },\n\n        _getTimeRemaining: function(endtime) {\n            var t       = Date.parse(endtime) - Date.parse(new Date());\n            var seconds = Math.floor((t / 1000) % 60);\n            var minutes = Math.floor((t / 1000 / 60) % 60);\n            var hours   = Math.floor((t / (1000 * 60 * 60)) % 24);\n            var days    = Math.floor(t / (1000 * 60 * 60 * 24));\n            return {\n                'total': t,\n                'days': (days < 10) ? ('0' + days) : days,\n                'hours': ('0' + hours).slice(-2),\n                'minutes': ('0' + minutes).slice(-2),\n                'seconds': ('0' + seconds).slice(-2)\n            };\n        },\n\n        _setTimeRemaining: function() {\n            var t = this._getTimeRemaining(this.options.time),\n                wrappers = {\n                    days: $(this.dateWrapper),\n                    hours: $(this.hoursWrapper),\n                    minutes: $(this.minutesWrapper),\n                    seconds: $(this.secondsWrapper)\n                },\n                labels = {\n                    days: this.dateLabel,\n                    hours: this.hoursLabel,\n                    minutes: this.minutesLabel,\n                    seconds: this.secondsLabel\n                };\n            if (t.total <= 0) {\n                clearInterval(this._timeInterval);\n                $.each(wrappers, function(type, element) {\n                    element.find('.mgz-countdown-unit-number').html('00');\n                });\n            } else {\n                $.each(wrappers, function(type, element) {\n                    element.find('.mgz-countdown-unit-number').html(t[type]);\n                    var $el = element.find('.mgz-countdown-unit-label');\n                    var label = parseInt(t[type]) != 1 ? labels[type].plural : labels[type].singular;\n                    $el.html(label);\n                });\n            }\n        },\n\n        _setCircleCount: function() {\n            var t = this._getTimeRemaining(this.options.time),\n                max = {\n                    days: 365,\n                    hours: 24,\n                    minutes: 60,\n                    seconds: 60\n                },\n                circles = {\n                    days: $(this.dateWrapper).find('svg'),\n                    hours: $(this.hoursWrapper).find('svg'),\n                    minutes: $(this.minutesWrapper).find('svg'),\n                    seconds: $(this.secondsWrapper).find('svg'),\n                }\n            $.each(circles, function(type, element) {\n                var $circle = element.find('.mgz-element-bar'),\n                    r = $circle.attr('r'),\n                    circle = Math.PI * (r * 2),\n                    val = t[type],\n                    total = max[type],\n                    stroke = (1 - (val / total)) * circle;\n                $circle.css({\n                    strokeDashoffset: stroke\n                });\n            });\n        },\n\n        _initCountdown: function() {\n            var self = this;\n            this._setTimeRemaining();\n            if (this.options.type == 'circle') {\n                this._setCircleCount();\n            }\n\n            this.interval = setInterval(function() {\n                self._setTimeRemaining();\n                if (self.options.type == 'circle') {\n                    self._setCircleCount();\n                }\n            }, 1000);\n        },\n\n        clearInterval: function() {\n            clearInterval(this.interval);\n        }\n    });\n\n    return $.magezon.countdown;\n});","Magezon_Builder/js/builder.js":"define([\n\t'angular',\n\t'formly',\n\t'Magezon_Builder/js/factories/config',\n\t'Magezon_Builder/js/services/magezonBuilder',\n\t'Magezon_Builder/js/services/url',\n\t'Magezon_Builder/js/services/modal',\n\t'Magezon_Builder/js/services/element',\n\t'Magezon_Builder/js/services/profile',\n\t'Magezon_Builder/js/services/form',\n\t'Magezon_Builder/js/services/editor',\n\t'Magezon_Builder/js/services/filter',\n\t'Magezon_Builder/js/services/history',\n\t'Magezon_Builder/js/controllers/base',\n\t'Magezon_Builder/js/controllers/list',\n\t'Magezon_Builder/js/controllers/modal',\n\t'Magezon_Builder/js/controllers/toolbar',\n\t'Magezon_Builder/js/directives/magezonBuilder',\n\t'Magezon_Builder/js/directives/modalElement',\n\t'Magezon_Builder/js/directives/resizable',\n\t'Magezon_Builder/js/directives/builderDirectiveList',\n\t'Magezon_Builder/js/builder/element/profile',\n\t'Magezon_Builder/js/directives/navigator',\n\t'Magezon_Builder/js/directives/elementIcon',\n\t'Magezon_Builder/js/directives/navigatorProfile',\n\t'Magezon_Builder/js/modules/contentEditable',\n\t'Magezon_Builder/js/modules/inlineEditor',\n\t'Magezon_Builder/js/modules/afterRender',\n\t'Magezon_Builder/js/directives/colorPicker',\n\t'Magezon_Builder/js/directives/elementActions',\n\t'Magezon_Builder/js/directives/elementResizable',\n\t'Magezon_Builder/js/directives/tooltip',\n\t'uiBootstrap',\n\t'dndLists',\n\t'angularSanitize',\n\t'dynamicDirective',\n\t'uiCodemirror',\n\t'uiSelect',\n\t'outsideClickDirective',\n\t'ngStats'\n], function(\n\tangular,\n\tformly,\n\tconfigProvider,\n\tmagezonBuilderSer,\n\tmagezonBuilderUrlSer,\n\tmagezonBuilderModalSer,\n\telementManagerSer,\n\tprofileManagerSer,\n\tformSer,\n\teditorSer,\n\tfilterSer,\n\thistorySer,\n\tbaseController,\n\tlistController,\n\tmodalBaseControllerCtrl,\n\ttoolbarControllerCtrl,\n\tmagezonBuilderDir,\n\tmodalElementDir,\n\tresizableDir,\n\tbuilderDirectiveListDir,\n\tprofileDir,\n\tnavigatorDir,\n\telementIconDir,\n\tnavigatorProfileDir,\n\tcontentEditableDir,\n\tinlineEditorDir,\n\tafterRender,\n\tcolorPicker,\n\telementActions,\n\telementResizable,\n\ttooltipDir\n) {\n\tvar builder = angular.module('magezonBuilder', ['formly', 'dndLists', 'ui.bootstrap', 'ngSanitize', 'dynamicDirective', 'ui.codemirror', 'ui.select', 'ngOutsideClick', 'angularStats']);\n\n\tbuilder.config(function($sceDelegateProvider) {\n\t\t$resourceUrlWhitelist = ['self','*://localhost/**','*://www.youtube.com/**', '*://player.vimeo.com/video/**'];\n\t\t$sceDelegateProvider.resourceUrlWhitelist($resourceUrlWhitelist.concat(window.builderConfig.resourceUrlWhitelist));\n\t});\n\n\tbuilder.run(function(dynamicDirectiveManager, magezonBuilderConfig, magezonBuilderService, magezonBuilderUrl, elementManager) {\n\t\tangular.forEach(magezonBuilderConfig.elements, function(element) {\n\t\t\tvar type = elementManager.getElementType(element.type);\n\t\t\trequire([element['element']], function(Directive) {\n\t\t\t\tdynamicDirectiveManager.registerDirective('mgzElement' + type, Directive, 'mgz');\n\t\t\t});\n\t\t\trequire([element['navigator']], function(Directive) {\n\t\t\t\tdynamicDirectiveManager.registerDirective('mgzElementNavigator' + type, Directive, 'mgz');\n\t\t\t});\n\t\t\tif (element['toolbar']) {\n\t\t\t\trequire([element['toolbar']], function(Directive) {\n\t\t\t\t\tdynamicDirectiveManager.registerDirective('mgzElementToolbar' + type, Directive, 'mgz');\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\tangular.forEach(magezonBuilderConfig.directives, function(directive, name) {\n\t\t\tname = elementManager.getElementType(directive.type);\n\t\t\tif (directive['element']) {\n\t\t\t\trequire([directive['element']], function(Directive) {\n\t\t\t\t\tdynamicDirectiveManager.registerDirective('mgzDirective' + name, Directive, 'mgz');\n\t\t\t\t});\n\t\t\t} else if (directive['templateUrl']) {\n\t\t\t\tfunction Directive() {\n\t\t\t\t \treturn {\n\t\t\t\t \t\treplace: true,\n\t\t\t\t \t\ttemplateUrl: magezonBuilderUrl.getViewFileUrl(directive['templateUrl'])\n\t\t\t\t \t};\n\t\t\t\t}\n\t\t\t\tdynamicDirectiveManager.registerDirective('mgzDirective' + name, Directive, 'mgz');\n\t\t\t}\n\t\t});\n\t\tmagezonBuilderService.directives = magezonBuilderConfig.directives;\n\t});\n\n\t// PROVIDER\n\tbuilder.provider('magezonBuilderConfig', configProvider);\n\tbuilder.service('magezonBuilderService', magezonBuilderSer);\n\tbuilder.service('magezonBuilderUrl', magezonBuilderUrlSer);\n\tbuilder.service('magezonBuilderModal', magezonBuilderModalSer);\n\tbuilder.service('elementManager', elementManagerSer);\n\tbuilder.service('profileManager', profileManagerSer);\n\tbuilder.service('historyManager', historySer);\n\tbuilder.service('magezonBuilderForm', formSer);\n\tbuilder.service('magezonBuilderEditor', editorSer);\n\tbuilder.service('magezonBuilderFilter', filterSer);\n\n\t// DIRECTIVE\n\tbuilder.directive('magezonBuilder', magezonBuilderDir);\n\tbuilder.directive('magezonBuilderModalElement', modalElementDir);\n\tbuilder.directive('magezonBuilderResizable', resizableDir);\n\tbuilder.directive('magezonBuilderDirectiveList', builderDirectiveListDir);\n\tbuilder.directive('magezonBuilderProfile', profileDir);\n\tbuilder.directive('magezonBuilderNavigator', navigatorDir);\n\tbuilder.directive('magezonBuilderElementIcon', elementIconDir);\n\tbuilder.directive('magezonBuilderNavigatorProfile', navigatorProfileDir);\n\tbuilder.directive('contentEditable', contentEditableDir);\n\tbuilder.directive('inlineEditor', inlineEditorDir);\n\tbuilder.directive('afterRender', afterRender);\n\tbuilder.directive('magezonBuilderColorPicker', colorPicker);\n\tbuilder.directive('magezonBuilderElementActions', elementActions);\n\tbuilder.directive('magezonBuilderElementResizable', elementResizable);\n\tbuilder.directive('mgzTooltip', tooltipDir);\n\n\t// CONTROLLER\n\tbuilder.controller('baseController', baseController);\n\tbuilder.controller('listController', listController);\n\tbuilder.controller('modalBaseController', modalBaseControllerCtrl);\n\tbuilder.controller('toolbarController', toolbarControllerCtrl);\n\n\treturn builder;\n});","Magezon_Builder/js/responsive-typography.js":"define([\n\t'jquery'\n], function ($) {\n\n\t// Source: https://gist.github.com/sulmanpucit/9b4db482fd3201e14e8686465d011def\n\n\t// Calculate the responsive type values for font size and line height for all heading tags\n\tvar calculateResponsiveTypeValues = function( $siteWidth, $customSensitivity, $customMinimumFontSizeFactor, $customMobileBreakPoint, $elements ) {\n\n\t\t// Setup options\n\t\tvar $sensitivity           = $customSensitivity || 1,\n\t\t    $minimumFontSizeFactor = $customMinimumFontSizeFactor || 1.5,\n\t\t    $bodyFontSize          = parseInt( jQuery( 'body' ).css( 'font-size' ) ),\n\t\t    $minimumFontSize       = $bodyFontSize * $minimumFontSizeFactor,\n\t\t    $mobileBreakPoint      = ( $customMobileBreakPoint || 0 === $customMobileBreakPoint ) ? $customMobileBreakPoint : 800,\n\t\t    $windowSiteWidthRatio,\n\t\t    $resizeFactor;\n\n\t\tvar calculateValues = function() {\n\t\t\tvar $siteWidth;\n\n\t\t\t// Get the site width for responsive type\n\t\t\tif ( jQuery( window ).width() >= $mobileBreakPoint ) {\n\n\t\t\t// If we are below $mobileBreakPoint of viewport width, set $mobileBreakPoint as site width\n\t\t\t} else {\n\t\t\t\t$siteWidth = $mobileBreakPoint;\n\t\t\t}\n\n\t\t\t// The resizing factor can be finetuned through a custom sensitivity; values below 1 decrease resizing speed\n\t\t\t$windowSiteWidthRatio = jQuery( window ).width() / $siteWidth;\n\t\t\t$resizeFactor         = 1 - ( ( 1 - $windowSiteWidthRatio ) * $sensitivity );\n\n\t\t\t// If window width is smaller than site width then let's adjust the headings\n\t\t\tif ( jQuery( window ).width() <= $siteWidth ) {\n\n\t\t\t\t// Loop over all heading tegs\n\t\t\t\tjQuery( $elements ).each( function() {\n\n\t\t\t\t\t// Only decrease font-size if the we stay above $minimumFontSize\n\t\t\t\t\tif ( jQuery( this ).data( 'fontsize' ) * $resizeFactor > $minimumFontSize ) {\n\t\t\t\t\t\tjQuery( this ).css( {\n\t\t\t\t\t\t\t'font-size': Math.round( jQuery( this ).data( 'fontsize' ) * $resizeFactor * 1000 ) / 1000,\n\t\t\t\t\t\t\t'line-height': ( Math.round( jQuery( this ).data( 'lineheight' ) * $resizeFactor * 1000 ) / 1000 ) + 'px'\n\t\t\t\t\t\t});\n\n\t\t\t\t\t// If decreased font size would become too small, natural font size is above $minimumFontSize, set font size to $minimumFontSize\n\t\t\t\t\t} else if ( jQuery( this ).data( 'fontsize' ) > $minimumFontSize ) {\n\t\t\t\t\t\tjQuery( this ).css( {\n\t\t\t\t\t\t\t'font-size': $minimumFontSize,\n\t\t\t\t\t\t\t'line-height': ( Math.round( jQuery( this ).data( 'lineheight' ) * $minimumFontSize / jQuery( this ).data( 'fontsize' ) * 1000 ) / 1000 ) + 'px'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t// If window width is larger than site width, delete any resizing styles\n\t\t\t} else {\n\t\t\t\tjQuery( $elements ).each( function() {\n\n\t\t\t\t\t// If initially an inline font size was set, restore it\n\t\t\t\t\tif ( jQuery( this ).data( 'inline-fontsize' ) ) {\n\t\t\t\t\t\tjQuery( this ).css( 'font-size', jQuery( this ).data( 'fontsize' ) );\n\n\t\t\t\t\t// Otherwise remove inline font size\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjQuery( this ).css( 'font-size', '' );\n\t\t\t\t\t}\n\n\t\t\t\t\t// If initially an inline line height was set, restore it\n\t\t\t\t\tif ( jQuery( this ).data( 'inline-lineheight' ) ) {\n\t\t\t\t\t\tjQuery( this ).css( 'line-height', jQuery( this ).data( 'lineheight' ) + 'px' );\n\n\t\t\t\t\t// Otherwise remove inline line height\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjQuery( this ).css( 'line-height', '' );\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tcalculateValues();\n\n\t\tjQuery( window ).on( 'resize orientationchange', calculateValues );\n\t};\n\n\tvar elements = $('*[data-inline-fontsize=true]');\n\tcalculateResponsiveTypeValues( 1240, true, 1.15, 768, elements);\n\n\tjQuery( window ).on( 'mgzResponsiveTypography', function() {\n\t\tvar elements = $('*[data-inline-fontsize=true]');\n\t\tcalculateResponsiveTypeValues( 1240, true, 1.15, 768, elements);\t\t\n\t} );\n});","Magezon_Builder/js/carousel.js":"define([\n    'jquery',\n    'jquery-ui-modules/widget',\n    'Magezon_Core/js/owl.carousel.min'\n], function ($) {\n    'use strict';\n\n/**\n * Animate Plugin\n * @version 2.3.4\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function($, window, document, undefined) {\n\n    /**\n     * Creates the animate plugin.\n     * @class The Navigation Plugin\n     * @param {Owl} scope - The Owl Carousel\n     */\n    var Animate = function(scope) {\n        this.core = scope;\n        this.core.options = $.extend({}, Animate.Defaults, this.core.options);\n        this.swapping = true;\n        this.previous = undefined;\n        this.next = undefined;\n\n        this.handlers = {\n            'change.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && e.property.name == 'position') {\n                    this.previous = this.core.current();\n                    this.next = e.property.value;\n                }\n            }, this),\n            'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {\n                if (e.namespace) {\n                    this.swapping = e.type == 'translated';\n                }\n            }, this),\n            'translate.owl.carousel': $.proxy(function(e) {\n                if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\n                    this.swap();\n                }\n            }, this)\n        };\n\n        this.core.$element.on(this.handlers);\n    };\n\n    /**\n     * Default options.\n     * @public\n     */\n    Animate.Defaults = {\n        animateOut: false,\n        animateIn: false\n    };\n\n    /**\n     * Toggles the animation classes whenever an translations starts.\n     * @protected\n     * @returns {Boolean|undefined}\n     */\n    Animate.prototype.swap = function() {\n\n        if (this.core.settings.items !== 1) {\n            return;\n        }\n\n        if (!$.support.animation || !$.support.transition) {\n            return;\n        }\n\n        this.core.speed(0);\n\n        var left,\n            clear = $.proxy(this.clear, this),\n            previous = this.core.$stage.children().eq(this.previous),\n            next = this.core.$stage.children().eq(this.next),\n            incoming = this.core.settings.animateIn,\n            outgoing = this.core.settings.animateOut;\n\n        if (this.core.current() === this.previous) {\n            return;\n        }\n\n        if (outgoing) {\n            left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\n            previous.one($.support.animation.end, clear)\n                .css( { 'left': left + 'px' } )\n                .addClass('animated owl-animated-out')\n                .addClass(outgoing);\n        }\n\n        if (incoming) {\n            next.one($.support.animation.end, clear)\n                .addClass('animated owl-animated-in')\n                .addClass(incoming);\n        }\n    };\n\n    Animate.prototype.clear = function(e) {\n        $(e.currentTarget).css( { 'left': '' } )\n            .removeClass('animated owl-animated-out owl-animated-in')\n            .removeClass(this.core.settings.animateIn)\n            .removeClass(this.core.settings.animateOut);\n        this.core.onTransitionEnd();\n    };\n\n    /**\n     * Destroys the plugin.\n     * @public\n     */\n    Animate.prototype.destroy = function() {\n        var handler, property;\n\n        for (handler in this.handlers) {\n            this.core.$element.off(handler, this.handlers[handler]);\n        }\n        for (property in Object.getOwnPropertyNames(this)) {\n            typeof this[property] != 'function' && (this[property] = null);\n        }\n    };\n\n    $.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\n\n})(window.Zepto || window.jQuery, window, document);\n\n\n    $.widget('magezon.carousel', {\n        options: {\n            item_xs: 1,\n            item_sm: 1,\n            item_md: 1,\n            item_lg: 1,\n            item_xl: 1,\n            items: 3,\n            loop: false,\n            center: false,\n            rewind: false,\n            checkVisibility: true,\n            \n            mouseDrag: true,\n            touchDrag: true,\n            pullDrag: true,\n            freeDrag: false,\n            \n            margin: 0,\n            stagePadding: 0,\n            \n            merge: false,\n            mergeFit: true,\n            autoWidth: false,\n            \n            startPosition: 0,\n            rtl: false,\n            \n            smartSpeed: 250,\n            fluidSpeed: false,\n            dragEndSpeed: false,\n            \n            responsive: {},\n            responsiveRefreshRate: 200,\n            responsiveBaseElement: window,\n            \n            fallbackEasing: 'swing',\n            slideTransition: '',\n            \n            info: false,\n            \n            nestedItemSelector: false,\n            itemElement: 'div',\n            stageElement: 'div',\n            \n            refreshClass: 'owl-refresh',\n            loadedClass: 'owl-loaded',\n            loadingClass: 'owl-loading',\n            rtlClass: 'owl-rtl',\n            responsiveClass: 'owl-responsive',\n            dragClass: 'owl-drag',\n            itemClass: 'owl-item',\n            stageClass: 'owl-stage',\n            stageOuterClass: 'owl-stage-outer',\n            grabClass: 'owl-grab',\n            autoHeight: true,\n            navText: ['<i class=\"fas mgz-fa-angle-left\"/>','<i class=\"fas mgz-fa-angle-right\"/>'],\n            animateOut: '',\n            animateIn: ''\n        },\n\n        _create: function () {\n\n            var self = this;\n            var options = this.options;\n\n            options['responsive'] = {\n                0: {'items': parseInt(options.item_xs)},\n                544: {'items': parseInt(options.item_sm)},\n                768: {'items': parseInt(options.item_md)},\n                992: {'items': parseInt(options.item_lg)},\n                1200: {'items': parseInt(options.item_xl)}\n            };\n            \n            function setAnimation ( _elem, _InOut ) {\n                var animationEndEvent = 'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend';\n                _elem.each(function() {\n                    var $elem = $(this);\n                    var $animationType = 'animated ' + $elem.data( 'animate-' + _InOut );\n                    var $animationDelay = $elem.data('animate-delay') ? $elem.data('animate-delay') + 's' : 0;\n                    $elem.css('-webkit-animation-delay', $animationDelay)\n                    .css('-moz-animation-delay', $animationDelay)\n                    .css('-ms-animation-delay', $animationDelay)\n                    .css('-o-animation-delay', $animationDelay)\n                    .css('animation-delay', $animationDelay);\n                    $elem.addClass($animationType).one(animationEndEvent, function () {\n                        $elem.removeClass($animationType);\n                    });\n                });\n            }\n\n            var firstSlide   = this.element.find('.item:eq(0)');\n            var $elemsToanim = firstSlide.find(\"[data-animate-in]\");\n            setAnimation ($elemsToanim, 'in');\n\n            var owl = this.element.owlCarousel(options);\n\n            owl.on('change.owl.carousel', function(event) {\n                var $currentItem = $('.owl-item', owl).eq(event.item.index);\n                var $elemsToanim = $currentItem.find(\"[data-animate-out]\");\n                setAnimation ($elemsToanim, 'out');\n            });\n\n            owl.on('changed.owl.carousel', function(event) {\n                var $currentItem = $('.owl-item', owl).eq(event.item.index);\n                var $elemsToanim = $currentItem.find(\"[data-animate-in]\");\n                setAnimation ($elemsToanim, 'in');\n                self.element.find('.owl-item').removeClass('owl-fadeUp-out');\n            });\n        }\n    });\n\n    return $.magezon.carousel;\n});","Magezon_Builder/js/tabs.js":"define([\n    'jquery',\n    'jquery-ui-modules/widget'\n], function ($) {\n    'use strict';\n\n    $.widget('magezon.mgzTabs', {\n        _create: function () {\n            var self = this;\n\n            $('.mgz-tabs-tab-content:not(.mgz-active) .owl-carousel').addClass('mgz-carousel-hidden');\n\n            var $tabsList    = this.element.children('.mgz-tabs-nav');\n            var $tabsContent = this.element.children('.mgz-tabs-content');\n            $tabsList.children('.mgz-tabs-tab-title').each(function(index, el) {\n                var outerHTML = $(this)[0].outerHTML;\n                var anchor    = $(this).children('a');\n                var targetId  = $(this).children('a').data('id');\n                if (targetId) {\n                    self.element.find(targetId).before(outerHTML);\n                }\n            });\n\n            var activeTab = function(tab) {\n                $tabsList.children().removeClass('mgz-active');\n                $tabsContent.children().removeClass('mgz-active');\n                var parentId = tab.parent().attr('data-id');\n                self.element.find('.' + parentId).addClass('mgz-active');\n                var targetId = tab.data('id') ? tab.data('id') : tab.attr('href');\n                var target = self.element.find(targetId);\n                target.addClass('mgz-active');\n                $(self.element).parents('.mgz-element').trigger('mgz:change');\n                setTimeout(function() {\n                    target.find('.owl-carousel.mgz-carousel-hidden').removeClass('mgz-carousel-hidden');\n                }, 500);\n\n                return true;\n            }\n\n            if (this.options.hover_active) {\n                $tabsList.children().hover(function(e) {\n                    activeTab($(this).children('a'));\n                });\n            }\n\n            $tabsList.children().click(function(e) {\n                if ($(this).children('a').attr('href').indexOf('#') !== -1) {\n                    e.preventDefault();\n                    activeTab($(this).children('a'));\n                    return false;\n                }\n            });\n\n            $tabsContent.children('.mgz-tabs-tab-title').click(function(e) {\n                e.preventDefault();\n                activeTab($(this).children('a'));\n                return false;\n            });\n        }\n    });\n\n    return $.magezon.mgzTabs;\n});","Magezon_Builder/js/parallax.js":"define([\n \t'jquery',\n \t'jarallax',\n \t'jarallaxVideo',\n], function ($) {\n\n\tvar $wnd = $(window);\n\tvar $doc = $(document);\n\t\n\tvar throttle = function ( delay, noTrailing, callback, debounceMode ) {\n\t\t/*\n\t\t * After wrapper has stopped being called, this timeout ensures that\n\t\t * `callback` is executed at the proper times in `throttle` and `end`\n\t\t * debounce modes.\n\t\t */\n\t\tvar timeoutID;\n\t\tvar cancelled = false;\n\n\t\t// Keep track of the last time `callback` was executed.\n\t\tvar lastExec = 0;\n\n\t\t// Function to clear existing timeout\n\t\tfunction clearExistingTimeout () {\n\t\t\tif ( timeoutID ) {\n\t\t\t\tclearTimeout(timeoutID);\n\t\t\t}\n\t\t}\n\n\t\t// Function to cancel next exec\n\t\tfunction cancel () {\n\t\t\tclearExistingTimeout();\n\t\t\tcancelled = true;\n\t\t}\n\n\n\t\t// `noTrailing` defaults to falsy.\n\t\tif ( typeof noTrailing !== 'boolean' ) {\n\t\t\tdebounceMode = callback;\n\t\t\tcallback = noTrailing;\n\t\t\tnoTrailing = undefined;\n\t\t}\n\n\t\t/*\n\t\t * The `wrapper` function encapsulates all of the throttling / debouncing\n\t\t * functionality and when executed will limit the rate at which `callback`\n\t\t * is executed.\n\t\t */\n\t\tfunction wrapper () {\n\n\t\t\tvar self = this;\n\t\t\tvar elapsed = Date.now() - lastExec;\n\t\t\tvar args = arguments;\n\n\t\t\tif (cancelled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Execute `callback` and update the `lastExec` timestamp.\n\t\t\tfunction exec () {\n\t\t\t\tlastExec = Date.now();\n\t\t\t\tcallback.apply(self, args);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If `debounceMode` is true (at begin) this is used to clear the flag\n\t\t\t * to allow future `callback` executions.\n\t\t\t */\n\t\t\tfunction clear () {\n\t\t\t\ttimeoutID = undefined;\n\t\t\t}\n\n\t\t\tif ( debounceMode && !timeoutID ) {\n\t\t\t\t/*\n\t\t\t\t * Since `wrapper` is being called for the first time and\n\t\t\t\t * `debounceMode` is true (at begin), execute `callback`.\n\t\t\t\t */\n\t\t\t\texec();\n\t\t\t}\n\n\t\t\tclearExistingTimeout();\n\n\t\t\tif ( debounceMode === undefined && elapsed > delay ) {\n\t\t\t\t/*\n\t\t\t\t * In throttle mode, if `delay` time has been exceeded, execute\n\t\t\t\t * `callback`.\n\t\t\t\t */\n\t\t\t\texec();\n\n\t\t\t} else if ( noTrailing !== true ) {\n\t\t\t\t/*\n\t\t\t\t * In trailing throttle mode, since `delay` time has not been\n\t\t\t\t * exceeded, schedule `callback` to execute `delay` ms after most\n\t\t\t\t * recent execution.\n\t\t\t\t *\n\t\t\t\t * If `debounceMode` is true (at begin), schedule `clear` to execute\n\t\t\t\t * after `delay` ms.\n\t\t\t\t *\n\t\t\t\t * If `debounceMode` is false (at end), schedule `callback` to\n\t\t\t\t * execute after `delay` ms.\n\t\t\t\t */\n\t\t\t\ttimeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n\t\t\t}\n\n\t\t}\n\n\t\twrapper.cancel = cancel;\n\n\t\t// Return the wrapper function.\n\t\treturn wrapper;\n\n\t}\n\n\tvar isMobile = /Android|iPhone|iPad|iPod|BlackBerry|Windows Phone/g.test(navigator.userAgent || navigator.vendor || window.opera);\n\n\tvar wndW = 0;\n\tvar wndH = 0;\n\t\twndW = $wnd.width();\n\t\twndH = $wnd.height();\n\t$wnd.on( 'resize load orientationchange', function() {\n\t\twndW = $wnd.width();\n\t    wndH = $wnd.height();\n\t});\n\n\t/**\n\t * In Viewport checker\n\t * return visible percent from 0 to 1\n\t *\n\t * @param {Object} $item - jQuery object.\n\t * @param {Bool} returnRect - return array with result and rect.\n\t *\n\t * @return {Mixed} - in viewport flag.\n\t */\n\tfunction isInViewport( $item, returnRect ) {\n\t    var rect = $item[ 0 ].getBoundingClientRect();\n\t    var result = 1;\n\n\t    if ( rect.right <= 0 || rect.left >= wndW ) {\n\t        result = 0;\n\t    } else if ( rect.bottom < 0 && rect.top <= wndH ) {\n\t        result = 0;\n\t    } else {\n\t        var beforeTopEnd = Math.max( 0, rect.height + rect.top );\n\t        var beforeBottomEnd = Math.max( 0, rect.height - ( rect.top + rect.height - wndH ) );\n\t        var afterTop = Math.max( 0, -rect.top );\n\t        var beforeBottom = Math.max( 0, rect.top + rect.height - wndH );\n\n\t        if ( rect.height < wndH ) {\n\t            result = 1 - ( ( afterTop || beforeBottom ) / rect.height );\n\t        } else if ( beforeTopEnd <= wndH ) {\n\t            result = beforeTopEnd / wndH;\n\t        } else if ( beforeBottomEnd <= wndH ) {\n\t            result = beforeBottomEnd / wndH;\n\t        }\n\t        result = result < 0 ? 0 : result;\n\t    }\n\t    if ( returnRect ) {\n\t        return [ result, rect ];\n\t    }\n\t    return result;\n\t}\n\n\n\t/**\n\t * Mouse Parallax\n\t */\n\tvar $parallaxMouseList = false;\n\tvar parallaxMouseTimeout;\n\tvar parallaxMouseFirstRun = 1;\n\n\t// run parallax animation\n\tfunction parallaxMouseRun( x, y, deviceOrientation ) {\n\t    var data;\n\t    var itemX;\n\t    var itemY;\n\t    $parallaxMouseList.each( function() {\n\t        var $this = $( this );\n\t        data = $this.data( 'parallax-mouse-data' );\n\n\t        // don't animate if block isn't in viewport\n\t        if ( typeof data !== 'object' || ( ! data.is_in_viewport && ! ( deviceOrientation && parallaxMouseFirstRun ) ) ) {\n\t            return;\n\t        }\n\n\t        // device acceleration calculate\n\t        if ( deviceOrientation ) {\n\t            itemX = -data.size * x;\n\t            itemY = -data.size * y;\n\n\t        // mouse calculate\n\t        } else {\n\t            itemX = ( data.rect.width - ( x - data.rect.left ) ) / data.rect.width;\n\t            itemY = ( data.rect.height - ( y - data.rect.top ) ) / data.rect.height;\n\t            if ( itemX > 1 || itemX < 0 || itemY > 1 || itemY < 0 ) {\n\t                itemX = 0.5;\n\t                itemY = 0.5;\n\t            }\n\t            itemX = data.size * ( itemX - 0.5 ) * 2;\n\t            itemY = data.size * ( itemY - 0.5 ) * 2;\n\t        }\n\n\t        // if first run orientation on device, set default values without animation\n\t        if ( deviceOrientation && parallaxMouseFirstRun ) {\n\t            $this.css( {\n\t                transform: `translateX(${ itemX }px) translateY(${ itemY }px) translateZ(0)`,\n\t            } );\n\t        } else {\n\t            $this.css( {\n\t                transition: `transform ${ deviceOrientation ? 2 : data.speed }s  cubic-bezier(0.22, 0.63, 0.6, 0.88)`,\n\t                transform: `translateX(${ itemX }px) translateY(${ itemY }px) translateZ(0)`,\n\t            } );\n\t        }\n\t    } );\n\t    parallaxMouseFirstRun = 0;\n\t}\n\tvar throttledParallaxMouseRun = throttle( 200, ( x, y, deviceOrientation ) => {\n\t    parallaxMouseRun( x, y, deviceOrientation );\n\t});\n\n\twindow.mgzParallaxMouse = function ( force ) {\n\t    function run() {\n\t        var $newParallax = $( '.mgz-parallax.mgz-parallax-mouse-parallax' ).children( '.mgz-parallax-inner' );\n\t        if ( $newParallax.length ) {\n\t            // add new parallax blocks\n\t            if ( $parallaxMouseList ) {\n\t                $parallaxMouseList = $newParallax;\n\n\t                // first init parallax\n\t            } else {\n\t                $parallaxMouseList = $newParallax;\n\n\t                if ( isMobile && window.DeviceOrientationEvent ) {\n\t                    $wnd.on( 'deviceorientation', ( event ) => {\n\t                        throttledParallaxMouseRun( event.originalEvent.gamma / 90, event.originalEvent.beta / 180, true );\n\t                    } );\n\n\t                // no smooth on firefox\n\t                } else {\n\t                    $wnd.on( 'mousemove', ( event ) => {\n\t                        throttledParallaxMouseRun( event.clientX, event.clientY );\n\t                    } );\n\t                }\n\t            }\n\t        }\n\n\t        // update data for parallax blocks\n\t        if ( $parallaxMouseList ) {\n\t            $parallaxMouseList.each( function() {\n\t\t\t\t\tvar $this   = $( this );\n\t\t\t\t\tvar $elem   = $( this ).closest('.mgz-element');\n\t\t\t\t\tvar $parent = $this.parent();\n\t\t\t\t\tvar size    = parseFloat( $parent.attr( 'data-parallax-mouse-parallax-size' ) ) || 30;\n\t\t\t\t\tvar speed   = parseFloat( $parent.attr( 'data-parallax-mouse-parallax-speed' ) ) || 10000;\n\t                $this.data( 'parallax-mouse-data', {\n\t                    is_in_viewport: isInViewport( $parent ) ? $elem.is( ':visible' ) : 0,\n\t                    rect: $parent[ 0 ].getBoundingClientRect(),\n\t                    size,\n\t                    speed: speed / 1000,\n\t                } );\n\t                $this.css( {\n\t                    left: -size,\n\t                    right: -size,\n\t                    top: -size,\n\t                    bottom: -size,\n\t                } );\n\t            } );\n\t        }\n\t    }\n\n\t    // run force without timeout\n\t    clearTimeout( parallaxMouseTimeout );\n\t    if ( force ) {\n\t        run();\n\t    } else {\n\t        parallaxMouseTimeout = setTimeout( parallaxMouseTimeout, 100 );\n\t    }\n\t}\n\t$wnd.on( 'resize scroll orientationchange load', window.mgzParallaxMouse );\n\n\tsetInterval( window.mgzParallaxMouse, 3000 );\n\n\t$(document).find('.mgz-parallax').each(function(index, el) {\n\t\tvar $this           = $( this );\n\t\tvar backgroundType  = $this.attr( 'data-background-type' );\n\t\tvar imageBgSize     = $this.attr( 'data-parallax-image-background-size' );\n\t\tvar imageBgPosition = $this.attr( 'data-parallax-image-background-position' );\n\t\tvar video           = false;\n\t\tvar videoStartTime  = 0;\n\t\tvar videoEndTime    = 0;\n\t\tvar videoVolume     = 0;\n\t\tvar videoLoop       = true;\n\t\tvar videoAlwaysPlay = true;\n\t\tvar videoMobile     = false;\n\t\tvar parallax        = $this.attr( 'data-parallax-type' );\n\t\tvar parallaxSpeed   = $this.attr( 'data-parallax-speed' );\n\t\tvar parallaxMobile  = $this.attr( 'data-parallax-mobile' ) === 'true' || $this.attr( 'data-parallax-mobile' ) === '1';\n\n        // video type\n        if ( backgroundType === 'yt_vm_video' || backgroundType === 'video' ) {\n\t\t\tvideo           = $this.attr( 'data-parallax-video' );\n\t\t\tvideoStartTime  = parseFloat( $this.attr( 'data-parallax-video-start-time' ) ) || 0;\n\t\t\tvideoEndTime    = parseFloat( $this.attr( 'data-parallax-video-end-time' ) ) || 0;\n\t\t\tvideoVolume     = parseFloat( $this.attr( 'data-parallax-video-volume' ) ) || 0;\n\t\t\tvideoLoop       = $this.attr( 'data-parallax-video-loop' ) !== 'false';\n\t\t\tvideoAlwaysPlay = $this.attr( 'data-parallax-video-always-play' ) === 'true';\n\t\t\tvideoMobile     = $this.attr( 'data-parallax-video-mobile' ) === '1' || $this.attr( 'data-parallax-video-mobile' ) === 'true';\n\n            if ( video && ! parallax && ! parallaxSpeed ) {\n\t\t\t\tparallax       = 'scroll';\n\t\t\t\tparallaxSpeed  = 1;\n\t\t\t\tparallaxMobile = videoMobile;\n            }\n        }\n\n        // prevent if no parallax and no video\n        if ( ! parallax && ! video ) return;\n\n        var jarallaxParams = {\n        \tautomaticResize: true,\n        \ttype: parallax,\n        \tspeed: parallaxSpeed,\n        \tdisableParallax() {\n        \t\treturn parallaxMobile ? false : isMobile;\n        \t},\n        \tdisableVideo() {\n        \t\treturn videoMobile ? false : isMobile;\n        \t},\n        \timgSize: imageBgSize || 'cover',\n        \timgPosition: imageBgPosition || '50% 50%',\n        };\n\n        if ( imageBgSize === 'pattern' ) {\n\t\t\tjarallaxParams.imgSize   = 'auto';\n\t\t\tjarallaxParams.imgRepeat = 'repeat';\n        }\n\n        if ( video ) {\n\t\t\tjarallaxParams.speed                = parallax ? parallaxSpeed : 1;\n\t\t\tjarallaxParams.videoSrc             = video;\n\t\t\tjarallaxParams.videoStartTime       = videoStartTime;\n\t\t\tjarallaxParams.videoEndTime         = videoEndTime;\n\t\t\tjarallaxParams.videoVolume          = videoVolume;\n\t\t\tjarallaxParams.videoLoop            = videoLoop;\n\t\t\tjarallaxParams.videoPlayOnlyVisible = ! videoAlwaysPlay;\n        }\n\t\tjarallax($this.children( '.mgz-parallax-inner' ), jarallaxParams);\n\t});\n});","Magezon_Builder/js/cm/mode/javascript/javascript.js":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\da-f]+|o[0-7]+|b[01]+)n?/i)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:n|(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*.*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/]/.test(ch)) {\n        return;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), className, poplex); }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typeexpr, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, block, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), expression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    if (type == \"import\") return cont(expression);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^>]|<.*?>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"keyof\" ? typeexpr : expressionNoComma)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\", \",;\"), poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), typeprop)\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(pattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybeinof);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return pass(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(isTS ? classfield : functiondef, classBody);\n    }\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), isTS ? classfield : functiondef, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \";\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    return pass(functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      var top = state.cc[state.cc.length - 1]\n      if (top == expression || top == expressionNoComma) state.cc.pop()\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n","Magezon_Builder/js/cm/mode/css/css.js":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"css\", function(config, parserConfig) {\n  var inline = parserConfig.inline\n  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode(\"text/css\");\n\n  var indentUnit = config.indentUnit,\n      tokenHooks = parserConfig.tokenHooks,\n      documentTypes = parserConfig.documentTypes || {},\n      mediaTypes = parserConfig.mediaTypes || {},\n      mediaFeatures = parserConfig.mediaFeatures || {},\n      mediaValueKeywords = parserConfig.mediaValueKeywords || {},\n      propertyKeywords = parserConfig.propertyKeywords || {},\n      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},\n      fontProperties = parserConfig.fontProperties || {},\n      counterDescriptors = parserConfig.counterDescriptors || {},\n      colorKeywords = parserConfig.colorKeywords || {},\n      valueKeywords = parserConfig.valueKeywords || {},\n      allowNested = parserConfig.allowNested,\n      lineComment = parserConfig.lineComment,\n      supportsAtComponent = parserConfig.supportsAtComponent === true;\n\n  var type, override;\n  function ret(style, tp) { type = tp; return style; }\n\n  // Tokenizers\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (tokenHooks[ch]) {\n      var result = tokenHooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == \"@\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"def\", stream.current());\n    } else if (ch == \"=\" || (ch == \"~\" || ch == \"|\") && stream.eat(\"=\")) {\n      return ret(null, \"compare\");\n    } else if (ch == \"\\\"\" || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \"#\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"atom\", \"hash\");\n    } else if (ch == \"!\") {\n      stream.match(/^\\s*\\w*/);\n      return ret(\"keyword\", \"important\");\n    } else if (/\\d/.test(ch) || ch == \".\" && stream.eat(/\\d/)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret(\"number\", \"unit\");\n    } else if (ch === \"-\") {\n      if (/[\\d.]/.test(stream.peek())) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret(\"number\", \"unit\");\n      } else if (stream.match(/^-[\\w\\\\\\-]+/)) {\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return ret(\"variable-2\", \"variable-definition\");\n        return ret(\"variable-2\", \"variable\");\n      } else if (stream.match(/^\\w+-/)) {\n        return ret(\"meta\", \"meta\");\n      }\n    } else if (/[,+>*\\/]/.test(ch)) {\n      return ret(null, \"select-op\");\n    } else if (ch == \".\" && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n      return ret(\"qualifier\", \"qualifier\");\n    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n      return ret(null, ch);\n    } else if (((ch == \"u\" || ch == \"U\") && stream.match(/rl(-prefix)?\\(/i)) ||\n               ((ch == \"d\" || ch == \"D\") && stream.match(\"omain(\", true, true)) ||\n               ((ch == \"r\" || ch == \"R\") && stream.match(\"egexp(\", true, true))) {\n      stream.backUp(1);\n      state.tokenize = tokenParenthesized;\n      return ret(\"property\", \"word\");\n    } else if (/[\\w\\\\\\-]/.test(ch)) {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"property\", \"word\");\n    } else {\n      return ret(null, null);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          if (quote == \")\") stream.backUp(1);\n          break;\n        }\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      if (ch == quote || !escaped && quote != \")\") state.tokenize = null;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenParenthesized(stream, state) {\n    stream.next(); // Must be '('\n    if (!stream.match(/\\s*[\\\"\\')]/, false))\n      state.tokenize = tokenString(\")\");\n    else\n      state.tokenize = null;\n    return ret(null, \"(\");\n  }\n\n  // Context management\n\n  function Context(type, indent, prev) {\n    this.type = type;\n    this.indent = indent;\n    this.prev = prev;\n  }\n\n  function pushContext(state, stream, type, indent) {\n    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);\n    return type;\n  }\n\n  function popContext(state) {\n    if (state.context.prev)\n      state.context = state.context.prev;\n    return state.context.type;\n  }\n\n  function pass(type, stream, state) {\n    return states[state.context.type](type, stream, state);\n  }\n  function popAndPass(type, stream, state, n) {\n    for (var i = n || 1; i > 0; i--)\n      state.context = state.context.prev;\n    return pass(type, stream, state);\n  }\n\n  // Parser\n\n  function wordAsValue(stream) {\n    var word = stream.current().toLowerCase();\n    if (valueKeywords.hasOwnProperty(word))\n      override = \"atom\";\n    else if (colorKeywords.hasOwnProperty(word))\n      override = \"keyword\";\n    else\n      override = \"variable\";\n  }\n\n  var states = {};\n\n  states.top = function(type, stream, state) {\n    if (type == \"{\") {\n      return pushContext(state, stream, \"block\");\n    } else if (type == \"}\" && state.context.prev) {\n      return popContext(state);\n    } else if (supportsAtComponent && /@component/i.test(type)) {\n      return pushContext(state, stream, \"atComponentBlock\");\n    } else if (/^@(-moz-)?document$/i.test(type)) {\n      return pushContext(state, stream, \"documentTypes\");\n    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {\n      return pushContext(state, stream, \"atBlock\");\n    } else if (/^@(font-face|counter-style)/i.test(type)) {\n      state.stateArg = type;\n      return \"restricted_atBlock_before\";\n    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {\n      return \"keyframes\";\n    } else if (type && type.charAt(0) == \"@\") {\n      return pushContext(state, stream, \"at\");\n    } else if (type == \"hash\") {\n      override = \"builtin\";\n    } else if (type == \"word\") {\n      override = \"tag\";\n    } else if (type == \"variable-definition\") {\n      return \"maybeprop\";\n    } else if (type == \"interpolation\") {\n      return pushContext(state, stream, \"interpolation\");\n    } else if (type == \":\") {\n      return \"pseudo\";\n    } else if (allowNested && type == \"(\") {\n      return pushContext(state, stream, \"parens\");\n    }\n    return state.context.type;\n  };\n\n  states.block = function(type, stream, state) {\n    if (type == \"word\") {\n      var word = stream.current().toLowerCase();\n      if (propertyKeywords.hasOwnProperty(word)) {\n        override = \"property\";\n        return \"maybeprop\";\n      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {\n        override = \"string-2\";\n        return \"maybeprop\";\n      } else if (allowNested) {\n        override = stream.match(/^\\s*:(?:\\s|$)/, false) ? \"property\" : \"tag\";\n        return \"block\";\n      } else {\n        override += \" error\";\n        return \"maybeprop\";\n      }\n    } else if (type == \"meta\") {\n      return \"block\";\n    } else if (!allowNested && (type == \"hash\" || type == \"qualifier\")) {\n      override = \"error\";\n      return \"block\";\n    } else {\n      return states.top(type, stream, state);\n    }\n  };\n\n  states.maybeprop = function(type, stream, state) {\n    if (type == \":\") return pushContext(state, stream, \"prop\");\n    return pass(type, stream, state);\n  };\n\n  states.prop = function(type, stream, state) {\n    if (type == \";\") return popContext(state);\n    if (type == \"{\" && allowNested) return pushContext(state, stream, \"propBlock\");\n    if (type == \"}\" || type == \"{\") return popAndPass(type, stream, state);\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\n\n    if (type == \"hash\" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {\n      override += \" error\";\n    } else if (type == \"word\") {\n      wordAsValue(stream);\n    } else if (type == \"interpolation\") {\n      return pushContext(state, stream, \"interpolation\");\n    }\n    return \"prop\";\n  };\n\n  states.propBlock = function(type, _stream, state) {\n    if (type == \"}\") return popContext(state);\n    if (type == \"word\") { override = \"property\"; return \"maybeprop\"; }\n    return state.context.type;\n  };\n\n  states.parens = function(type, stream, state) {\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n    if (type == \")\") return popContext(state);\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n    if (type == \"word\") wordAsValue(stream);\n    return \"parens\";\n  };\n\n  states.pseudo = function(type, stream, state) {\n    if (type == \"meta\") return \"pseudo\";\n\n    if (type == \"word\") {\n      override = \"variable-3\";\n      return state.context.type;\n    }\n    return pass(type, stream, state);\n  };\n\n  states.documentTypes = function(type, stream, state) {\n    if (type == \"word\" && documentTypes.hasOwnProperty(stream.current())) {\n      override = \"tag\";\n      return state.context.type;\n    } else {\n      return states.atBlock(type, stream, state);\n    }\n  };\n\n  states.atBlock = function(type, stream, state) {\n    if (type == \"(\") return pushContext(state, stream, \"atBlock_parens\");\n    if (type == \"}\" || type == \";\") return popAndPass(type, stream, state);\n    if (type == \"{\") return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\");\n\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n\n    if (type == \"word\") {\n      var word = stream.current().toLowerCase();\n      if (word == \"only\" || word == \"not\" || word == \"and\" || word == \"or\")\n        override = \"keyword\";\n      else if (mediaTypes.hasOwnProperty(word))\n        override = \"attribute\";\n      else if (mediaFeatures.hasOwnProperty(word))\n        override = \"property\";\n      else if (mediaValueKeywords.hasOwnProperty(word))\n        override = \"keyword\";\n      else if (propertyKeywords.hasOwnProperty(word))\n        override = \"property\";\n      else if (nonStandardPropertyKeywords.hasOwnProperty(word))\n        override = \"string-2\";\n      else if (valueKeywords.hasOwnProperty(word))\n        override = \"atom\";\n      else if (colorKeywords.hasOwnProperty(word))\n        override = \"keyword\";\n      else\n        override = \"error\";\n    }\n    return state.context.type;\n  };\n\n  states.atComponentBlock = function(type, stream, state) {\n    if (type == \"}\")\n      return popAndPass(type, stream, state);\n    if (type == \"{\")\n      return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\", false);\n    if (type == \"word\")\n      override = \"error\";\n    return state.context.type;\n  };\n\n  states.atBlock_parens = function(type, stream, state) {\n    if (type == \")\") return popContext(state);\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state, 2);\n    return states.atBlock(type, stream, state);\n  };\n\n  states.restricted_atBlock_before = function(type, stream, state) {\n    if (type == \"{\")\n      return pushContext(state, stream, \"restricted_atBlock\");\n    if (type == \"word\" && state.stateArg == \"@counter-style\") {\n      override = \"variable\";\n      return \"restricted_atBlock_before\";\n    }\n    return pass(type, stream, state);\n  };\n\n  states.restricted_atBlock = function(type, stream, state) {\n    if (type == \"}\") {\n      state.stateArg = null;\n      return popContext(state);\n    }\n    if (type == \"word\") {\n      if ((state.stateArg == \"@font-face\" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||\n          (state.stateArg == \"@counter-style\" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))\n        override = \"error\";\n      else\n        override = \"property\";\n      return \"maybeprop\";\n    }\n    return \"restricted_atBlock\";\n  };\n\n  states.keyframes = function(type, stream, state) {\n    if (type == \"word\") { override = \"variable\"; return \"keyframes\"; }\n    if (type == \"{\") return pushContext(state, stream, \"top\");\n    return pass(type, stream, state);\n  };\n\n  states.at = function(type, stream, state) {\n    if (type == \";\") return popContext(state);\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n    if (type == \"word\") override = \"tag\";\n    else if (type == \"hash\") override = \"builtin\";\n    return \"at\";\n  };\n\n  states.interpolation = function(type, stream, state) {\n    if (type == \"}\") return popContext(state);\n    if (type == \"{\" || type == \";\") return popAndPass(type, stream, state);\n    if (type == \"word\") override = \"variable\";\n    else if (type != \"variable\" && type != \"(\" && type != \")\") override = \"error\";\n    return \"interpolation\";\n  };\n\n  return {\n    startState: function(base) {\n      return {tokenize: null,\n              state: inline ? \"block\" : \"top\",\n              stateArg: null,\n              context: new Context(inline ? \"block\" : \"top\", base || 0, null)};\n    },\n\n    token: function(stream, state) {\n      if (!state.tokenize && stream.eatSpace()) return null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style && typeof style == \"object\") {\n        type = style[1];\n        style = style[0];\n      }\n      override = style;\n      if (type != \"comment\")\n        state.state = states[state.state](type, stream, state);\n      return override;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context, ch = textAfter && textAfter.charAt(0);\n      var indent = cx.indent;\n      if (cx.type == \"prop\" && (ch == \"}\" || ch == \")\")) cx = cx.prev;\n      if (cx.prev) {\n        if (ch == \"}\" && (cx.type == \"block\" || cx.type == \"top\" ||\n                          cx.type == \"interpolation\" || cx.type == \"restricted_atBlock\")) {\n          // Resume indentation from parent context.\n          cx = cx.prev;\n          indent = cx.indent;\n        } else if (ch == \")\" && (cx.type == \"parens\" || cx.type == \"atBlock_parens\") ||\n            ch == \"{\" && (cx.type == \"at\" || cx.type == \"atBlock\")) {\n          // Dedent relative to current context.\n          indent = Math.max(0, cx.indent - indentUnit);\n        }\n      }\n      return indent;\n    },\n\n    electricChars: \"}\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    blockCommentContinue: \" * \",\n    lineComment: lineComment,\n    fold: \"brace\"\n  };\n});\n\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) {\n      keys[array[i].toLowerCase()] = true;\n    }\n    return keys;\n  }\n\n  var documentTypes_ = [\n    \"domain\", \"regexp\", \"url\", \"url-prefix\"\n  ], documentTypes = keySet(documentTypes_);\n\n  var mediaTypes_ = [\n    \"all\", \"aural\", \"braille\", \"handheld\", \"print\", \"projection\", \"screen\",\n    \"tty\", \"tv\", \"embossed\"\n  ], mediaTypes = keySet(mediaTypes_);\n\n  var mediaFeatures_ = [\n    \"width\", \"min-width\", \"max-width\", \"height\", \"min-height\", \"max-height\",\n    \"device-width\", \"min-device-width\", \"max-device-width\", \"device-height\",\n    \"min-device-height\", \"max-device-height\", \"aspect-ratio\",\n    \"min-aspect-ratio\", \"max-aspect-ratio\", \"device-aspect-ratio\",\n    \"min-device-aspect-ratio\", \"max-device-aspect-ratio\", \"color\", \"min-color\",\n    \"max-color\", \"color-index\", \"min-color-index\", \"max-color-index\",\n    \"monochrome\", \"min-monochrome\", \"max-monochrome\", \"resolution\",\n    \"min-resolution\", \"max-resolution\", \"scan\", \"grid\", \"orientation\",\n    \"device-pixel-ratio\", \"min-device-pixel-ratio\", \"max-device-pixel-ratio\",\n    \"pointer\", \"any-pointer\", \"hover\", \"any-hover\"\n  ], mediaFeatures = keySet(mediaFeatures_);\n\n  var mediaValueKeywords_ = [\n    \"landscape\", \"portrait\", \"none\", \"coarse\", \"fine\", \"on-demand\", \"hover\",\n    \"interlace\", \"progressive\"\n  ], mediaValueKeywords = keySet(mediaValueKeywords_);\n\n  var propertyKeywords_ = [\n    \"align-content\", \"align-items\", \"align-self\", \"alignment-adjust\",\n    \"alignment-baseline\", \"anchor-point\", \"animation\", \"animation-delay\",\n    \"animation-direction\", \"animation-duration\", \"animation-fill-mode\",\n    \"animation-iteration-count\", \"animation-name\", \"animation-play-state\",\n    \"animation-timing-function\", \"appearance\", \"azimuth\", \"backface-visibility\",\n    \"background\", \"background-attachment\", \"background-blend-mode\", \"background-clip\",\n    \"background-color\", \"background-image\", \"background-origin\", \"background-position\",\n    \"background-repeat\", \"background-size\", \"baseline-shift\", \"binding\",\n    \"bleed\", \"bookmark-label\", \"bookmark-level\", \"bookmark-state\",\n    \"bookmark-target\", \"border\", \"border-bottom\", \"border-bottom-color\",\n    \"border-bottom-left-radius\", \"border-bottom-right-radius\",\n    \"border-bottom-style\", \"border-bottom-width\", \"border-collapse\",\n    \"border-color\", \"border-image\", \"border-image-outset\",\n    \"border-image-repeat\", \"border-image-slice\", \"border-image-source\",\n    \"border-image-width\", \"border-left\", \"border-left-color\",\n    \"border-left-style\", \"border-left-width\", \"border-radius\", \"border-right\",\n    \"border-right-color\", \"border-right-style\", \"border-right-width\",\n    \"border-spacing\", \"border-style\", \"border-top\", \"border-top-color\",\n    \"border-top-left-radius\", \"border-top-right-radius\", \"border-top-style\",\n    \"border-top-width\", \"border-width\", \"bottom\", \"box-decoration-break\",\n    \"box-shadow\", \"box-sizing\", \"break-after\", \"break-before\", \"break-inside\",\n    \"caption-side\", \"caret-color\", \"clear\", \"clip\", \"color\", \"color-profile\", \"column-count\",\n    \"column-fill\", \"column-gap\", \"column-rule\", \"column-rule-color\",\n    \"column-rule-style\", \"column-rule-width\", \"column-span\", \"column-width\",\n    \"columns\", \"content\", \"counter-increment\", \"counter-reset\", \"crop\", \"cue\",\n    \"cue-after\", \"cue-before\", \"cursor\", \"direction\", \"display\",\n    \"dominant-baseline\", \"drop-initial-after-adjust\",\n    \"drop-initial-after-align\", \"drop-initial-before-adjust\",\n    \"drop-initial-before-align\", \"drop-initial-size\", \"drop-initial-value\",\n    \"elevation\", \"empty-cells\", \"fit\", \"fit-position\", \"flex\", \"flex-basis\",\n    \"flex-direction\", \"flex-flow\", \"flex-grow\", \"flex-shrink\", \"flex-wrap\",\n    \"float\", \"float-offset\", \"flow-from\", \"flow-into\", \"font\", \"font-feature-settings\",\n    \"font-family\", \"font-kerning\", \"font-language-override\", \"font-size\", \"font-size-adjust\",\n    \"font-stretch\", \"font-style\", \"font-synthesis\", \"font-variant\",\n    \"font-variant-alternates\", \"font-variant-caps\", \"font-variant-east-asian\",\n    \"font-variant-ligatures\", \"font-variant-numeric\", \"font-variant-position\",\n    \"font-weight\", \"grid\", \"grid-area\", \"grid-auto-columns\", \"grid-auto-flow\",\n    \"grid-auto-rows\", \"grid-column\", \"grid-column-end\", \"grid-column-gap\",\n    \"grid-column-start\", \"grid-gap\", \"grid-row\", \"grid-row-end\", \"grid-row-gap\",\n    \"grid-row-start\", \"grid-template\", \"grid-template-areas\", \"grid-template-columns\",\n    \"grid-template-rows\", \"hanging-punctuation\", \"height\", \"hyphens\",\n    \"icon\", \"image-orientation\", \"image-rendering\", \"image-resolution\",\n    \"inline-box-align\", \"justify-content\", \"justify-items\", \"justify-self\", \"left\", \"letter-spacing\",\n    \"line-break\", \"line-height\", \"line-stacking\", \"line-stacking-ruby\",\n    \"line-stacking-shift\", \"line-stacking-strategy\", \"list-style\",\n    \"list-style-image\", \"list-style-position\", \"list-style-type\", \"margin\",\n    \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\",\n    \"marks\", \"marquee-direction\", \"marquee-loop\",\n    \"marquee-play-count\", \"marquee-speed\", \"marquee-style\", \"max-height\",\n    \"max-width\", \"min-height\", \"min-width\", \"move-to\", \"nav-down\", \"nav-index\",\n    \"nav-left\", \"nav-right\", \"nav-up\", \"object-fit\", \"object-position\",\n    \"opacity\", \"order\", \"orphans\", \"outline\",\n    \"outline-color\", \"outline-offset\", \"outline-style\", \"outline-width\",\n    \"overflow\", \"overflow-style\", \"overflow-wrap\", \"overflow-x\", \"overflow-y\",\n    \"padding\", \"padding-bottom\", \"padding-left\", \"padding-right\", \"padding-top\",\n    \"page\", \"page-break-after\", \"page-break-before\", \"page-break-inside\",\n    \"page-policy\", \"pause\", \"pause-after\", \"pause-before\", \"perspective\",\n    \"perspective-origin\", \"pitch\", \"pitch-range\", \"place-content\", \"place-items\", \"place-self\", \"play-during\", \"position\",\n    \"presentation-level\", \"punctuation-trim\", \"quotes\", \"region-break-after\",\n    \"region-break-before\", \"region-break-inside\", \"region-fragment\",\n    \"rendering-intent\", \"resize\", \"rest\", \"rest-after\", \"rest-before\", \"richness\",\n    \"right\", \"rotation\", \"rotation-point\", \"ruby-align\", \"ruby-overhang\",\n    \"ruby-position\", \"ruby-span\", \"shape-image-threshold\", \"shape-inside\", \"shape-margin\",\n    \"shape-outside\", \"size\", \"speak\", \"speak-as\", \"speak-header\",\n    \"speak-numeral\", \"speak-punctuation\", \"speech-rate\", \"stress\", \"string-set\",\n    \"tab-size\", \"table-layout\", \"target\", \"target-name\", \"target-new\",\n    \"target-position\", \"text-align\", \"text-align-last\", \"text-decoration\",\n    \"text-decoration-color\", \"text-decoration-line\", \"text-decoration-skip\",\n    \"text-decoration-style\", \"text-emphasis\", \"text-emphasis-color\",\n    \"text-emphasis-position\", \"text-emphasis-style\", \"text-height\",\n    \"text-indent\", \"text-justify\", \"text-outline\", \"text-overflow\", \"text-shadow\",\n    \"text-size-adjust\", \"text-space-collapse\", \"text-transform\", \"text-underline-position\",\n    \"text-wrap\", \"top\", \"transform\", \"transform-origin\", \"transform-style\",\n    \"transition\", \"transition-delay\", \"transition-duration\",\n    \"transition-property\", \"transition-timing-function\", \"unicode-bidi\",\n    \"user-select\", \"vertical-align\", \"visibility\", \"voice-balance\", \"voice-duration\",\n    \"voice-family\", \"voice-pitch\", \"voice-range\", \"voice-rate\", \"voice-stress\",\n    \"voice-volume\", \"volume\", \"white-space\", \"widows\", \"width\", \"will-change\", \"word-break\",\n    \"word-spacing\", \"word-wrap\", \"z-index\",\n    // SVG-specific\n    \"clip-path\", \"clip-rule\", \"mask\", \"enable-background\", \"filter\", \"flood-color\",\n    \"flood-opacity\", \"lighting-color\", \"stop-color\", \"stop-opacity\", \"pointer-events\",\n    \"color-interpolation\", \"color-interpolation-filters\",\n    \"color-rendering\", \"fill\", \"fill-opacity\", \"fill-rule\", \"image-rendering\",\n    \"marker\", \"marker-end\", \"marker-mid\", \"marker-start\", \"shape-rendering\", \"stroke\",\n    \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\",\n    \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"text-rendering\",\n    \"baseline-shift\", \"dominant-baseline\", \"glyph-orientation-horizontal\",\n    \"glyph-orientation-vertical\", \"text-anchor\", \"writing-mode\"\n  ], propertyKeywords = keySet(propertyKeywords_);\n\n  var nonStandardPropertyKeywords_ = [\n    \"scrollbar-arrow-color\", \"scrollbar-base-color\", \"scrollbar-dark-shadow-color\",\n    \"scrollbar-face-color\", \"scrollbar-highlight-color\", \"scrollbar-shadow-color\",\n    \"scrollbar-3d-light-color\", \"scrollbar-track-color\", \"shape-inside\",\n    \"searchfield-cancel-button\", \"searchfield-decoration\", \"searchfield-results-button\",\n    \"searchfield-results-decoration\", \"zoom\"\n  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);\n\n  var fontProperties_ = [\n    \"font-family\", \"src\", \"unicode-range\", \"font-variant\", \"font-feature-settings\",\n    \"font-stretch\", \"font-weight\", \"font-style\"\n  ], fontProperties = keySet(fontProperties_);\n\n  var counterDescriptors_ = [\n    \"additive-symbols\", \"fallback\", \"negative\", \"pad\", \"prefix\", \"range\",\n    \"speak-as\", \"suffix\", \"symbols\", \"system\"\n  ], counterDescriptors = keySet(counterDescriptors_);\n\n  var colorKeywords_ = [\n    \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\",\n    \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\",\n    \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\",\n    \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\",\n    \"darkgray\", \"darkgreen\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\",\n    \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\",\n    \"darkslateblue\", \"darkslategray\", \"darkturquoise\", \"darkviolet\",\n    \"deeppink\", \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\",\n    \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\",\n    \"gold\", \"goldenrod\", \"gray\", \"grey\", \"green\", \"greenyellow\", \"honeydew\",\n    \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\",\n    \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\",\n    \"lightcyan\", \"lightgoldenrodyellow\", \"lightgray\", \"lightgreen\", \"lightpink\",\n    \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\",\n    \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\",\n    \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\",\n    \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n    \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\",\n    \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\",\n    \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\",\n    \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\",\n    \"purple\", \"rebeccapurple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\",\n    \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\",\n    \"slateblue\", \"slategray\", \"snow\", \"springgreen\", \"steelblue\", \"tan\",\n    \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\",\n    \"whitesmoke\", \"yellow\", \"yellowgreen\"\n  ], colorKeywords = keySet(colorKeywords_);\n\n  var valueKeywords_ = [\n    \"above\", \"absolute\", \"activeborder\", \"additive\", \"activecaption\", \"afar\",\n    \"after-white-space\", \"ahead\", \"alias\", \"all\", \"all-scroll\", \"alphabetic\", \"alternate\",\n    \"always\", \"amharic\", \"amharic-abegede\", \"antialiased\", \"appworkspace\",\n    \"arabic-indic\", \"armenian\", \"asterisks\", \"attr\", \"auto\", \"auto-flow\", \"avoid\", \"avoid-column\", \"avoid-page\",\n    \"avoid-region\", \"background\", \"backwards\", \"baseline\", \"below\", \"bidi-override\", \"binary\",\n    \"bengali\", \"blink\", \"block\", \"block-axis\", \"bold\", \"bolder\", \"border\", \"border-box\",\n    \"both\", \"bottom\", \"break\", \"break-all\", \"break-word\", \"bullets\", \"button\", \"button-bevel\",\n    \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\", \"calc\", \"cambodian\",\n    \"capitalize\", \"caps-lock-indicator\", \"caption\", \"captiontext\", \"caret\",\n    \"cell\", \"center\", \"checkbox\", \"circle\", \"cjk-decimal\", \"cjk-earthly-branch\",\n    \"cjk-heavenly-stem\", \"cjk-ideographic\", \"clear\", \"clip\", \"close-quote\",\n    \"col-resize\", \"collapse\", \"color\", \"color-burn\", \"color-dodge\", \"column\", \"column-reverse\",\n    \"compact\", \"condensed\", \"contain\", \"content\", \"contents\",\n    \"content-box\", \"context-menu\", \"continuous\", \"copy\", \"counter\", \"counters\", \"cover\", \"crop\",\n    \"cross\", \"crosshair\", \"currentcolor\", \"cursive\", \"cyclic\", \"darken\", \"dashed\", \"decimal\",\n    \"decimal-leading-zero\", \"default\", \"default-button\", \"dense\", \"destination-atop\",\n    \"destination-in\", \"destination-out\", \"destination-over\", \"devanagari\", \"difference\",\n    \"disc\", \"discard\", \"disclosure-closed\", \"disclosure-open\", \"document\",\n    \"dot-dash\", \"dot-dot-dash\",\n    \"dotted\", \"double\", \"down\", \"e-resize\", \"ease\", \"ease-in\", \"ease-in-out\", \"ease-out\",\n    \"element\", \"ellipse\", \"ellipsis\", \"embed\", \"end\", \"ethiopic\", \"ethiopic-abegede\",\n    \"ethiopic-abegede-am-et\", \"ethiopic-abegede-gez\", \"ethiopic-abegede-ti-er\",\n    \"ethiopic-abegede-ti-et\", \"ethiopic-halehame-aa-er\",\n    \"ethiopic-halehame-aa-et\", \"ethiopic-halehame-am-et\",\n    \"ethiopic-halehame-gez\", \"ethiopic-halehame-om-et\",\n    \"ethiopic-halehame-sid-et\", \"ethiopic-halehame-so-et\",\n    \"ethiopic-halehame-ti-er\", \"ethiopic-halehame-ti-et\", \"ethiopic-halehame-tig\",\n    \"ethiopic-numeric\", \"ew-resize\", \"exclusion\", \"expanded\", \"extends\", \"extra-condensed\",\n    \"extra-expanded\", \"fantasy\", \"fast\", \"fill\", \"fixed\", \"flat\", \"flex\", \"flex-end\", \"flex-start\", \"footnotes\",\n    \"forwards\", \"from\", \"geometricPrecision\", \"georgian\", \"graytext\", \"grid\", \"groove\",\n    \"gujarati\", \"gurmukhi\", \"hand\", \"hangul\", \"hangul-consonant\", \"hard-light\", \"hebrew\",\n    \"help\", \"hidden\", \"hide\", \"higher\", \"highlight\", \"highlighttext\",\n    \"hiragana\", \"hiragana-iroha\", \"horizontal\", \"hsl\", \"hsla\", \"hue\", \"icon\", \"ignore\",\n    \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\", \"infinite\",\n    \"infobackground\", \"infotext\", \"inherit\", \"initial\", \"inline\", \"inline-axis\",\n    \"inline-block\", \"inline-flex\", \"inline-grid\", \"inline-table\", \"inset\", \"inside\", \"intrinsic\", \"invert\",\n    \"italic\", \"japanese-formal\", \"japanese-informal\", \"justify\", \"kannada\",\n    \"katakana\", \"katakana-iroha\", \"keep-all\", \"khmer\",\n    \"korean-hangul-formal\", \"korean-hanja-formal\", \"korean-hanja-informal\",\n    \"landscape\", \"lao\", \"large\", \"larger\", \"left\", \"level\", \"lighter\", \"lighten\",\n    \"line-through\", \"linear\", \"linear-gradient\", \"lines\", \"list-item\", \"listbox\", \"listitem\",\n    \"local\", \"logical\", \"loud\", \"lower\", \"lower-alpha\", \"lower-armenian\",\n    \"lower-greek\", \"lower-hexadecimal\", \"lower-latin\", \"lower-norwegian\",\n    \"lower-roman\", \"lowercase\", \"ltr\", \"luminosity\", \"malayalam\", \"match\", \"matrix\", \"matrix3d\",\n    \"media-controls-background\", \"media-current-time-display\",\n    \"media-fullscreen-button\", \"media-mute-button\", \"media-play-button\",\n    \"media-return-to-realtime-button\", \"media-rewind-button\",\n    \"media-seek-back-button\", \"media-seek-forward-button\", \"media-slider\",\n    \"media-sliderthumb\", \"media-time-remaining-display\", \"media-volume-slider\",\n    \"media-volume-slider-container\", \"media-volume-sliderthumb\", \"medium\",\n    \"menu\", \"menulist\", \"menulist-button\", \"menulist-text\",\n    \"menulist-textfield\", \"menutext\", \"message-box\", \"middle\", \"min-intrinsic\",\n    \"mix\", \"mongolian\", \"monospace\", \"move\", \"multiple\", \"multiply\", \"myanmar\", \"n-resize\",\n    \"narrower\", \"ne-resize\", \"nesw-resize\", \"no-close-quote\", \"no-drop\",\n    \"no-open-quote\", \"no-repeat\", \"none\", \"normal\", \"not-allowed\", \"nowrap\",\n    \"ns-resize\", \"numbers\", \"numeric\", \"nw-resize\", \"nwse-resize\", \"oblique\", \"octal\", \"opacity\", \"open-quote\",\n    \"optimizeLegibility\", \"optimizeSpeed\", \"oriya\", \"oromo\", \"outset\",\n    \"outside\", \"outside-shape\", \"overlay\", \"overline\", \"padding\", \"padding-box\",\n    \"painted\", \"page\", \"paused\", \"persian\", \"perspective\", \"plus-darker\", \"plus-lighter\",\n    \"pointer\", \"polygon\", \"portrait\", \"pre\", \"pre-line\", \"pre-wrap\", \"preserve-3d\",\n    \"progress\", \"push-button\", \"radial-gradient\", \"radio\", \"read-only\",\n    \"read-write\", \"read-write-plaintext-only\", \"rectangle\", \"region\",\n    \"relative\", \"repeat\", \"repeating-linear-gradient\",\n    \"repeating-radial-gradient\", \"repeat-x\", \"repeat-y\", \"reset\", \"reverse\",\n    \"rgb\", \"rgba\", \"ridge\", \"right\", \"rotate\", \"rotate3d\", \"rotateX\", \"rotateY\",\n    \"rotateZ\", \"round\", \"row\", \"row-resize\", \"row-reverse\", \"rtl\", \"run-in\", \"running\",\n    \"s-resize\", \"sans-serif\", \"saturation\", \"scale\", \"scale3d\", \"scaleX\", \"scaleY\", \"scaleZ\", \"screen\",\n    \"scroll\", \"scrollbar\", \"scroll-position\", \"se-resize\", \"searchfield\",\n    \"searchfield-cancel-button\", \"searchfield-decoration\",\n    \"searchfield-results-button\", \"searchfield-results-decoration\", \"self-start\", \"self-end\",\n    \"semi-condensed\", \"semi-expanded\", \"separate\", \"serif\", \"show\", \"sidama\",\n    \"simp-chinese-formal\", \"simp-chinese-informal\", \"single\",\n    \"skew\", \"skewX\", \"skewY\", \"skip-white-space\", \"slide\", \"slider-horizontal\",\n    \"slider-vertical\", \"sliderthumb-horizontal\", \"sliderthumb-vertical\", \"slow\",\n    \"small\", \"small-caps\", \"small-caption\", \"smaller\", \"soft-light\", \"solid\", \"somali\",\n    \"source-atop\", \"source-in\", \"source-out\", \"source-over\", \"space\", \"space-around\", \"space-between\", \"space-evenly\", \"spell-out\", \"square\",\n    \"square-button\", \"start\", \"static\", \"status-bar\", \"stretch\", \"stroke\", \"sub\",\n    \"subpixel-antialiased\", \"super\", \"sw-resize\", \"symbolic\", \"symbols\", \"system-ui\", \"table\",\n    \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\",\n    \"table-footer-group\", \"table-header-group\", \"table-row\", \"table-row-group\",\n    \"tamil\",\n    \"telugu\", \"text\", \"text-bottom\", \"text-top\", \"textarea\", \"textfield\", \"thai\",\n    \"thick\", \"thin\", \"threeddarkshadow\", \"threedface\", \"threedhighlight\",\n    \"threedlightshadow\", \"threedshadow\", \"tibetan\", \"tigre\", \"tigrinya-er\",\n    \"tigrinya-er-abegede\", \"tigrinya-et\", \"tigrinya-et-abegede\", \"to\", \"top\",\n    \"trad-chinese-formal\", \"trad-chinese-informal\", \"transform\",\n    \"translate\", \"translate3d\", \"translateX\", \"translateY\", \"translateZ\",\n    \"transparent\", \"ultra-condensed\", \"ultra-expanded\", \"underline\", \"unset\", \"up\",\n    \"upper-alpha\", \"upper-armenian\", \"upper-greek\", \"upper-hexadecimal\",\n    \"upper-latin\", \"upper-norwegian\", \"upper-roman\", \"uppercase\", \"urdu\", \"url\",\n    \"var\", \"vertical\", \"vertical-text\", \"visible\", \"visibleFill\", \"visiblePainted\",\n    \"visibleStroke\", \"visual\", \"w-resize\", \"wait\", \"wave\", \"wider\",\n    \"window\", \"windowframe\", \"windowtext\", \"words\", \"wrap\", \"wrap-reverse\", \"x-large\", \"x-small\", \"xor\",\n    \"xx-large\", \"xx-small\"\n  ], valueKeywords = keySet(valueKeywords_);\n\n  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)\n    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)\n    .concat(valueKeywords_);\n  CodeMirror.registerHelper(\"hintWords\", \"css\", allWords);\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == \"/\") {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return [\"comment\", \"comment\"];\n  }\n\n  CodeMirror.defineMIME(\"text/css\", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: \"css\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-scss\", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    lineComment: \"//\",\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return [\"comment\", \"comment\"];\n        } else if (stream.eat(\"*\")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return [\"operator\", \"operator\"];\n        }\n      },\n      \":\": function(stream) {\n        if (stream.match(/\\s*\\{/, false))\n          return [null, null]\n        return false;\n      },\n      \"$\": function(stream) {\n        stream.match(/^[\\w-]+/);\n        if (stream.match(/^\\s*:/, false))\n          return [\"variable-2\", \"variable-definition\"];\n        return [\"variable-2\", \"variable\"];\n      },\n      \"#\": function(stream) {\n        if (!stream.eat(\"{\")) return false;\n        return [null, \"interpolation\"];\n      }\n    },\n    name: \"css\",\n    helperType: \"scss\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-less\", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    lineComment: \"//\",\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return [\"comment\", \"comment\"];\n        } else if (stream.eat(\"*\")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return [\"operator\", \"operator\"];\n        }\n      },\n      \"@\": function(stream) {\n        if (stream.eat(\"{\")) return [null, \"interpolation\"];\n        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\\b/i, false)) return false;\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return [\"variable-2\", \"variable-definition\"];\n        return [\"variable-2\", \"variable\"];\n      },\n      \"&\": function() {\n        return [\"atom\", \"atom\"];\n      }\n    },\n    name: \"css\",\n    helperType: \"less\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-gss\", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    supportsAtComponent: true,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: \"css\",\n    helperType: \"gss\"\n  });\n\n});\n","Magezon_Builder/js/directives/colorPicker.js":"define([\n\t'jquery',\n\t'angular',\n    'Magezon_Builder/js/ui/form/element/color-picker-palette'\n], function ($, angular, palette) {\n\n\tvar directive = function(magezonBuilderUrl, $timeout, $rootScope) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\trequire: \"ngModel\",\n\t\t\tscope: {\n\t\t\t\tconfig: '='\n\t\t\t},\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/directives/color.html');\n\t\t\t},\n\t\t\tlink: function(scope, element, attrs, ngModel) {\n\t\t\t\tvar initColorPicker = function() {\n\t\t\t\t\tvar config = {\n\t\t\t\t\t\tcontainerClassName: 'mgz-spectrum',\n\t\t                chooseText: 'Apply',\n\t\t                cancelText: 'Cancel',\n\t\t                maxSelectionSize: 8,\n\t\t                clickoutFiresChange: true,\n\t\t                allowEmpty: true,\n\t\t                localStorageKey: 'magezon.spectrum',\n\t\t                palette: palette,\n\t\t                showInput: true,\n\t\t                showInitial: false,\n\t\t                showPalette: true,\n\t\t                showAlpha: true,\n\t\t                showSelectionPalette: true,\n\t\t                preferredFormat: 'hex',\n\t\t                color: ngModel.$viewValue,\n\t\t                hide : function(c) {\n\t\t                \t$timeout(function() {\n\t\t                \t\tif (c) ngModel.$setViewValue(c.toString());\n\t\t                \t});\n\t\t                }\n\t\t            };\n\t\t            config = angular.extend(config, scope.config);\n\t\t            element.spectrum(config);\n\t\t        }\n\t            setTimeout(function() {\n\t            \tinitColorPicker();\n\t            });\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/directives/navigator.js":"define([\n\t'angular'\n], function (angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\tscope: {\n\t\t\t\telement: '='\n\t\t\t},\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/navigator_item.html')\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/directives/navigatorProfile.js":"define([\n\t'jquery',\n\t'angular'\n], function ($, angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\tscope: {\n\t\t\t\telement: '='\n\t\t\t},\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/navigator/element/profile.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\t\t\t\tvar parent = $controller('baseController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t\t$scope.listVisible = true;\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/directives/elementActions.js":"define([\n\t'jquery',\n\t'angular'\n], function ($, angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getViewFileUrl('Magezon_Builder/js/templates/directives/element-actions.html');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/directives/magezonBuilder.js":"define([\n\t'jquery',\n\t'waypoints'\n], function ($) {\n\n\tvar magezonBuilderDir = function(profileManager, $timeout, magezonBuilderUrl, $templateRequest) {\n\t\treturn {\n\t\t\tscope: {\n\t\t\t\tprofile: '='\n\t\t\t},\n    \t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder.html')\n\t\t\t},\n\t\t\tcontroller: function($rootScope, $scope, magezonBuilderModal, historyManager, magezonBuilderService, magezonBuilderConfig) {\n\t\t\t\t$rootScope.builderId = magezonBuilderService.getUniqueId();\n\n\t\t\t\t$scope.$on('openElementsModal', function(event) {\n\t\t\t\t\t$scope.openModal();\n\t\t\t\t});\n\n\t\t\t\t$scope.openModal = function() {\n\t\t\t\t\tmagezonBuilderModal.open('elements').result.then(function() {}, function() {\n\t\t\t\t\t\tmagezonBuilderModal.setElement(null);\n\t\t\t\t\t\tmagezonBuilderModal.setAction(null);\n\t\t\t\t\t\tmagezonBuilderModal.setData(null);\n\t\t\t\t\t\tmagezonBuilderModal.setOpenModal(null);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t$rootScope.$on('loadStyles', function(e, draggingElement) {\n\t\t\t\t\t$scope.loadStyles();\n\t\t\t\t});\n\n\t\t        $scope.loadStyles = function() {\n\t\t        \tif ($rootScope.builderConfig.loadStylesUrl && $rootScope.profile.elements && $rootScope.profile.elements.length) {\n\t\t        \t\tmagezonBuilderService.post($rootScope.builderConfig.loadStylesUrl, {\n\t\t        \t\t\tprofile: profileManager.toString()\n\t\t        \t\t}, true, function(res) {\n\t\t        \t\t\tif (res.message) {\n\t\t        \t\t\t\talert(res.message);\n\t\t        \t\t\t}\n\t\t        \t\t\tif (res.status) {\n\t\t        \t\t\t\t$('#' + $rootScope.builderConfig.targetId + '-styles').html(res.html);\n\t\t        \t\t\t}\n\t\t        \t\t});\n\t\t\t        }\n\t\t        }\n\n\t\t        $templateRequest(magezonBuilderUrl.getViewFileUrl('Magezon_Builder/js/templates/navigator/element/list.html')).then(function(html) {\n\t\t        \t$timeout(function() {\n\t\t\t\t\t\t$('.' + $rootScope.builderConfig.htmlId + '-spinner').remove();\n\t\t\t\t\t\tif (profileManager.getKey()) {\n\t\t\t\t\t\t\tif (magezonBuilderService.isJSON(profileManager.getContent())) {\n\t\t\t\t\t\t\t\t$('.' + $rootScope.rootId).addClass('mgz-deactive-builder');\n\t\t\t\t\t\t\t\t$('.' + $rootScope.rootId).removeClass('mgz-active-builder');\n\t\t\t\t\t\t\t\t$rootScope.$broadcast('importShortcode');\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (profileManager.getContent()) {\n\t\t\t\t\t\t\t\t\t$('.' + $rootScope.rootId).addClass('mgz-active-builder');\n\t\t\t\t\t\t\t\t\t$('.' + $rootScope.rootId).removeClass('mgz-deactive-builder');\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$('.' + $rootScope.rootId).addClass('mgz-deactive-builder');\n\t\t\t\t\t\t\t\t\t$('.' + $rootScope.rootId).removeClass('mgz-active-builder');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$rootScope.$broadcast('importShortcode');\n\t\t\t\t\t\t}\n\t\t\t        }, 100);\n\t\t        });\n\n\t\t        $scope.$on('addElement', function(e, item) {\n\t\t        \tvar elem, action, openModal, data, type;\n\t\t        \tif (item && item.hasOwnProperty('elem')) elem = item.elem;\n\t\t        \tif (item && item.hasOwnProperty('action')) action = item.action;\n\t\t        \tif (item && item.hasOwnProperty('openModal')) openModal = item.openModal;\n\t\t        \tif (item && item.hasOwnProperty('data')) data = item.data;\n\t\t        \tif (item && item.hasOwnProperty('type')) type = item.type;\n\t\t        \tif (type) {\n\t\t        \t\t$rootScope.$broadcast('addNewElment', {\n\t\t\t\t\t\t\telem: elem,\n\t\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\t\taction: 'append',\n\t\t\t\t\t\t\topenModal: openModal,\n\t\t\t\t\t\t\tdata: data\n\t\t\t\t\t\t});\n\t\t        \t} else {\n\t\t        \t\tif (elem) magezonBuilderModal.setElement(elem);\n\t\t\t\t\t\tif (action) magezonBuilderModal.setAction(action);\n\t\t\t\t\t\tif (openModal) magezonBuilderModal.setOpenModal(openModal);\n\t\t\t\t\t\tif (data) magezonBuilderModal.setData(data);\n\t\t\t\t\t\t$rootScope.$broadcast('openElementsModal');\n\t\t        \t}\n\t\t\t\t});\n\n\t\t\t\tvar loadAnimation = function() {\n\t\t\t\t\tif ($(\".mgz-animated:not(.mgz_start_animation)\").length) {\n\t\t\t\t\t\t$(\".mgz-animated:not(.mgz_start_animation)\").waypoint(function() {\n\t\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\t\tvar delayTime = 0;\n\t\t\t\t\t\t\tif ($(this.element).data('animation-delay')) {\n\t\t\t\t\t\t\t\tdelayTime = $(this.element).data('animation-delay');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar durationTime = 0;\n\t\t\t\t\t\t\tif ($(this.element).data('animation-duration')) {\n\t\t\t\t\t\t\t\tdurationTime = $(this.element).data('animation-duration');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (durationTime) $(self.element).css(\"animation-duration\", durationTime + 's');\n\n\t\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\t\t$(self.element).addClass(\"mgz_start_animation animated\")\n\t\t\t\t\t\t\t}, delayTime * 1000);\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\toffset: \"85%\"\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$scope.$on('editedElement', function(e, elem) {\n\t\t\t\t\tloadAnimation();\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\treturn magezonBuilderDir;\n});","Magezon_Builder/js/directives/elementResizable.js":"define([\n\t'jquery',\n\t'angular'\n], function ($, angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getViewFileUrl('Magezon_Builder/js/templates/directives/element-resizable.html');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/directives/resizable.js":"define([\n    'jquery'\n], function ($) {\n\n\tvar resizableDir = function(magezonBuilderService, $rootScope) {\n\t\treturn {\n            restrict: 'AE',\n            scope: {\n            \trElement: '=',\n                rDirections: '=',\n                rCenteredX: '=',\n                rCenteredY: '=',\n                rWidth: '=',\n                rHeight: '=',\n                rFlex: '=',\n                rGrabber: '@',\n                rDisabled: '@'\n            },\n            link: function(scope, element, attr) {\n                scope.sizes = [];\n                magezonBuilderService.getBuilderConfig('resizableSizes', function(resizableSizes) {\n                    scope.sizes = resizableSizes;\n                });\n\n            \tscope.currentSize = scope.sizes[scope.sizes.length-1];\n\n                var flexBasis = 'flexBasis' in document.documentElement.style ? 'flexBasis' :\n                    'webkitFlexBasis' in document.documentElement.style ? 'webkitFlexBasis' :\n                    'msFlexPreferredSize' in document.documentElement.style ? 'msFlexPreferredSize' : 'flexBasis';\n\n                // register watchers on width and height attributes if they are set\n                scope.$watch('rWidth', function(value){\n                    element[0].style.width = scope.rWidth + 'px';\n                });\n                scope.$watch('rHeight', function(value){\n                    element[0].style.height = scope.rHeight + 'px';\n                });\n\n                element.addClass('resizable');\n\n                var style = window.getComputedStyle(element[0], null),\n                    w,\n                    h,\n                    dir = scope.rDirections,\n                    vx = scope.rCenteredX ? 2 : 1, // if centered double velocity\n                    vy = scope.rCenteredY ? 2 : 1, // if centered double velocity\n                    inner = scope.rGrabber ? scope.rGrabber : '<span></span>',\n                    start,\n                    dragDir,\n                    axis,\n                    info = {};\n\n                var oldSize;\n\n                var updateInfo = function(e) {\n                    info.width = false; info.height = false;\n                    if(axis === 'x')\n                        info.width = parseInt(element[0].style[scope.rFlex ? flexBasis : 'width']);\n                    else\n                        info.height = parseInt(element[0].style[scope.rFlex ? flexBasis : 'height']);\n                    info.id = element[0].id;\n                    info.evt = e;\n\n                    var size = scope.currentSize;\n                    if (size && oldSize!=size) {\n                        magezonBuilderService.setResponiveValue(scope.rElement, 'size', size['value']);\n                        scope.$parent.$parent.$digest();\n                    \toldSize = size;\n                \t\telement[0].style['width'] = '';\n                \t\telement.parent().children('.mgz-column-resize').html(size.shortLabel);\n                        $rootScope.$broadcast('exportShortcode');\n\t                }\n                };\n\n                var getSize = function(percent) {\n\n                \tif (percent <= scope.sizes[0]['percent']) {\n                \t\treturn scope.sizes[0];\n                \t}\n\n                \tif (percent >= scope.sizes[scope.sizes.length-1]['percent']) {\n                \t\treturn scope.sizes[scope.sizes.length-1];\n                \t}\n\n                    scope.sizes.sort(function(a,b){\n                        return a['percent'] - b['percent'];\n                    });\n\n                    var newSizes = [];\n                    var size, a, b;\n                \tfor (var i = 0; i < scope.sizes.length; i++) {\n                        var row = scope.sizes[i];\n\n                        if (!size) {\n                            size = scope.sizes[i];\n                            continue;\n                        }\n\n                        a = Math.abs(percent - scope.sizes[i]['percent']);\n                        b = Math.abs(percent - size['percent']);\n\n                        if (a < b) {\n                            size = scope.sizes[i];\n                        }\n                \t}\n\n                    if (size) {\n                        return size;\n                    }\n\n                \treturn scope.currentSize;\n                }\n\n                var dragging = function(e) {\n                    var _width       = $(element).width();\n                    var _parentWidth = $(element).parents('.mgz-element-collection').eq(1).width() + 30;\n                    if (isNaN(_width) || !_width) return;\n                \tif (_width > _parentWidth) {\n\t\t\t\t\t\tpercent = 100;\n                \t} else {\n\t\t\t\t\t\tvar prop, offset = axis === 'x' ? start - e.clientX : start - e.clientY;\n\t\t\t\t\t\tvar percent      = (_width / _parentWidth) * 100;\n\t                }\n\t\t\t\t\tscope.currentSize = getSize(percent);\n                    switch(dragDir) {\n                        case 'right':\n                            prop = scope.rFlex ? flexBasis : 'width';\n                            element[0].style[prop] = (w - offset) + 'px';\n                            break;\n                        case 'left':\n                            prop = scope.rFlex ? flexBasis : 'width';\n                            element[0].style[prop] = w + (offset * vx) + 'px';\n                            break;\n                    }\n                    updateInfo(e);\n                };\n\n                var dragEnd = function(e) {\n                \telement.parent().removeClass('mgz-resizing');\n                \telement[0].style['width'] = '';\n                    updateInfo();\n                    document.removeEventListener('mouseup', dragEnd, false);\n                    document.removeEventListener('mousemove', dragging, false);\n                    element.removeClass('no-transition');\n                };\n                var dragStart = function(e, direction) {\n                    var width = element.closest('.mgz-element').outerWidth();\n\t\t\t\t\telement.parent().addClass('mgz-resizing');\n                    element.width(width);\n\t\t\t\t\tdragDir = direction;\n\t\t\t\t\taxis    = dragDir === 'left' || dragDir === 'right' ? 'x' : 'y';\n\t\t\t\t\tstart   = axis === 'x' ? e.clientX : e.clientY;\n                    w = parseInt(style.getPropertyValue('width'));\n                    h = parseInt(style.getPropertyValue('height'));\n\n                    //prevent transition while dragging\n                    element.addClass('no-transition');\n\n                    document.addEventListener('mouseup', dragEnd, false);\n                    document.addEventListener('mousemove', dragging, false);\n\n                    // Disable highlighting while dragging\n                    if(e.stopPropagation) e.stopPropagation();\n                    if(e.preventDefault) e.preventDefault();\n                    e.cancelBubble = true;\n                    e.returnValue = false;\n                    updateInfo(e);\n                };\n\n                dir.forEach(function (direction) {\n                    var grabber = document.createElement('div');\n\n                    // add class for styling purposes\n                    grabber.setAttribute('class', 'mgz-resize');\n                    grabber.innerHTML = inner;\n                    element[0].appendChild(grabber);\n                    grabber.ondragstart = function() { return false; };\n                    grabber.addEventListener('mousedown', function(e) {\n                        var disabled = (scope.rDisabled === 'true');\n                        if (!disabled && e.which === 1) {\n                            // left mouse click\n                            dragStart(e, direction);\n                        }\n                    }, false);\n\n                    if(!element.parent().children('.mgz-column-resize').length) {\n                    \telement.parent().append('<div class=\"mgz-column-resize\"></div>');\n                    }\n                });\n            }\n        };\n\t};\n\n\treturn resizableDir;\n});","Magezon_Builder/js/directives/modalElement.js":"define([\n\t'angular'\n], function (angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\tscope: {\n\t\t\t\telement: '=element'\n\t\t\t},\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/modal/elements_element.html')\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/directives/builderDirectiveList.js":"define([\n\t'jquery',\n\t'angular'\n], function ($, angular) {\n\n\tvar directive = function(magezonBuilderService, $compile) {\n\t\treturn {\n\t\t\tscope: {\n\t\t\t\tgroup: '@',\n\t\t\t\ttag: '@',\n\t\t\t\thtmlTag: '@',\n\t\t\t\telement: '=?'\n\t\t\t},\n\t\t\tlink: function(scope, element, attrs) {\n\t\t\t\tvar parent    = scope.$parent;\n\t\t\t\tvar htmlTag   = scope.htmlTag ? scope.htmlTag : 'div';\n\t\t\t\tvar deferreds = [];\n\t\t\t\tvar items     = {};\n\t\t\t\tangular.forEach(magezonBuilderService.directives, function(directive, index) {\n\t\t\t\t\tvar tags = directive.tag ? directive.tag : '';\n\t\t\t\t\tvar groups  = directive.group ? directive.group : '';\n\t\t\t\t\tif (angular.isString(tags)) tags = tags.split(',');\n\t\t\t\t\tif (angular.isObject(tags)) tags = Object.values(tags);\n\t\t\t\t\tif (angular.isString(groups)) groups = groups.split(',');\n\t\t\t\t\tif (angular.isObject(groups)) groups = Object.values(groups);\n\t\t\t\t\tif ($.inArray(scope.tag, tags) !== -1 || $.inArray(scope.group, groups) !== -1) {\n\t\t\t\t\t\tif (!directive.hasOwnProperty('disabled') || !directive.disabled) {\n\t\t\t\t\t\t\tvar additionalClasses = directive.additionalClasses ? ' ' + directive.additionalClasses : '';\n\t\t\t\t\t\t\tadditionalClasses += ' magezon-builder-directive-' + directive.type;\n\t\t\t\t\t\t\tif (directive.group) additionalClasses += ' magezon-builder-directive-group-' + directive.group;\n\t\t\t\t\t\t\tif (directive['element']) {\n\t\t\t\t\t\t\t\tvar deferred;\n\t\t\t\t\t\t\t\tdeferred = $.Deferred();\n\t\t\t\t\t\t\t\tdeferreds.push(deferred);\n\t\t\t\t\t\t\t\trequire([directive['element']], function(Directive) {\n\t\t\t\t\t\t\t\t\tvar html = '<' + htmlTag + ' class=\"magezon-builder-directive' + additionalClasses + '\" ' + (directive.templateUrl ? 'templateUrl=\"' + directive.templateUrl + '\"' : '') + ' element=\"element\" dynamic-directive element-name=\"mgz-directive-' + directive.type + '\" sort-order=\"' + (directive['sortOrder'] ? directive['sortOrder'] : 0) + '\"></' + htmlTag + '>';\n\t\t\t\t\t\t\t\t\titems[index] = html;\n\t\t\t\t\t\t\t\t\tdeferred.resolve();\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar html = '<' + htmlTag + ' class=\"magezon-builder-directive' + additionalClasses + '\" ' + (directive.templateUrl ? 'templateUrl=\"' + directive.templateUrl + '\"' : '') + ' element=\"element\" dynamic-directive element-name=\"mgz-directive-' + directive.type + '\" sort-order=\"' + (directive['sortOrder'] ? directive['sortOrder'] : 0) + '\"></' + htmlTag + '>';\n\t\t\t\t\t\t\t\titems[index] = html;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t$.when.apply($, deferreds).done(function () {\n\t\t\t\t\tif (!Object.keys(items).length) element.remove();\n\t\t\t\t\tangular.forEach(items, function(item) {\n\t\t\t\t\t\tif (parent.$parent) {\n\t\t\t\t\t\t\tvar template = angular.element(item);\n\t\t\t\t\t\t\tvar newScope = parent.$parent.$new(true);\n\t\t\t\t\t\t\tnewScope.element = scope.element;\n\t\t\t\t\t\t\tvar html = $compile(template)(newScope);\n\t\t\t\t\t\t\telement.append(html);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t}\n\t}\n\treturn directive;\n});","Magezon_Builder/js/directives/tooltip.js":"define([\n\t'jquery'\n\t], function ($) {\n\n\t\t// https://embed.plnkr.co/plunk/amkxZc\n\t\tvar directive = function($compile, $timeout) {\n\t\t\tvar template =  '<div class=\"mgz-tooltip tooltip {{placement}}\" ng-class=\"{ in: isOpen, fade: animation() }\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\" ng-bind=\"tooltipTitle\"></div></div>';\n\n\t\t\treturn {\n\t\t\t\tscope: { tooltipTitle: '@mgzTooltip', placement: '@tooltipPlacement', animation: '&tooltipAnimation' },\n\t\t\t\tlink: function ( scope, element, attr ) {\n\t\t\t\t\tvar tooltip = $compile( template )( scope ), \n\t\t\t\t\ttransitionTimeout;\n\t\t\t\t\tvar hoverd;\n\n      \t\t\t\t// Calculate the current position and size of the directive element.\n      \t\t\t\tfunction getPosition() {\n      \t\t\t\t\treturn {\n      \t\t\t\t\t\twidth: element.prop( 'offsetWidth' ),\n      \t\t\t\t\t\theight: element.prop( 'offsetHeight' ),\n      \t\t\t\t\t\ttop: element.prop( 'offsetTop' ),\n      \t\t\t\t\t\tleft: element.prop( 'offsetLeft' )\n      \t\t\t\t\t};\n      \t\t\t\t}\n\n      \t\t\t\t// Show the tooltip popup element.\n      \t\t\t\tfunction show() {\n      \t\t\t\t\tvar position,\n      \t\t\t\t\tttWidth,\n      \t\t\t\t\tttHeight,\n      \t\t\t\t\tttPosition;\n\n        \t\t\t\t// If no placement was provided, default to 'top'.\n        \t\t\t\tscope.placement = scope.placement || 'top';\n\n\t\t\t\t        // If there is a pending remove transition, we must cancel it, lest the\n\t\t\t\t        // toolip be mysteriously removed.\n\t\t\t\t        if ( transitionTimeout ) $timeout.cancel( transitionTimeout );\n\n\t\t\t\t        // Lazy compile the tooltip element\n\t\t\t\t        // FIXME: For some reason, this does *not* always work correctly on the \n\t\t\t\t        // *first* run, but does so on all subsequent runs.\n\t\t\t\t        //tooltip = tooltip ||  $compile( template )( scope );\n\n        \t\t\t\t// Set the initial positioning.\n        \t\t\t\ttooltip.css({ top: 0, left: 0, display: 'block' });\n\n\t\t\t\t        // Now we add it to the DOM because need some info about it. But it's not \n\t\t\t\t        // visible yet anyway.\n\t\t\t\t        element.after( tooltip );\n\n\t\t\t\t        // Get the position of the directive element.\n\t\t\t\t        position = getPosition();\n\t\t\t\t        \n\t\t\t\t        // Get the height and width of the tooltip so we can center it.\n\t\t\t\t        ttWidth = tooltip.prop( 'offsetWidth' );\n\t\t\t\t        ttHeight = tooltip.prop( 'offsetHeight' );\n\n\t\t\t\t        // Calculate the tooltip's top and left coordinates to center it with\n\t\t\t\t        // this directive.\n\t\t\t\t        switch ( scope.placement ) {\n\t\t\t\t        \tcase 'right':\n\t\t\t\t        \tttPosition = {\n\t\t\t\t        \t\ttop: (position.top + position.height / 2 - ttHeight / 2) + 'px',\n\t\t\t\t        \t\tleft: (position.left + position.width) + 'px'\n\t\t\t\t        \t};\n\t\t\t\t        \tbreak;\n\t\t\t\t        \tcase 'bottom':\n\t\t\t\t        \tttPosition = {\n\t\t\t\t        \t\ttop: (position.top + position.height) + 'px',\n\t\t\t\t        \t\tleft: (position.left + position.width / 2 - ttWidth / 2) + 'px'\n\t\t\t\t        \t};\n\t\t\t\t        \tbreak;\n\t\t\t\t        \tcase 'left':\n\t\t\t\t        \tttPosition = {\n\t\t\t\t        \t\ttop: (position.top + position.height / 2 - ttHeight / 2) + 'px',\n\t\t\t\t        \t\tleft: (position.left - ttWidth) + 'px'\n\t\t\t\t        \t};\n\t\t\t\t        \tbreak;\n\t\t\t\t        \tdefault:\n\t\t\t\t        \tttPosition = {\n\t\t\t\t        \t\ttop: (position.top - ttHeight) + 'px',\n\t\t\t\t        \t\tleft: (position.left + position.width / 2 - ttWidth / 2) + 'px'\n\t\t\t\t        \t};\n\t\t\t\t        \tbreak;\n\t\t\t\t        }\n\n\t\t\t\t        // Now set the calculated positioning.\n\t\t\t\t        tooltip.css( ttPosition );\n\n\t\t\t\t        if (scope.placement == 'top' || scope.placement == 'bottom') {\n\t\t\t\t        \tvar arrowSel = tooltip.find('.tooltip-arrow');\n\t\t\t\t        \tarrowSel.css('left', (tooltip.width() - arrowSel.outerWidth(true)) / 2);\n\t\t\t\t    \t}\n\n\t\t\t\t        // And show the tooltip.\n\t\t\t\t        scope.isOpen = true;\n\t\t\t\t    }\n\n      \t\t\t\t// Hide the tooltip popup element.\n      \t\t\t\tfunction hide() {\n\t\t\t\t        transitionTimeout = $timeout( function () {\n\t\t\t\t        \tif (!hoverd) {\n\t\t\t\t        \t\tscope.isOpen = false;\n\t\t\t\t        \t\t//tooltip.remove();\n\t\t\t\t        \t}\n\t\t\t\t        }, 500);\n\t\t\t\t    }\n\n\t\t\t\t    \n\t\t\t\t    tooltip.hover(function() {\n\t\t\t\t    \tscope.$apply( show );\n\t\t\t\t    \thoverd = true;\n\t\t\t\t    }, function() {\n\t\t\t\t    \thoverd = false;\n\t\t\t\t    \tscope.$apply( hide );\n\t\t\t\t    })\n\n\t\t\t      \t// Register the event listeners.\n\t\t\t      \telement.bind( 'mouseenter', function() {\n\t\t\t      \t\t$('.mgz-tooltip').remove();\n\t\t\t      \t\tscope.$apply( show );\n\t\t\t      \t\thoverd = true;\n\t\t\t      \t});\n\t\t\t      \telement.bind( 'mouseleave', function() {\n\t\t\t      \t\thoverd = false;\n\t\t\t      \t\tscope.$apply( hide );\n\t\t\t      \t});\n\t\t\t      }\n\t\t\t  };\n\t\t\t}\n\n\t\t\treturn directive;\n\t\t});","Magezon_Builder/js/directives/elementIcon.js":"define([\n\t'jquery',\n\t'angular'\n], function ($, angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\tscope: {\n\t\t\t\telement: '='\n\t\t\t},\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/element_icon.html');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/modules/dynamicDirective.js":"// Source Blog: https://weblogs.thinktecture.com/pawel/2014/07/angularjs-dynamic-directives.html\n// https://jsfiddle.net/Pawel_Gerr/y22ZK/\n\n/**\n * Dynamic directive\n */\n(function(dynamicDirective) {\n    'use strict';\n\n    /**\n     * @param $scope\n     */\n    function Controller($scope) {\n\n    }\n\n    /**\n     * @constructor\n     * @param $compile\n     * @param {DynamicDirectiveManager} dynamicDirectiveManager\n     */\n    function Directive($compile, dynamicDirectiveManager) {\n\n        function safeApply(scope, fn) {\n            var phase = scope.$root.$$phase;\n\n            if (phase === '$apply' || phase === '$digest') {\n                if (fn && (typeof(fn) === 'function')) {\n                    fn();\n                }\n            } else {\n                scope.$apply(fn);\n            }\n        }\n\n        return {\n            restrict: 'AE',\n            require: 'dynamicDirective',\n            controller: Controller,\n            compile: function () {\n\n                var currentSuffix;\n                var ctx = new DummyDynamicDirectiveContext();\n\n                return {\n                    post: function (scope, element, attrs, controller) {\n\n                        controller.recompile = function (suffix) {\n                            if (currentSuffix === suffix) {\n                                return;\n                            }\n\n                            currentSuffix = suffix;\n\n                            // safeApply(scope, function () {\n                            //     ctx.recompileInnerElement(scope, element, currentSuffix, attrs);\n                            // });\n                        };\n\n                        ctx.register();\n                        //ctx.recompileInnerElement(scope, element, currentSuffix, attrs);\n\n                        scope.$on('$destroy', function () {\n                            ctx.unregister();\n                        });\n\n                        attrs.$observe('elementName', function (newName, oldName) {\n                            if (newName !== oldName) {\n                                ctx.unregister();\n                                ctx.destroyInnerElement(scope, element);\n\n                                if (newName) {\n                                    ctx = new DynamicDirectiveContext($compile, dynamicDirectiveManager, controller, newName, attrs);\n                                } else {\n                                    ctx = new DummyDynamicDirectiveContext();\n                                }\n\n                                ctx.register();\n                                ctx.recompileInnerElement(scope, element, currentSuffix, attrs);\n                            }\n                        });\n\n                    }\n                };\n            }\n        };\n    }\n\n    function DynamicDirectiveContext($compile, dynamicDirectiveManager, controller, elementName, attrs) {\n\n        if (!elementName) {\n            throw new Error('Element name must not null nor empty.');\n        }\n\n        var normalizedName = attrs.$normalize(elementName);\n        var currentInnerElement;\n\n        // taken from angular.js\n        var SNAKE_CASE_REGEXP = /[A-Z]/g;\n\n        function snakeCase(name, separator) {\n            separator = separator || '_';\n            return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {\n                return (pos ? separator : '') + letter.toLowerCase();\n            });\n        }\n\n        function createElement(currentSuffix) {\n\n            var name = elementName;\n\n            if (angular.isDefined(currentSuffix) && (currentSuffix !== null)) {\n                name = name + '-' + currentSuffix;\n            }\n\n            var directiveElem = angular.element(document.createElement(name));\n            var attrsToOmit = ['elementName', '$attr'];\n\n            angular.forEach(attrs, function (value, key) {\n                if (attrs.hasOwnProperty(key) && (attrsToOmit.indexOf(key) < 0) && (key.indexOf('$$') !== 0)) {\n                  if (snakeCase(key, '-')!='ng-repeat') {\n                    //directiveElem.attr(snakeCase(key, '-'), value);\n                  }\n                }\n            });\n            return directiveElem;\n        }\n\n        this.recompileInnerElement = function (scope, element, suffix, attrs) {\n            this.destroyInnerElement(scope, element);\n            currentInnerElement = createElement(suffix);\n            if (attrs.elementName == 'mgz-element-menu_item') {\n                element.replaceWith(currentInnerElement);\n            } else {\n                element.append(currentInnerElement);\n            }\n            $compile(currentInnerElement)(scope);\n        };\n\n        this.destroyInnerElement = function (scope, element) {\n            destroyInnerScope(scope);\n            //element.html(null);\n        };\n\n        function destroyInnerScope(scope) {\n            if (currentInnerElement) {\n                var innerScope = currentInnerElement.isolateScope() || currentInnerElement.scope();\n\n                if (innerScope && (innerScope !== scope)) {\n                  //innerScope.$destroy();\n                }\n            }\n        }\n\n        this.register = function () {\n            dynamicDirectiveManager.add(normalizedName, controller);\n        };\n\n        this.unregister = function () {\n            dynamicDirectiveManager.remove(normalizedName, controller);\n        };\n    }\n\n    function DummyDynamicDirectiveContext() {\n\n        this.register = function () {\n        };\n\n        this.unregister = function () {\n        };\n\n        this.recompileInnerElement = function () {\n        };\n\n        this.destroyInnerElement = function () {\n        };\n    }\n\n    /**\n     * @constructor\n     * @param $compileProvider\n     * @param {DynamicDirectiveSuffixGenerator} dynamicDirectiveSuffixGenerator\n     */\n    function DynamicDirectiveManager($compileProvider, dynamicDirectiveSuffixGenerator) {\n        if (!$compileProvider) {\n            throw new Error('Compile provider must not be null.');\n        }\n\n        var defaultSuffixGenerator = dynamicDirectiveSuffixGenerator;\n        var dynDirectives = {};\n        var registeredDirectives = {};\n        var regex = /^[a-z0-9]+$/;\n\n        /**\n         * Adds a dynamic directive controller instance to the manager.\n         * @param {string} normalizedElementName Pascal-cased name of the directive.\n         * @param {*} dynamicDirectiveController A dynamic directive controller.\n         */\n        this.add = function (normalizedElementName, dynamicDirectiveController) {\n            if (!normalizedElementName) {\n                throw new Error('Name must not be empty.');\n            }\n\n            if (!dynamicDirectiveController) {\n                throw new Error('Dynamic directive controller must not be null.');\n            }\n\n            var directives = dynDirectives[normalizedElementName];\n\n            if (!directives) {\n                directives = [];\n                dynDirectives[normalizedElementName] = directives;\n\n            } else if (directives.indexOf(dynamicDirectiveController) >= 0) {\n                return;\n            }\n\n            directives.push(dynamicDirectiveController);\n\n            var suffixes = registeredDirectives[normalizedElementName];\n            if (suffixes) {\n                dynamicDirectiveController.recompile(suffixes._last);\n            }\n        };\n\n        /**\n         * Removes a dynamic directive controller from the manager.\n         * @param {string} normalizedElementName Pascal-cased name of the directive.\n         * @param {*} dynamicDirectiveController A dynamic directive controller.\n         */\n        this.remove = function (normalizedElementName, dynamicDirectiveController) {\n            if (!normalizedElementName) {\n                throw new Error('Name must not be empty.');\n            }\n\n            if (!dynamicDirectiveController) {\n                throw new Error('Dynamic directive controller must not be null.');\n            }\n\n            var directives = dynDirectives[normalizedElementName];\n\n            if (directives) {\n                var index = directives.indexOf(dynamicDirectiveController);\n\n                if (index >= 0) {\n                    directives.splice(index, 1);\n                }\n            }\n\n        };\n\n        /**\n         * Registers a new directive.\n         * @param {string} normalizedName Pascal-cased directive name.\n         * @param {function} constructor Directive constructor\n         * @param {*} [suffix] If suffix equals false than no suffix is appended; if suffix is undefined than a random suffix is generated; otherwise the suffix is converted to string.\n         */\n        this.registerDirective = function (normalizedName, constructor, suffix) {\n            var nameWithSuffix = normalizedName;\n            suffix = prepareSuffix(normalizedName, suffix);\n\n            if (!angular.isUndefined(suffix)) {\n                nameWithSuffix = nameWithSuffix + suffix;\n            }\n\n            var registerDirective = true;\n            var suffixes = registeredDirectives[normalizedName];\n\n            if (!suffixes) {\n                suffixes = {};\n                registeredDirectives[normalizedName] = suffixes;\n            }\n\n            if (suffixes[suffix]) {\n                registerDirective = false;\n            } else {\n                suffixes[suffix] = true;\n            }\n\n            suffixes._last = suffix;\n\n            if (!$compileProvider) {\n                dynamicDirective.directive(nameWithSuffix, constructor);\n            } else {\n                if (registerDirective) {\n                    $compileProvider.directive.apply(null, [nameWithSuffix, constructor]);\n                }\n\n                recompile(normalizedName, suffix);\n            }\n        };\n\n        /**\n         * Changes the suffix generator.\n         * @param {{generateSuffix:Function}} suffixGenerator\n         */\n        this.changeSuffixGenerator = function (suffixGenerator) {\n            if (angular.isUndefined(suffixGenerator) || (suffixGenerator === null)) {\n                dynamicDirectiveSuffixGenerator = defaultSuffixGenerator;\n                return;\n            }\n\n            if (!angular.isFunction(suffixGenerator.generateSuffix)) {\n                throw new Error('Suffix generator must have a function \"generateSuffix\".');\n            }\n\n            dynamicDirectiveSuffixGenerator = suffixGenerator;\n        };\n\n        /**\n         * Changes the suffix of all dynamic directives.\n         * @param {*} [suffix] If suffix equals false than no suffix is appended; if suffix is undefined than a random suffix is generated; otherwise the suffix is converted to string.\n         */\n        this.changeSuffix = function (suffix) {\n\n            _.each(dynDirectives, function (directives, normalizedName) {\n\n                var preparedSuffix = prepareSuffix(normalizedName, suffix);\n                var suffixes = registeredDirectives[normalizedName];\n\n                if (suffixes) {\n                    suffixes._last = preparedSuffix;\n                }\n\n                angular.forEach(directives, function (dynamicDirective) {\n                    dynamicDirective.recompile(preparedSuffix);\n                });\n            });\n        };\n\n        function prepareSuffix(normalizedName, suffix) {\n            if (suffix === false) {\n                return undefined;\n            }\n\n            if (angular.isUndefined(suffix)) {\n                suffix = dynamicDirectiveSuffixGenerator.generateSuffix(normalizedName);\n            }\n\n            if (!regex.test(suffix)) {\n                throw new Error('Suffix must consist of lowercased characters (a-z) and number (0-9) only.');\n            } else {\n                suffix = suffix + '';\n                suffix = suffix.substr(0, 1).toUpperCase() + suffix.substr(1);\n            }\n\n            return suffix;\n        }\n\n        function recompile(normalizedElementName, suffix) {\n            var directives = dynDirectives[normalizedElementName];\n\n            if (directives) {\n                angular.forEach(directives, function (dynamicDirective) {\n                    dynamicDirective.recompile(suffix);\n                });\n            }\n        }\n    }\n\n    /**\n     * @constructor\n     */\n    function DynamicDirectiveManagerProvider() {\n        var $compileProvider;\n\n        this.setCompileProvider = function (compileProvider) {\n            if (!compileProvider) {\n                throw new Error('Compile provider must not be null.');\n            }\n\n            $compileProvider = compileProvider;\n        };\n\n        this.$get = function ($injector) {\n            return $injector.instantiate(DynamicDirectiveManager, { $compileProvider: $compileProvider });\n        };\n    }\n\n    /**\n     * @constructor\n     */\n    function DynamicDirectiveSuffixGenerator() {\n\n        /**\n         * @param {string} normalizedName\n         * @returns {string}\n         */\n        this.generateSuffix = function (normalizedName) {\n            return new Date().getTime() + '';\n        };\n\n    }\n\n    dynamicDirective.provider('dynamicDirectiveManager', DynamicDirectiveManagerProvider);\n    dynamicDirective.service('dynamicDirectiveSuffixGenerator', DynamicDirectiveSuffixGenerator);\n    dynamicDirective.directive('dynamicDirective', Directive);\n\n    /* grab the $compileProvider */\n    dynamicDirective\n        .config(function ($compileProvider, dynamicDirectiveManagerProvider) {\n            dynamicDirectiveManagerProvider.setCompileProvider($compileProvider);\n        })\n        .run(function (dynamicDirectiveManager) {\n            dynamicDirective.dynamicDirectiveManager = dynamicDirectiveManager;\n        });\n\n})(angular.module('dynamicDirective', []));\n","Magezon_Builder/js/modules/contentEditable.js":"define([\n\t'jquery',\n\t'angular'\n], function ($, angular) {\n\n\tvar directive = function($document, $rootScope, $timeout) {\n\t\treturn {\n\t\t\trequire: \"ngModel\",\n\t\t\tlink: function(scope, element, attrs, ngModel) {\n\t\t\t\telement.addClass('mgz-contenteditable-element');\n\t\t\t\telement.attr('contenteditable', true);\n\n\t\t\t\tvar type = attrs.type ? attrs.type : 'inline';\n\n\t\t\t\tfunction read() {\n\t\t\t\t\tngModel.$setViewValue(element.html());\n\t\t\t\t}\n\n\t\t\t\tfunction updatePlaceHolder() {\n\t\t\t\t\tif (element.data('placeholder') && !ngModel.$viewValue) {\n\t\t\t\t\t\telement.addClass('placeholder-text');\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.removeClass('placeholder-text');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tngModel.$render = function() {\n\t\t\t\t\telement.html(ngModel.$viewValue || \"\");\n\t\t\t\t};\n\n\t\t\t\tscope.enableEditing = function() {\n\t\t\t\t\tif(scope.element) {\n\t\t\t\t\t\t$rootScope.$broadcast('disableEditing', scope.element);\n\t\t\t\t\t\t$timeout(function () {\n\t\t\t\t\t\t\tscope.element.builder.editing = true;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telement.bind(\"click\", function(e) {\n\t\t\t\t\tvar draggableParent = element.closest('.ui-draggable');\n\t\t\t\t\tif (draggableParent.length) {\n\t\t\t\t\t\tdraggableParent.draggable({ disabled: true });\n\t\t\t\t\t}\n\t\t\t\t\tscope.enableEditing();\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t});\n\n\t\t\t\telement.bind(\"focus\", function(e) {\n\t\t\t\t\telement.trigger('click');\n\t\t\t\t\telement.trigger('mouseenter');\n\t\t\t\t});\n\n\t\t\t\telement.bind(\"blur\", function(e) {\n\t\t\t\t\tvar draggableParent = element.closest('.ui-draggable');\n\t\t\t\t\tif (draggableParent.length) {\n\t\t\t\t\t\tdraggableParent.draggable({ disabled: false });\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\telement.bind(\"blur keyup keypress change\", function() {\n\t\t\t\t\tupdatePlaceHolder();\n\t\t\t\t\tscope.$apply(read);\n\t\t\t\t});\n\n\t\t\t\telement.bind(\"keydown keypress\", function (e) {\n\t\t\t\t\tif(e.which === 13 && type == 'inline') {\n\t                    element[0].blur();\n\t                    e.preventDefault();\n\t                }\n\t\t\t\t});\n\n\t\t\t\tscope.$on('disableEditing', function(e, elem) {\n\t\t\t\t\tif (scope.element) {\n\t\t\t\t\t\tif (elem.id !== scope.element.id) {\n\t\t\t\t\t\t\tscope.element.builder.editing = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/modules/outside-click.js":"require(['jquery'], function($) {\n\n// https://github.com/abrkt/ng-outside-click\n(function(){\n  'use strict';\n\n  var contains = function (parent, child) {\n    var node = child;\n    while ((node = node.parentNode) !== null && node !== parent);\n    return node !== null;\n  };\n\n  angular.module('ngOutsideClick', []).directive('outsideClick', ['$document', function ($document) {\n    return {\n      restrict: 'A',\n      link: function ($scope, $element, $attrs) {\n        var scopeExpression = $attrs.outsideClick;\n        var onDocumentClick = function (event) {\n          if ($element[0] !== event.target && !contains($element[0], event.target) && !$(event.target).parents('.mgz-element-controls').length) {\n            $scope.$apply(scopeExpression);\n          }\n        };\n        $document.on('click', onDocumentClick);\n        $element.on('$destroy', function () {\n          $document.off('click', onDocumentClick);\n        });\n      }\n    };\n  }]);\n\n})();\n\n});","Magezon_Builder/js/modules/inlineEditor.js":"define([\n\t'jquery',\n\t'angular'\n], function ($, angular) {\n\n\tvar directive = function($rootScope, magezonBuilderEditor, magezonBuilderService, magezonBuilderFilter, $document, $timeout) {\n\t\treturn {\n\t\t\trequire: \"ngModel\",\n\t\t\tlink: function(scope, element, attrs, ngModel) {\n\t\t\t\telement.addClass('mgz-inline-editor');\n\t\t\t\telement.attr('contenteditable', true);\n\n\t\t\t\tscope.id = magezonBuilderService.uniqueid();\n\t\t\t\tscope.wysiwyg = Object.extend(angular.copy($rootScope.builderConfig.wysiwyg), scope.wysiwyg);\n\t\t\t\tscope.wysiwyg['inline'] = true;\n\t\t\t\tscope.wysiwyg['fixed_toolbar_container'] = '.' + scope.element.id + ' .mgz-element-inner';\n\t\t\t\telement.attr('id', scope.id);\n\n\t\t\t\tngModel.$render = function() {\n\t\t\t\t\telement.html(magezonBuilderFilter.encodeContent(ngModel.$viewValue) || \"\");\n\t\t\t\t};\n\n\t\t\t\telement.bind(\"click\", function(e) {\n\t\t\t\t\t$rootScope.$broadcast('disableEditing', scope.element);\n\t\t\t\t\t$timeout(function () {\n\t\t\t\t\t\tscope.element.builder.editing = true;\n\t\t\t\t\t}, 1000);\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t});\n\n\t\t\t\tif ($rootScope.builderConfig.wysiwyg.tinymce4) {\n\t\t\t\t\telement.on('mouseenter', function() {\n\t\t\t\t\t\tmagezonBuilderEditor.initTinymce(scope.id, scope.wysiwyg, function(value) {\n\t\t\t\t\t\t\tngModel.$setViewValue(magezonBuilderFilter.decodeContent(value));\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\telement.bind(\"blur\", function(e) {\n\t\t\t\t\tif (scope.element) {\n\t\t\t\t\t\t$timeout(function () {\n\t\t\t\t\t\t\tscope.element.builder.editing = false;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tscope.$on('disableEditing', function(e, elem) {\n\t\t\t\t\tif (scope.element) {\n\t\t\t\t\t\tif (elem.id !== scope.element.id) {\n\t\t\t\t\t\t\tscope.element.builder.editing = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/modules/afterRender.js":"define([\n\t'jquery',\n\t'angular'\n], function ($, angular) {\n\n\tvar directive = function($timeout) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\trestrict: 'A',\n\t        terminal: true,\n\t        transclude: false,\n\t        link: function (scope, element, attrs) {\n\t            $timeout(function() {\n\t            \tscope.$eval(attrs.afterRender);\n\t            }, 100);\n\t        }\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/navigator/element/base.js":"define([\n\t'jquery',\n\t'angular'\n], function($, angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/navigator/element/default.html');\n\t\t\t},\n\t\t\tcontroller: function($rootScope, $scope, $controller) {\n\t\t\t\tvar parent = $controller('baseController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t\tvar self = this;\n\n\t\t\t\tthis.getWrapperClasses = function() {\n\t\t\t\t\tvar element = $scope.element;\n\t\t\t\t\tvar classes = [];\n\t\t\t\t\tclasses.push('mgz-navigator-element');\n\t\t\t\t\tclasses.push('mgz-navigator-element-' + element.id);\n\t\t\t\t\tif (element.disable_element) classes.push('mgz-element-disabled');\n\t\t\t\t\tif (element.builder.actived) classes.push('mgz-element-actived');\n\t\t\t\t\tif (element.hidden_default) classes.push('mgz-element-hide-default');\n\t\t\t\t\tif (element.disable_element) classes.push('mgz-element-disabled');\n\t\t\t\t\treturn classes;\n\t\t\t\t}\n\n\t\t\t\tthis.getStype = function() {\n\t\t\t\t\tvar level = self.getParents().length;\n\t\t\t\t\tvar paddingLeft = ((level + 1) * 1.6) + 'rem';\n\t\t\t\t\tif (!$scope.element.builder.is_collection) {\n\t\t\t\t\t\tpaddingLeft = ((level + 1) * 1.8) + 'rem';\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\t'padding-left': paddingLeft\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$scope.toggleElementList = function() {\n\t\t\t\t\t$scope.element.builder.navigator.listVisible = !$scope.element.builder.navigator.listVisible;\n\t\t\t\t}\n\n\t\t\t\t$scope.$on('addNewElment', function(event, item) {\n\t\t\t\t\tif ((item.action == 'before' || item.action == 'after' || item.action == 'replace')) {\n\t\t\t\t\t\tif ($scope.isChildren(item.elem)) {\n\t\t\t\t\t\t\t$scope.listVisible = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (item.action == 'append' && item.elem.id == $scope.element.id) {\n\t\t\t\t\t\t$scope.listVisible = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tvar loaded = false;\n\t\t\t\t$scope.$watch('element.builder.name', function(name) {\n\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\t$rootScope.$broadcast('exportShortcode');\n\t\t\t\t\t}\n\t\t\t\t\tloaded = true;\n\t\t\t\t});\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/factories/FormlyUtils.js":"define([\n    'angular',\n    'underscore'\n], function(angular, _) {\n\n\tvar uniqueid = function (size) {\n        var code = Math.random() * 25 + 65 | 0,\n            idstr = String.fromCharCode(code);\n\n        size = size || 12;\n\n        while (idstr.length < size) {\n            code = Math.floor(Math.random() * 42 + 48);\n\n            if (code < 58 || code > 64) {\n                idstr += String.fromCharCode(code);\n            }\n        }\n\n        return idstr.toLowerCase();\n    };\n\n    var processFields = function(array, separator, level, key) {\n        if (level === undefined) {\n            level = 0;\n        }\n        var types = [];\n        var i = 0,length;\n        var children = [];\n        array  = _.compact(array);\n        length = array.length;\n        for (i; i < length; i++) {\n            var orgiKey = key;\n            var row  = array[i];\n            var elem = row['config'];\n            if (elem['templateOptions']['element']) {\n                if (!elem['data']) elem['data'] = {};\n                elem['data']['element'] = elem['templateOptions']['element'];\n            }\n            if (elem['key']) {\n                if (key) {\n                    key += '.' + elem['key'];\n                } else {\n                    key = elem['key'];\n                }\n                elem['key'] = key;\n            }\n            // Dynamic Rows\n            if (row.config.templateOptions.children) {\n                key = '';\n                row.config.templateOptions.children = this.processFields(row.config.templateOptions.children, separator, level, key);\n            }\n            if (row.hasOwnProperty(separator)) {\n                level++;\n                elem['wrapper']    = this.getUniqueId();\n                elem['fieldGroup'] = this.processFields(row[separator], separator, level, key);\n            } else {\n                elem['type'] = this.getUniqueId();\n                elem['id']   = this.getUniqueId();\n            }\n\n            if (!elem['className']) elem['className'] = '';\n            elem['className'] += ' mgz__field';\n            elem['className'] += ' mgz_field-' + elem.templateOptions.elementId;\n            elem['className'] += ' mgz_field-type-' + elem.templateOptions.builderType;\n\n            if (elem.templateOptions.required) {\n                elem['className'] += ' _required';\n            }\n\n            if (elem.templateOptions.templateUrl) {\n                elem.templateOptions.templateUrl = window.magezonBuilder.viewFileUrl + elem.templateOptions.templateUrl;\n            }\n\n            if (elem.templateOptions.wrapperTemplateUrl) {\n                elem.templateOptions.wrapperTemplateUrl = window.magezonBuilder.viewFileUrl + elem.templateOptions.wrapperTemplateUrl;\n            }\n\n            // overide wrapepr template url\n            if (elem.templateOptions.wrapperTemplateUrl) {\n                var wrapperId = this.getUniqueId();\n                if (!elem['data']) elem['data'] = {};\n                elem['data']['wrapperType'] = wrapperId;\n                elem['wrapper'] = wrapperId;\n            }\n            children.push(elem);\n            key = orgiKey;\n        }\n        return children;\n    }\n\n    var getComponentDefault = function() {\n        return {\n            visible: true,\n            control: true\n        };   \n    }\n\n    var getDefaultValues = function(element) {\n        var defaultValues        = angular.copy(processDefaultValues(element.tabs, {}));\n        defaultValues['type']    = element.type;\n        defaultValues['builder'] = getComponentDefault();\n        return defaultValues;\n    }\n\n    var processDefaultValues = function(fields) {\n        var defaultValues = {};\n        _.each(fields, function(field, k) {\n            if (field.fieldGroup) {\n                var _defaultValues = processDefaultValues(field.fieldGroup);\n                if (_defaultValues) {\n                    if (field.key) {\n                        defaultValues[field.key] = _defaultValues;\n                    } else {\n                        defaultValues = angular.merge(defaultValues, _defaultValues);\n                    }\n                }\n            } else if (field.hasOwnProperty('key') && field.hasOwnProperty('defaultValue')) {\n                defaultValues[field.key] = field['defaultValue'];\n            }\n        });\n        return defaultValues;\n    };\n\n    return {\n        getUniqueId: uniqueid,\n        processFields: processFields\n    }\n});","Magezon_Builder/js/factories/config.js":"define([\n\t'jquery',\n\t'angular'\n], function($, angular) {\n\n\tvar array_diff = function(arr1) {\n\t\tvar retArr = {}\n\t\tvar argl = arguments.length\n\t\tvar k1 = ''\n\t\tvar i = 1\n\t\tvar k = ''\n\t\tvar arr = {}\n\n\t\t  \tarr1keys: for (k1 in arr1) {\n\t\t  \t\tfor (i = 1; i < argl; i++) {\n\t\t  \t\t\tarr = arguments[i]\n\t\t  \t\t\tfor (k in arr) {\n\t\t  \t\t\t\tif (arr[k] === arr1[k1]) {\n\t\t          \t\t\tcontinue arr1keys;\n\t\t      \t\t\t}\n\t\t  \t\t\t}\n\t\t  \t\t\tretArr[k1] = arr1[k1]\n\t\t\t\t}\n\t\t\t}\n\t\treturn retArr\n\t}\n\n\tvar array_values = function (input) {\n\t\tvar tmpArr = []\n\t\tvar key = ''\n\n\t\tfor (key in input) {\n\t\t\ttmpArr[tmpArr.length] = input[key]\n\t\t}\n\n\t\treturn tmpArr\n\t}\n\n\treturn function(formlyConfigProvider) {\n\t\tvar elements      = {};\n\t\tvar groups        = {};\n\t\tvar $config       = {};\n\t\tvar $directives   = {};\n\n\t\treturn {\n\t\t\tregisterConfig: function(config) {\n\t\t\t\t$config = config;\n\t\t\t},\n\n\t\t\tregisterGroup: function(name, group) {\n\t\t\t\tif (!groups[name]) {\n\t\t\t\t\tgroups[name] = group;\n\t\t\t\t} else {\n\t\t\t\t\tangular.extend(groups[name], group);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tregisterElement: function(name, element) {\n\t\t\t\tif (!element['element']) {\n\t\t\t\t\tif (element['is_collection']) {\n\t\t\t\t\t\telement['element'] = 'Magezon_Builder/js/builder/element/list';\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement['element'] = 'Magezon_Builder/js/builder/element/base';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!element['navigator']) element['navigator'] = 'Magezon_Builder/js/navigator/element/base';\n\t\t\t\tif (element['is_collection']) {\n\t\t\t\t\tif (!element['templateUrl']) {\n\t\t\t\t\t\telement['templateUrl'] = 'Magezon_Builder/js/templates/builder/element/list.html'\n\t\t\t\t\t}\n\t\t\t\t\tif (!element['navigatorTemplateUrl']) {\n\t\t\t\t\t\telement['navigatorTemplateUrl'] = 'Magezon_Builder/js/templates/navigator/element/list.html'\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (element.hasOwnProperty('visible') && element.visible || !element.hasOwnProperty('visible')) {\n\t\t\t\t\tif (!elements[name]) {\n\t\t\t\t\t\telements[name] = element;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tangular.extend(elements[name], element);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tprocessAllowTypes: function() {\n\t\t\t\t$allTypes      = [];\n\t\t\t\tangular.forEach(elements, function(element, index) {\n\t\t\t\t\t$allTypes.push(element.type);\n\t\t\t\t});\n\n\t\t\t\t$childrenTypes = [];\n\t            angular.forEach(elements, function(element, index) {\n\t\t\t\t\t$allowedTypes  = element.allowed_types;\n\t\t\t\t\t$excludedTypes = element.excluded_types;\n\n\t                if (angular.isString($allowedTypes)) {\n\t                    element.allowed_types = $allowedTypes.split(',');\n\t                }\n\n\t                if (!element.allowed_types && $excludedTypes) {\n\t                    if (angular.isString($excludedTypes)) {\n\t                        $excludedTypes = $excludedTypes.split(',');\n\t                    }\n\t                    $allowedTypes = array_diff($allTypes, $excludedTypes);\n\t                    element.allowed_types = array_values($allowedTypes);\n\t                }\n\n\t                if (element.children) {\n\t                    $childrenTypes.push(element.children);\n\t                }\n\t            });\n\n\t            $validTypes = array_diff($allTypes, $childrenTypes);\n\t            angular.forEach(elements, function(element, index) {\n\t                $allowedTypes  = element.allowed_types;\n\t                if ($allowedTypes) {\n\t                    if ($.inArray( element.children, $allowedTypes) === -1) {\n\t\t\t\t\t\t\t$_allowedTypes        = array_diff($allowedTypes, $childrenTypes);\n\t\t\t\t\t\t\telement.allowed_types = array_values($_allowedTypes);\n\t                    }\n\t                } else {\n\t                    element.allowed_types = array_values($validTypes);\n\t                }\n\t            });\n\t\t\t},\n\n\t\t\tregisterDirectives: function(name, directive) {\n\t\t\t\t$directives[name] = directive;\n\t\t\t},\n\n\t\t\t$get: function() {\n\t\t\t\treturn {\n\t\t\t\t\telements: elements,\n\t\t\t\t\tgroups: groups,\n\t\t\t\t\tconfig: $config,\n\t\t\t\t\tdirectives: $directives\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/magento-widget.js":"define([\n\t'jquery'\n], function($) {\n\n\treturn {\n\t\tcontroller: function($rootScope, $scope, magezonBuilderService, magezonBuilderFilter, $sce) {\n\t\t\t$scope.ajax = true;\n\t\t\t$rootScope.$broadcast('disableSaveBtn');\n\t\t\tmagezonBuilderService.post('mgzbuilder/widget/index', {}, false, function(res) {\n\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t$scope.html = $sce.trustAsHtml(res);\n\t\t\t\t\t$rootScope.$broadcast('enableSaveBtn');\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t$scope.$watch('html', function(value) {\n\t\t\t\tif ($scope.model[$scope.options.key] && value) {\n\t\t\t\t\tvar widgetCode   = angular.copy($scope.model[$scope.options.key]);\n\t\t\t\t\tvar optionValues = new Hash({});\n\t\t\t\t\tvar widgetValue;\n\n\t\t\t\t\t// mage/adminhtml/wysiwyg/widget.js - line 287\n\t                widgetCode.gsub(/([a-z0-9\\_]+)\\s*\\=\\s*[\\\"]{1}([^\\\"]+)[\\\"]{1}/i, function (match) {\n\t                    if (match[1] == 'type') { //eslint-disable-line eqeqeq\n\t                        widgetValue = match[2];\n\t                    } else {\n\t                        optionValues.set(match[1], match[2]);\n\t                    }\n\t                });\n\n\t                if (widgetValue) {\n\t                \t$rootScope.$broadcast('disableSaveBtn');\n\t                \tvar params = {\n\t\t\t                'widget_type': widgetValue,\n\t\t\t                values: optionValues\n\t\t\t            };\n\t\t\t            magezonBuilderService.post('mgzbuilder/widget/loadOptions', {\n\t\t\t            \twidget: Object.toJSON(params)\n\t\t\t            }, false, function(res) {\n\t\t\t            \t$rootScope.$broadcast('enableSaveBtn');\n\t\t\t            \tvar widgetCode = widgetValue.gsub(/\\//, '_');\n\t\t\t            \t$('#select_widget_type').val(widgetCode);\n\t\t\t            \tvar optionsContainerId = 'widget_options_' + widgetCode;\n\t\t\t            \tvar optionsContainer   = $('#' + optionsContainerId);\n\t\t\t            \tif (optionsContainer.length) {\n\t\t\t            \t\toptionsContainer.html(res);\n\t\t\t            \t} else {\n\t\t\t            \t\tvar html = '<div id=\"' + optionsContainerId + '\">';\n\t\t\t            \t\thtml += res;\n\t\t\t            \t\thtml += '</div>';\n\t\t\t            \t\t$('#widget_options').append(html);\n\t\t\t            \t}\n\t\t\t            });\n\t                }\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t$scope.updateValue = function() {\n\t\t\t\tvar form  = $('#widget_options_form');\n\t\t\t\tvar valid = true;\n\t\t\t\tform.find('.error').each(function(index, el) {\n\t\t\t\t\tif ($(this).is(':visible')) {\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (form.valid() && $scope.ajax) {\n\t\t\t\t\t$scope.ajax = false;\n\t\t\t\t\t$rootScope.$broadcast('disableSaveBtn');\n\t\t\t\t\tmagezonBuilderService.post('mgzbuilder/widget/buildWidget', form.serialize(), false, function(res) {\n\t\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t\t$scope.ajax = true;\n\t\t\t\t\t\t\t$rootScope.$broadcast('enableSaveBtn');\n\t\t\t\t\t\t\t$scope.model[$scope.options.key] = magezonBuilderFilter.decodeContent(res);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$(document).on('click', '.rule-param-apply,.rule-param-remove,.data-grid ._clickable,#select_widget_type,.x-tree-node-el', function() {\n\t\t\t\t$scope.updateValue();\n\t\t\t});\n\n\t\t\t$(document).on('change', \"#widget_options_form *[name^='parameters'],#select_widget_type\", function() {\n\t\t\t\tif ($(this).parents('.mgz-modal-form').length) {\n\t               $scope.updateValue();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/dynamic-rows.js":"define([\n\t'angular'\n], function(angular) {\n\n\treturn {\n\t\tcontroller: function($scope) {\n\t\t\t$scope.formOptions = {formState: $scope.formState};\n\t\t\t$scope.addNew = addNew;\n\n\t\t\tvar unique = 1;\n\n\t\t\tangular.forEach($scope.model[$scope.options.key], function(_item, index) {\n\t\t\t\t_item['position'] = index + 1;\n\t\t\t});\n\n\t\t\t$scope.copyFields = copyFields;\n\n\t\t\t$scope.$on('removeDynamicItem', function(event, item) {\n\t\t\t\tvar index = $scope.model[$scope.options.key].indexOf(item);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\t$scope.model[$scope.options.key].splice(index, 1);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t$scope.$on('radioDefaultDynamicItem', function(event, data) {\n\t\t\t\tvar index = $scope.model[$scope.options.key].indexOf(data.item);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tangular.forEach($scope.model[$scope.options.key], function(_item, index) {\n\t\t\t\t\t\tif (_item===data.item) {\n\t\t\t\t\t\t\t_item[data.key] = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_item[data.key] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t$scope.$on('sortDynamicItems', function(event, data) {\n\t\t\t\t$scope.model[$scope.options.key] = _.sortBy($scope.model[$scope.options.key], data.key);\n\t\t\t});\n\n\t\t\tfunction copyFields(fields) {\n\t\t\t\tfields = angular.copy(fields);\n\t\t\t\taddRandomIds(fields);\n\t\t\t\treturn fields;\n\t\t\t}\n\n\t\t\tfunction addNew() {\n\t\t\t\t$scope.model[$scope.options.key] = $scope.model[$scope.options.key] || [];\n\t\t\t\tvar repeatsection = $scope.model[$scope.options.key];\n\t\t\t\tvar lastSection   = repeatsection[repeatsection.length - 1];\n\t\t\t\tvar newsection    = {};\n\t\t\t\tif (lastSection) {\n\t\t\t\t\tnewsection = angular.copy(lastSection);\n\t\t\t\t}\n\t\t\t\tvar newsection = {};\n\t\t\t\tnewsection['position'] = repeatsection.length + 1;\n\t\t\t\trepeatsection.push(newsection);\n\t\t\t}\n\n\t\t\tfunction addRandomIds(fields) {\n\t\t\t\tunique++;\n\t\t\t\tangular.forEach(fields, function(field, index) {\n\t\t\t\t\tif (field.fieldGroup) {\n\t\t\t\t\t\taddRandomIds(field.fieldGroup);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (field.children) {\n\t\t\t\t\t\taddRandomIds(field.children);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (field.templateOptions && field.templateOptions.children) {\n\t\t\t\t\t\taddRandomIds(field.templateOptions.children);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (field.key) {\n\t\t\t\t\t\tfield.id = field.key.replace(/\\./g,'_') + '_' + index + '_' + unique + getRandomInt(0, 9999);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction getRandomInt(min, max) {\n\t\t\t\treturn Math.floor(Math.random() * (max - min)) + min;\n\t\t\t}\n\t\t}\n\t}\n})","Magezon_Builder/js/form/element/editor.js":"define([\n    'jquery',\n    'angular'\n], function($, angular) {\n\n    return {\n        controller: function($rootScope, $scope, magezonBuilderService, magezonBuilderEditor, magezonBuilderFilter) {\n            $scope.to.loading = true;\n            var config = Object.extend(angular.copy($rootScope.builderConfig.wysiwyg), $scope.to.wysiwyg);\n            $scope.id = magezonBuilderService.uniqueid();\n            $scope.content = $scope.model[$scope.options.key];\n            magezonBuilderEditor.initTinymce($scope.id, config, function(value) {\n                $scope.content = $scope.model[$scope.options.key] = magezonBuilderFilter.decodeContent(value);\n            }, function() {\n                $scope.to.loading = false;\n            });\n        }\n    }\n})","Magezon_Builder/js/form/element/dependency.js":"define([\n\t'angular',\n\t'jquery'\n], function(angular, $) {\n\n\treturn {\n\t\tcontroller: function($scope, $rootScope, $timeout) {\n\t\t\tvar initializing = true;\n\n\t\t\t$scope.$watch('model.' + $scope.options.key, function(value) {\n\t\t\t\tif (initializing) {\n\t\t\t\t\t$timeout(function() { initializing = false; });\n\t\t\t\t} else {\n\t\t\t\t\tif ($scope.to.values && $scope.to.values.hasOwnProperty(value)) {\n\t\t\t\t\t\tangular.forEach($scope.to.values[value], function(value, key) {\n\t\t\t\t\t\t\t$scope.model[key] = value;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif ($scope.to.groupsConfig) {\n\t\t\t\t$scope.$watch('model.' + $scope.options.key, function(value) {\n\t\t\t\t\t$rootScope.$broadcast('showField', {\n\t\t\t\t\t\tvalue: $scope.model[$scope.options.key],\n\t\t\t\t\t\tgroupsConfig: $scope.to.groupsConfig\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ($scope.to.target) {\n\t\t\t\tangular.forEach($scope.to.target, function(value, index) {\n\t\t\t\t\t$scope.$watch('model.' + value, function(value) {\n\t\t\t\t\t\t$rootScope.$broadcast('showField', {\n\t\t\t\t\t\t\tvalue: $scope.model[$scope.options.key],\n\t\t\t\t\t\t\tgroupsConfig: $scope.to.groupsConfig\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\t$scope.$watchCollection('model.' + value, function(value) {\n\t\t\t\t\t\t$rootScope.$broadcast('showField', {\n\t\t\t\t\t\t\tvalue: $scope.model[$scope.options.key],\n\t\t\t\t\t\t\tgroupsConfig: $scope.to.groupsConfig\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/condition.js":"define([\n\t'jquery'\n], function($) {\n\n\t$(document).on('click', '.rule-param-remove', function() {\n\t\t$('.rule-tree').trigger('change');\n\t});\n\n\treturn {\n\t\tcontroller: function($rootScope, $scope, $sce, magezonBuilderService) {\n\t\t\t$scope.to.loading = true;\n\t\t\t$scope.id         = magezonBuilderService.uniqueid();\n\t\t\t$scope.status     = true;\n\n\t\t\t$scope.loadConditionsValue = function() {\n\t\t\t\tif ($scope.status) {\n\t\t\t\t\t$scope.status = false;\n\t\t\t\t\t$rootScope.$broadcast('disableSaveBtn');\n\t\t\t\t\tmagezonBuilderService.post('mgzbuilder/ajax/conditionsValue', {\n\t\t\t\t\t\tvalues: $('.mgz-modal-form form').serialize(),\n\t\t\t\t\t\tfield: $scope.options.key\n\t\t\t\t\t}, true, function(res) {\n\t\t\t\t\t\tif (res.status) {\n\t\t\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t\t\t$scope.model[$scope.options.key] = res.value;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$rootScope.$broadcast('enableSaveBtn');\n\t\t\t\t\t\t$scope.status = true;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmagezonBuilderService.post('mgzbuilder/ajax/conditions', {\n\t\t\t\tconditions: $scope.model[$scope.options.key],\n\t\t\t\tid: $scope.id\n\t\t\t}, true, function(res) {\n\t\t\t\tif (res.message) {\n\t\t\t\t\talert(res.message);\n\t\t\t\t}\n\t\t\t\tif (res.status) {\n\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t$scope.html       = $sce.trustAsHtml(res.html);\n\t\t\t\t\t\t$scope.to.loading = false;\n\n\t\t\t\t\t\t$('#' + $scope.id).on('click', '.rule-param-remove,.rule-param-apply,.data-grid ._clickable,#select_widget_type', function() {\n\t\t\t\t\t\t\t$scope.loadConditionsValue();\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t$('#' + $scope.id).on('change', '.element-value-changer,.rule-tree', function() {\n\t\t\t\t\t\t\t$scope.loadConditionsValue();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/select.js":"define([\n\t'angular'\n], function(angular) {\n\n\treturn {\n\t\ttemplateOptions: {\n\t\t\tlabelProp: 'label',\n\t\t\tvalueProp: 'value'\n\t\t},\n\t\tcontroller: function($scope, $timeout, magezonBuilderService) {\n\t\t\t$scope.to.loading = false;\n\t\t\tif ($scope.to.lazyOptions) {\n\t\t\t\t$scope.to.options = eval($scope.to.lazyOptions);\n\t\t\t}\n\t\t\tif ($scope.to.builderConfig) {\n\t\t\t\t$scope.to.loading = true;\n\t\t\t\tmagezonBuilderService.getBuilderConfig($scope.to.builderConfig, function(options) {\n\t\t\t\t\t$timeout(function() {\n\t\t\t\t\t\t$scope.to.options = options;\n\t\t\t\t\t\t$scope.to.loading = false;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ($scope.to.url) {\n\t\t\t\t$scope.to.loading = true;\n\t\t\t\tmagezonBuilderService.post($scope.to.url, {\n\t\t\t\t\tfield: $scope.options.key\n\t\t\t\t}, true, function(res) {\n\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t$scope.to.options = res;\n\t\t\t\t\t\t$scope.to.loading = false;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else if ($scope.to.source) {\n\t\t\t\t$scope.to.loading = true;\n\t\t\t\tmagezonBuilderService.post('mgzbuilder/ajax/itemList', {\n\t\t\t\t\ttype: $scope.to.source,\n\t\t\t\t\tfield: $scope.options.key\n\t\t\t\t}, true, function(res) {\n\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t$scope.to.options = res;\n\t\t\t\t\t\t$scope.to.loading = false;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n})","Magezon_Builder/js/form/element/animation-out.js":"define(function() {\n\n\treturn {\n\t\tcontroller: function($scope, $timeout, magezonBuilderService) {\n\t\t\t$scope.to.loading = true;\n\t\t\tmagezonBuilderService.getBuilderConfig('animationOut', function(options) {\n\t\t\t\t$scope.styles = angular.copy(options);\n\t\t\t\t$timeout(function() {\n\t\t\t\t\t$scope.to.loading = false;\n\t\t\t\t})\n\t\t\t});\n\t\t\t$scope.loadAnimate = function() {\n\t\t\t\t$scope.animateClass = $scope.fc.$viewValue + ' animated';\n\t\t\t\t$timeout(function() {\n\t\t\t\t\t$scope.animateClass = '';\n\t\t\t\t}, 1000);\n\t\t\t};\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/hide_on.js":"define([\n\t'jquery'\n], function($) {\n\n\treturn {\n\t\tcontroller: function($scope) {\n\t\t\t$scope.toggleHide = function(type) {\n\t\t\t\t$scope.model[type + '_hide'] = !$scope.model[type + '_hide'];\n\t\t\t}\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/color.js":"define([\n\t'jquery',\n\t'mgzspectrum',\n    'mgztinycolor',\n    'Magezon_Builder/js/ui/form/element/color-picker-palette'\n], function($, spectrum, tinycolor, palette) {\n\n\treturn {\n\t\tcontroller: function($scope, $timeout) {\n\n\t\t\t$scope.value = $scope.model[$scope.options.key];\n\t\t\tvar element = $('#' + $scope.id);\n\n\t\t\tvar getColor = function(color) {\n\t\t\t\tif (!color) color = $('#' + $scope.id).spectrum('get').toString();\n\t\t\t\treturn $scope.to.hex ? tinycolor(color).toHexString() : tinycolor(color).toString();\n\t\t\t}\n\n\t\t\tvar config = {\n\t\t\t\tcontainerClassName: 'mgz-spectrum',\n                chooseText: 'Apply',\n                cancelText: 'Cancel',\n                maxSelectionSize: 8,\n                clickoutFiresChange: true,\n                allowEmpty: true,\n                localStorageKey: 'magezon.spectrum',\n                palette: palette,\n                showInput: true,\n                showInitial: false,\n                showPalette: true,\n                showAlpha: $scope.to.hex ? false : true,\n                showSelectionPalette: true,\n                preferredFormat: 'hex',\n                color: $scope.value,\n                hide : function(c) {\n            \t\t$timeout(function() {\n                \t\tif ($('#' + $scope.id).spectrum('get')) {\n                \t\t\t$scope.model[$scope.options.key] = $scope.value = getColor();\n                \t\t\t$('#' + $scope.id).spectrum('set', $scope.value);\n                \t\t} else {\n                \t\t\t$scope.model[$scope.options.key] = $scope.value = '';\n                \t\t}\n                \t});\n                }\n            };\n            config = angular.extend(config, $scope.to.colorPickerConfig);\n\n\t\t\t$timeout(function() {\n\t\t\t\t$('#' + $scope.id).spectrum(config);\n\t\t\t\t$('#' + $scope.id + '-input').change(function(event) {\n\t\t\t\t\tvar value = $(this).val();\n\t\t\t\t\tif (value) {\n                        if (tinycolor(value).isValid()) {\n    \t\t\t\t\t\tvalue = getColor(value);\n    \t\t\t\t\t\t$('#' + $scope.id).spectrum('set', value);\n    \t\t\t\t\t\t$scope.model[$scope.options.key] = $scope.value = getColor();\n    \t\t\t\t\t\t$(this).val(value);\n                        }\n\t\t\t\t\t} else {\n                        $scope.model[$scope.options.key] = '';\n                    }\n\t\t\t\t});\n\t\t\t}, 200);\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/image.js":"define([\n\t'angular',\n\t'Magezon_Core/js/mage/browser'\n], function(angular) {\n\n\treturn {\n\t\tcontroller: function($scope, $rootScope) {\n\t\t\t$scope.openFileManager =  function() {\n\t            var fileManagerUrl = $rootScope.builderConfig.fileManagerUrl.replace('UID', $scope.id);\n\t            MgzMediabrowserUtility.openDialog(fileManagerUrl);\n\t        }\n\n\t        $scope.getSrc = function() {\n\t        \tif ($scope.model[$scope.options.key]) {\n\t\t\t\t\treturn $rootScope.builderConfig.mediaUrl + $scope.model[$scope.options.key];\n\t\t\t\t}\n\t        }\n\t\t}\n\t}\n})","Magezon_Builder/js/form/element/date.js":"define([\n\t'jquery',\n\t'mage/calendar'\n], function($) {\n\n\treturn {\n\t\tlink: function(scope, element) {\n\t\t\tsetTimeout(function() {\n\t\t\t\t$('#' + scope.id).calendar({\n\t\t\t\t\tdateFormat: \"mm/dd/yy\"\n\t\t\t\t});\n\t\t\t}, 100);\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/ui-select.js":"define([\n\t'angular',\n\t'jquery'\n], function(angular, $) {\n\n\treturn {\n\t\ttemplateOptions: {\n\t\t\tlabelProp: 'label',\n\t\t\tvalueProp: 'value'\n\t\t},\n\t\tcontroller: function($scope, $timeout, magezonBuilderService) {\n\t\t\t$scope.to.loading = false;\n\n\t\t\tif ($scope.to.builderConfig) {\n\t\t\t\t$scope.to.loading = true;\n\t\t\t\tmagezonBuilderService.getBuilderConfig($scope.to.builderConfig, function(options) {\n\t\t\t\t\t$timeout(function() {\n\t\t\t\t\t\t$scope.to.options = options;\n\t\t\t\t\t\t$scope.to.loading = false;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t$scope.refresh = function($select) {\n\t\t\t\tvar search = $select.search ? $select.search : $scope.model[$scope.options.key];\n\t\t\t\tif (search && (search.length >= 2 || !isNaN(search))) {\n\t\t\t\t\tif ($scope.to.url) {\n\t\t\t\t\t\t$scope.to.loading = true;\n\t\t\t\t\t\tmagezonBuilderService.post($scope.to.url, {\n\t\t\t\t\t\t\tfield: $scope.options.key,\n\t\t\t\t\t\t\tq: search\n\t\t\t\t\t\t}, true, function(res) {\n\t\t\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t\t\t$scope.to.options = res;\n\t\t\t\t\t\t\t\t$scope.to.loading = false;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if ($scope.to.source) {\n\t\t\t\t\t\t$scope.to.loading = true;\n\t\t\t\t\t\tmagezonBuilderService.post('mgzbuilder/ajax/itemList', {\n\t\t\t\t\t\t\ttype: $scope.to.source,\n\t\t\t\t\t\t\tfield: $scope.options.key,\n\t\t\t\t\t\t\tq: search\n\t\t\t\t\t\t}, true, function(res) {\n\t\t\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t\t\t$scope.to.options = res;\n\t\t\t\t\t\t\t\t$scope.to.loading = false;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})","Magezon_Builder/js/form/element/simply.js":"define([\n\t'jquery'\n], function($) {\n\n\treturn {\n\t\texpressionProperties: {\n\t\t\t'templateOptions.disabled': function(viewValue, modelValue, scope) {\n\t\t\t\tif (viewValue) {\n\t\t\t\t\tvar prefix = scope.to.prefix;\n\t\t\t\t\t$('.mgz-design-layout').addClass('mgz-design-simply');\n\t\t\t\t\tscope.model[prefix + 'border_top_left_radius'] = scope.model[prefix + 'border_bottom_right_radius'] = scope.model[prefix + 'border_bottom_left_radius'] = scope.model[prefix + 'border_top_right_radius'];\n\t\t\t\t\tscope.model[prefix + 'margin_right'] = scope.model[prefix + 'margin_bottom'] = scope.model[prefix + 'margin_left'] = scope.model[prefix + 'margin_top'];\n\t\t\t\t\tscope.model[prefix + 'border_right_width'] = scope.model[prefix + 'border_bottom_width'] = scope.model[prefix + 'border_left_width'] = scope.model[prefix + 'border_top_width'];\n\t\t\t\t\tscope.model[prefix + 'padding_right'] = scope.model[prefix + 'padding_bottom'] = scope.model[prefix + 'padding_left'] = scope.model[prefix + 'padding_top'];\n\t\t\t\t} else {\n\t\t\t\t\t$('.mgz-design-layout').removeClass('mgz-design-simply');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})","Magezon_Builder/js/form/element/icon.js":"define([\n\t'jquery',\n\t'angular'\n], function($, angular) {\n\n\treturn {\n\t\ttemplateOptions: {\n\t\t\tlabelProp: 'label',\n\t\t\tvalueProp: 'value'\n\t\t},\n\t\tcontroller: function($rootScope, $scope, magezonBuilderService) {\n\t\t\t$scope.font  = $scope.to.defaultFont ? $scope.to.defaultFont : 'awesome';\n\t\t\t$scope.fonts = [];\n\t\t\tangular.forEach($rootScope.builderConfig.fonts, function(font) {\n\t\t\t\t$scope.fonts.push(font);\n\t\t\t});\n\n\t\t\t$scope.onSuccess = function(data) {\n\t\t\t\t$scope.to.loading = false;\n\t\t\t\t$scope.to.options = data;\n\t\t\t};\n\n\t\t\t$scope.to.loading = true;\n\t\t\tmagezonBuilderService.getBuilderConfig('fonts.' + $scope.font, $scope.onSuccess);\n\t\t\t$scope.listVisible = false;\n\n\t\t\t$scope.$watch('model.' + $scope.options.key, function(value) {\n\t\t\t\t$scope.listVisible = false;\n\t\t\t});\n\n\t\t\t$scope.$watch('font', function(value) {\n\t\t\t\t$scope.to.loading = true;\n\t\t\t\tif (value) magezonBuilderService.getBuilderConfig('fonts.' + value, $scope.onSuccess);\n\t\t\t});\n\n\t\t\t$scope.tagHandler = function (tag) {\n\t\t\t    return null;\n\t\t\t}\n\n\t\t\t$scope.outsideClick = function() {\n\t\t\t\t$scope.listVisible = false;\n\t\t\t}\n\n\t\t\t$scope.removeIcon = function() {\n\t\t\t\t$scope.model[$scope.options.key] = '';\n\t\t\t}\n\t\t},\n\t\tlink: function(scope, element, attrs, $select) {\n            element.find('.mgz-selector-button').click(function(event) {\n            \tif (scope.listVisible) {\n            \t\tsetTimeout(function () {\n            \t\t\t$(element).find('.ui-select-toggle').first().trigger('click');\n            \t\t}, 300);\n            \t}\n            });        \n        }\n\t}\n});","Magezon_Builder/js/form/element/tab.js":"define([\n\t'angular',\n    'jquery'\n], function(angular, $) {\n\n    return {\n        controller: function($scope) {\n\n\t\t\t$scope.tabs   = $scope.to.children;\n\t\t\t$scope.length = $scope.tabs.length;\n\n\t\t\t// Copy from forly.js\n        \tfunction formlyEval(scope, expression, $modelValue, $viewValue, extraLocals) {\n        \t\tif (angular.isFunction(expression)) {\n        \t\t\treturn expression($viewValue, $modelValue, scope, extraLocals);\n        \t\t} else {\n        \t\t\treturn scope.$eval(expression, angular.extend({ $viewValue: $viewValue, $modelValue: $modelValue }, extraLocals));\n        \t\t}\n        \t}\n\n        \t// Copy from forly.js\n        \tfunction getFormlyFieldLikeLocals(field, index) {\n        \t\treturn {\n        \t\t\tmodel: field.model,\n        \t\t\toptions: field,\n        \t\t\tindex: index,\n        \t\t\tformState: $scope.options.formState,\n        \t\t\toriginalModel: $scope.model,\n        \t\t\tformOptions: $scope.options,\n        \t\t\tformId: $scope.formId\n        \t\t};\n        \t}\n\n        \t// Copy from forly.js\n        \tfunction evalCloseToFormlyExpression(expression, val, field, index) {\n        \t\tvar extraLocals = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];\n        \t\textraLocals = angular.extend(getFormlyFieldLikeLocals(field, index), extraLocals);\n        \t\treturn formlyEval($scope, expression, val, val, extraLocals);\n        \t}\n\n\t\t\t$scope.$watch('model', function() {\n\t\t\t\tvar length = $scope.tabs.length;\n\t\t\t\tangular.forEach($scope.tabs, function (field, index) {\n\t\t\t\t\t// Copy from forly.js\n\t\t\t\t\tvar model = field.model || $scope.model;\n\t\t\t\t\tvar promise = field.runExpressions && field.runExpressions();\n\t\t\t\t\tif (field.hideExpression) {\n\t\t\t\t\t\tvar val = model[field.key];\n\t\t\t\t\t\tfield.hide = evalCloseToFormlyExpression(field.hideExpression, val, field, index, { model: model });\n\t\t\t\t\t\tif (field.hide) {\n\t\t\t\t\t\t\tlength--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t$scope.length = length;\n\t\t\t}, true);\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/templates.js":"define([\n\t'jquery',\n\t'angular'\n], function($, angular) {\n\n\treturn {\n\t\ttemplateOptions: {\n\t\t\tlabelProp: 'label',\n\t\t\tvalueProp: 'value'\n\t\t},\n\t\tcontroller: function($rootScope, $scope, magezonBuilderService, elementManager, magezonBuilderModal, profileManager) {\n\t\t\t$scope.loadTemplates = function() {\n\t\t\t\t$rootScope.$broadcast('enableModalSpinner');\n\t\t\t\t$scope.to.loading = true;\n\t\t\t\tif ($scope.to.url) {\n\t\t\t\t\t$scope.to.loading = true;\n\t\t\t\t\tmagezonBuilderService.post($scope.to.url, {\n\t\t\t\t\t\tfield: $scope.options.key,\n\t\t\t\t\t\turl: $rootScope.builderConfig.profile.templateUrl\n\t\t\t\t\t}, true, function(res) {\n\t\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t\tangular.forEach(res, function(item, key) {\n\t\t\t\t\t\t\t\tif (item.profile) {\n\t\t\t\t\t\t\t\t\tvar profile = profileManager.prepareProfile(item.profile, true);\n\t\t\t\t\t\t\t\t\titem.elements = profile.elements;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (item.label) item.name = item.label;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t$scope.to.options = res;\n\t\t\t\t\t\t\t$scope.to.loading = false;\n\t\t\t\t\t\t\t$rootScope.$broadcast('disableModalSpinner');\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else if ($scope.to.source) {\n\t\t\t\t\t$scope.to.loading = true;\n\t\t\t\t\tmagezonBuilderService.post('mgzbuilder/ajax/itemList', {\n\t\t\t\t\t\ttype: $scope.to.source,\n\t\t\t\t\t\turl: $rootScope.builderConfig.profile.templateUrl\n\t\t\t\t\t}, true, function(res) {\n\t\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t\tangular.forEach(res, function(item, key) {\n\t\t\t\t\t\t\t\tif (item.profile) {\n\t\t\t\t\t\t\t\t\tvar profile = profileManager.prepareProfile(item.profile, true);\n\t\t\t\t\t\t\t\t\titem.elements = profile.elements;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (item.label) item.name = item.label;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t$scope.to.options = res;\n\t\t\t\t\t\t\t$scope.to.loading = false;\n\t\t\t\t\t\t\t$rootScope.$broadcast('disableModalSpinner');\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t$scope.loadTemplates();\n\n\t\t\t$scope.$on('loadTemplates', function() {\n\t\t\t\t$scope.loadTemplates();\n\t\t\t});\n\n\t\t\t$scope.openElements = function(item) {\n\t\t\t\titem['active'] = !item['active'];\n\t\t\t}\n\n\t\t    $scope.importItem = function(item) {\n\t\t    \tif (item.file || item.elements.length) {\n\t\t\t    \tvar elements;\n\t\t\t    \tif (item.elements && item.elements.length) {\n\t\t\t    \t\telements = angular.copy(elementManager.prepareElements(item.elements, true));\n\t\t\t\t\t\tangular.forEach(elements, function(elem, index) {\n\t\t\t\t\t\t\t$rootScope.profile.elements.push(angular.copy(elem));\n\t\t\t\t\t\t});\n\t\t\t\t\t\tmagezonBuilderModal.closeModal();\n\t\t\t\t\t\t$rootScope.$broadcast('addHistory', {\n\t\t\t\t\t\t\ttype: 'imported_template',\n\t\t\t\t\t\t\ttitle: item.name\n\t\t\t\t\t\t});\n\t\t\t\t\t\titem.importing = false;\n\t\t\t    \t}\n\t\t\t    \tif (item.file) {\n\t\t\t    \t\titem.importing = true;\n\t\t\t    \t\tmagezonBuilderService.post('mgzbuilder/ajax/template', {\n\t\t\t\t\t\t\titem: item\n\t\t\t\t\t\t}, true, function(res) {\n\t\t\t\t\t\t\telements = elementManager.prepareElements(res.elements, true);\n\t\t\t\t\t\t\tangular.forEach(elements, function(elem, index) {\n\t\t\t\t\t\t\t\t$rootScope.profile.elements.push(angular.copy(elem));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tmagezonBuilderModal.closeModal();\n\t\t\t\t\t\t\t$rootScope.$broadcast('addHistory', {\n\t\t\t\t\t\t\t\ttype: 'imported_template',\n\t\t\t\t\t\t\t\ttitle: item.name\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t\t\titem.importing = false;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t    \t}\n\t\t\t\t}\n\t\t    }\n\t\t}\n\t}\n})","Magezon_Builder/js/form/element/multicheckbox.js":"define([\n\t'underscore'\n\t], function(_) {\n\n\t\treturn {\n\t\t\ttemplateOptions: {\n\t\t\t\tlabelProp: 'label',\n\t\t\t\tvalueProp: 'value'\n\t\t\t},\n\t\t\tcontroller: function($scope) {\n\t\t\t\tconst to = $scope.to;\n\t\t\t\tconst opts = $scope.options;\n\t\t\t\t$scope.multiCheckbox = {\n\t\t\t\t\tchecked: [],\n\t\t\t\t\tchange: setModel\n\t\t\t\t};\n\n        // initialize the checkboxes check property\n        $scope.$watch('model', function modelWatcher(newModelValue) {\n        \tvar modelValue, valueProp;\n\n        \tif (Object.keys(newModelValue).length) {\n        \t\tmodelValue = newModelValue[opts.key];\n\n        \t\t$scope.$watch('to.options', function optionsWatcher(newOptionsValues) {\n        \t\t\tif (newOptionsValues && Array.isArray(newOptionsValues) && Array.isArray(modelValue)) {\n        \t\t\t\tvalueProp = to.valueProp || 'value';\n        \t\t\t\tfor (var index = 0; index < newOptionsValues.length; index++) {\n        \t\t\t\t\t$scope.multiCheckbox.checked[index] = modelValue.indexOf(newOptionsValues[index][valueProp]) !== -1;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t});\n        \t}\n        }, true);\n\n        function checkValidity(expressionValue) {\n        \tvar valid;\n\n        \tif ($scope.to.required) {\n        \t\tvalid = angular.isArray($scope.model[opts.key]) &&\n        \t\t$scope.model[opts.key].length > 0 &&\n        \t\texpressionValue;\n\n        \t\t$scope.fc.$setValidity('required', valid);\n        \t}\n        }\n\n        function setModel() {\n        \t$scope.model[opts.key] = [];\n        \tangular.forEach($scope.multiCheckbox.checked, (checkbox, index) => {\n        \t\tif (checkbox) {\n        \t\t\t$scope.model[opts.key].push(to.options[index][to.valueProp || 'value']);\n        \t\t}\n        \t});\n\n          // Must make sure we mark as touched because only the last checkbox due to a bug in angular.\n          $scope.fc.$setTouched();\n          checkValidity(true);\n          \n          if ($scope.to.onChange) {\n          \t$scope.to.onChange();\n          }\n      }\n\n      if (opts.expressionProperties && opts.expressionProperties['templateOptions.required']) {\n      \t$scope.$watch(function() {\n      \t\treturn $scope.to.required;\n      \t}, function(newValue) {\n      \t\tcheckValidity(newValue);\n      \t});\n      }\n\n      if ($scope.to.required) {\n      \tvar unwatchFormControl = $scope.$watch('fc', function(newValue) {\n      \t\tif (!newValue) {\n      \t\t\treturn;\n      \t\t}\n      \t\tcheckValidity(true);\n      \t\tunwatchFormControl();\n      \t});\n      }\n  }\n}\n})","Magezon_Builder/js/form/element/save-templates.js":"define([\n\t'jquery'\n], function($) {\n\n\treturn {\n\t\tcontroller: function($rootScope, $scope, $timeout, magezonBuilderUrl, profileManager) {\n\t\t\t$scope.text     = 'Save Template';\n\t\t\t$scope.disabled = false;\n\n\t\t\t$scope.saveTemplate = function() {\n\t\t\t\tif ($scope.to.saveTemplateUrl) {\n\t\t\t\t\tvar name = $scope.model[$scope.options.key];\n\t\t\t\t\tif (name && !$scope.disabled) {\n\t\t\t\t\t\t$scope.disabled = true;\n\t\t\t\t\t\t$scope.text     = 'Saving';\n\n\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\tname: name,\n\t\t\t\t\t\t\tprofile: profileManager.getShortCode(),\n\t\t\t\t\t\t\tis_active: 1\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t$.ajax({\n\t\t\t                url: magezonBuilderUrl.getUrl($scope.to.saveTemplateUrl),\n\t\t\t                type:'POST',\n\t\t\t                data: data,\n\t\t\t                success: function(res) {\n\t\t\t\t\t\t\t\tif (res.message) {\n\t\t\t\t\t\t\t\t\talert(res.message);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t\t\t\t$scope.text = 'Saved';\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t$timeout(function() {\n\t\t\t\t\t\t\t\t\t$scope.model[$scope.options.key] = '';\n\t\t\t\t\t\t\t\t\t$scope.text                      = 'Save Template';\n\t\t\t\t\t\t\t\t\t$scope.disabled                  = false;\n\t\t\t\t\t\t\t\t\t$rootScope.$broadcast('loadTemplates');\n\t\t\t\t\t\t\t\t}, 1000);\n\t\t\t                }\n\t\t\t            });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})","Magezon_Builder/js/form/element/link_entity.js":"define([\n\t'angular',\n\t'underscore',\n], function(angular, _) {\n\n\treturn {\n\t\tcontroller: function($scope, magezonBuilderService, $timeout) {\n\t\t\tvar initializing = true;\n\t\t\t$scope.to.options = [];\n\n\t\t\t$scope.$watch('model.type', function(type) {\n\t\t\t\tif (type !== 'custom') {\n\t\t\t\t\t$scope.to.label = magezonBuilderService.capitalize(type);\n\t\t\t\t}\n\t\t\t\tif (initializing) {\n\t\t\t\t\t$timeout(function() { initializing = false; });\n\t\t\t\t} else {\n\t\t\t\t\t$scope.model.id = '';\n\t\t\t\t\t$scope.to.options = [];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t$scope.$watch('model.id', function(id) {\n\t\t\t\tif (id) {\n\t\t\t\t\tvar item = _.findWhere($scope.to.options, {value: id});\n\t\t\t\t\tif (!$scope.model.title) $scope.model.title = item.label;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t$scope.refresh = function($select) {\n\t\t\t\tvar type = $scope.model.type;\n\t\t\t\tvar search = $select.search ? $select.search : $scope.model[$scope.options.key];\n\t\t\t\tif (search && ($select.search.length >= 2 || $scope.model[$scope.options.key])) {\n\t\t\t\t\t$scope.to.loading = true;\n\t\t\t\t\tmagezonBuilderService.post('mgzbuilder/ajax/itemList', {\n\t\t\t\t\t\ttype: $scope.model.type,\n\t\t\t\t\t\tq: search\n\t\t\t\t\t}, true, function(res) {\n\t\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t\t$scope.to.options = res;\n\t\t\t\t\t\t\t$scope.to.loading = false;\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})","Magezon_Builder/js/form/element/link.js":"define([\n\t'jquery',\n\t'underscore',\n    'uiRegistry'\n], function($, _, registry) {\n\n\treturn {\n\t\tcontroller: function($scope, magezonBuilderModal, magezonBuilderService, magezonBuilderFilter) {\n\t\t\t$scope.type = 'Custom';\n\n            $scope.getLinkParams = function(link) {\n\t\t\t\tvar params = {\n\t\t\t\t\ttype: 'custom',\n\t\t\t\t\turl: '',\n\t\t\t\t\tid: 0,\n\t\t\t\t\ttitle: '',\n\t\t\t\t\textra: '',\n\t\t\t\t\tnofollow: 0,\n\t\t\t\t\tblank: 0\n\t\t    \t};\n\t\t    \tif (link) {\n\t\t\t\t\tif (link.indexOf('{{mgzlink') === -1) {\n\t\t\t\t\t\tparams['url']  = link;\n\t\t\t\t\t\tparams['type'] = 'custom';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlink.gsub(/\\{\\{mgzlink(.*?)\\}\\}/i, function (match) {\n\t\t\t\t\t\t\tparams = magezonBuilderFilter.parseAttributesString(match[1]);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (params['url']) params['url'] = magezonBuilderService.removeslashes(params['url']);\n\t\t\t\treturn params;\n            }\n\n\t\t\t$scope.selectUrl = function() {\n\t\t\t\tmagezonBuilderModal.open('link', {\n\t\t\t\t\tbackdrop: true,\n\t\t\t\t\tresolve: {\n\t\t\t\t\t\tform: {\n\t\t\t\t\t\t\tmodel: $scope.getLinkParams($scope.model[$scope.options.key])\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, function(model) {\n\t\t\t\t\tvar link = '{{mgzlink';\n\t\t\t\t\tangular.forEach(model, function (value, key) {\n\t\t\t\t\t\tif (angular.isString(value)) {\n\t\t\t\t\t\t\tlink += ' ' + key + '=\"' + magezonBuilderService.addslashes(value) + '\"';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlink += ' ' + key + '=' + value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tlink += '}}';\n\t\t\t\t\t$scope.model[$scope.options.key] = link;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t$scope.$watch('model.' + $scope.options.key, function(link) {\n\t\t\t\tvar params = $scope.getLinkParams(link);\n\t\t\t\tvar type = params.type;\n\t\t\t\tif (type == 'custom') {\n\t\t\t\t\t$scope.type = 'Custom Url';\n\t\t\t\t\t$scope.linkName = params.url;\n\t\t\t\t} else {\n\t\t\t\t\t$scope.to.loading = true;\n\t\t\t\t\tmagezonBuilderService.post('mgzbuilder/ajax/itemInfo', {\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tq: params.id\n\t\t\t\t\t}, true, function(res) {\n\t\t\t\t\t\t$scope.$apply(function() {\n\t\t\t\t\t\t\t$scope.title      = params.title;\n\t\t\t\t\t\t\t$scope.type       = magezonBuilderService.capitalize(type);\n\t\t\t\t\t\t\t$scope.linkName   = res.label;\n\t\t\t\t\t\t\t$scope.to.loading = false;\n\t\t\t\t\t\t})\n\t\t\t\t\t});\t\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/animation-in.js":"define(['angular'], function(angular) {\n\n\treturn {\n\t\tcontroller: function($scope, magezonBuilderService, $timeout) {\n\t\t\t$scope.to.loading = true;\n\t\t\tmagezonBuilderService.getBuilderConfig('animationIn', function(options) {\n\t\t\t\t$scope.styles = angular.copy(options);\n\t\t\t\t$timeout(function() {\n\t\t\t\t\t$scope.to.loading = false;\n\t\t\t\t})\n\t\t\t});\n\n\t\t\t$scope.loadAnimate = function() {\n\t\t\t\t$scope.animateClass = $scope.fc.$viewValue + ' animated';\n\t\t\t\t$timeout(function() {\n\t\t\t\t\t$scope.animateClass = '';\n\t\t\t\t}, 1000);\n\t\t\t};\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/code.js":"define([\n\t'jquery'\n], function($) {\n\n\treturn {\n\t\tcontroller: function($scope, $timeout) {\n\t\t\t$timeout(function() {\n\t\t\t\t$scope.refreshEditor = true;\n\t\t\t}, 200);\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/dynamic-rows/position.js":"define([\n\t'jquery',\n\t'angular'\n], function($, angular) {\n\n\treturn {\n\t\tlink: function(scope, element, attrs, ctrl) {\n\t\t\t$(element).find('input').change(function(event) {\n\t\t\t\tscope.$emit('sortDynamicItems', {\n\t\t\t\t\tkey: scope.options.key\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/dynamic-rows/action-delete.js":"define([\n\t'jquery',\n\t'angular'\n], function($, angular) {\n\n\treturn {\n\t\tlink: function(scope, element, attrs) {\n\t\t\tscope.removeItem = function() {\n\t\t\t\tscope.$emit('removeDynamicItem', scope.model);\n\t\t\t}\n\t\t}\n\t}\n});","Magezon_Builder/js/form/element/dynamic-rows/radio.js":"define([\n\t'jquery',\n\t'angular'\n], function($, angular) {\n\n\treturn {\n\t\tlink: function(scope, element, attrs, ctrl) {\n\t\t\t$(element).find('input').click(function(event) {\n\t\t\t\tscope.$emit('radioDefaultDynamicItem', {\n\t\t\t\t\titem: scope.model,\n\t\t\t\t\tkey: scope.options.key\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});","Magezon_Builder/js/builder/helper.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/helper.html')\n\t\t\t},\n\t\t\tcontroller: function($rootScope, $scope) {\n\n\t\t\t\t$scope.addRowElement = function(columns) {\n\t\t\t\t\t$rootScope.$broadcast('addRootRowElement', columns);\n\t\t\t\t\t$rootScope.$broadcast('exportShortcode');\n\t\t\t\t}\n\n\t\t\t\t$scope.openModal = function() {\n\t\t\t\t\t$rootScope.$broadcast('openElementsModal', true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/control/updown.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/control/updown.html')\n\t\t\t},\n\t\t\tcontroller: function($rootScope, $scope, elementManager) {\n\n\t\t\t\t$scope.upClass   = 'mgz-fa-chevron-up';\n\t\t\t\t$scope.upTitle   = 'Move up';\n\t\t\t\t$scope.downClass = 'mgz-fa-chevron-down';\n\t\t\t\t$scope.downTitle = 'Move down';\n\n\t\t\t\t$scope.isUpVisible = function() {\n\t\t\t\t\tvar el = elementManager.getEl($scope.element);\n\t\t\t\t\tif (!el.prev('.mgz-element').length || !el.prev('.mgz-element').is(':visible')) return false;\n\t\t\t\t\tvar elPosition   = el.position();\n\t\t\t\t\tvar nextPosition = el.prev('.mgz-element').position();\n\t\t\t\t\tif (elPosition.top == nextPosition.top) {\n\t\t\t\t\t\t$scope.upTitle = 'Move left';\n\t\t\t\t\t\t$scope.upClass = 'mgz-fa-chevron-left';\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t$scope.moveUp = function() {\n\t\t\t\t\t$rootScope.$broadcast('moveUpElement', $scope.element);\n\t\t\t\t}\n\n\t\t\t\t$scope.isDownVisible = function() {\n\t\t\t\t\tvar el = elementManager.getEl($scope.element);\n\t\t\t\t\tif (!el.next('.mgz-element').length || !el.next('.mgz-element').is(':visible')) return false;\n\t\t\t\t\tvar elPosition   = el.position();\n\t\t\t\t\tvar prevPosition = el.next('.mgz-element').position();\n\t\t\t\t\tif (elPosition.top == prevPosition.top) {\n\t\t\t\t\t\t$scope.downTitle = 'Move right';\n\t\t\t\t\t\t$scope.downClass = 'mgz-fa-chevron-right';\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\t\n\t\t\t\t}\n\n\t\t\t\t$scope.moveDown = function() {\n\t\t\t\t\t$rootScope.$broadcast('moveDownElement', $scope.element);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/element/column.js":"define([\n\t'jquery',\n\t'angular',\n], function($, angular) {\n\n\tvar text = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getViewFileUrl('Magezon_Builder/js/templates/builder/element/list.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\t\t\t\tvar loaded = false;\n\t\t\t\tvar parent = $controller('listController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t\tvar parentElement = $scope.$parent.$parent.element;\n\t\t\t\tthis.getWrapperClasses = function() {\n\t\t\t\t\tvar classes = parent.getWrapperClasses();\n\t\t\t\t\tvar gapType = parentElement.gap_type ? parentElement.gap_type : 'padding';\n\t\t\t\t\tif (gapType == 'margin') {\n\t\t\t\t\t\tclasses.push('mgz-row-gap-margin');\n\t\t\t\t\t}\n\t\t\t\t\treturn classes;\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn text;\n});","Magezon_Builder/js/builder/element/row.js":"define([\n\t'jquery',\n\t'angular',\n], function($, angular) {\n\n\tvar text = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getViewFileUrl('Magezon_Builder/js/templates/builder/element/row.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\t\t\t\tvar loaded = false;\n\t\t\t\tvar parent = $controller('listController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t\tthis.getWrapperClasses = function() {\n\t\t\t\t\tvar classes = parent.getWrapperClasses();\n\t\t\t\t\tif ($scope.element.row_type == 'contained') {\n\t\t\t\t\t\tclasses.push('mgz-container');\n\t\t\t\t\t}\n\t\t\t\t\tif ($scope.element.equal_height) {\n\t\t\t\t\t\tclasses.push('mgz-row-equal-height');\n\t\t\t\t\t\tif ($scope.element.content_position) classes.push('content-' + $scope.element.content_position);\n\t\t\t\t\t}\n\t\t\t\t\tif ($scope.element.full_height) classes.push('mgz-row-full-height');\n\t\t\t\t\treturn classes;\n\t\t\t\t}\n\t\t\t},\n\t\t\tlink: function(scope, element) {\n\t\t\t\tvar height;\n\t\t\t\tscope.$watch('element.full_height', function(fullHeight) {\n\t\t\t\t\tif (fullHeight) {\n\t\t\t\t\t\theight = $(window).height();\n\t\t\t\t\t} else {\n\t\t\t\t\t\theight = '';\n\t\t\t\t\t}\n\t\t\t\t\telement.parent().css('min-height', height);\n\t\t\t\t});\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn text;\n});","Magezon_Builder/js/builder/element/text.js":"define([\n\t'jquery',\n\t'angular',\n], function($, angular) {\n\n\tvar text = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/element/text.html');\n\t\t\t},\n\t\t\tcontroller: function($rootScope, $scope, $controller) {\n\t\t\t\tvar loaded = false;\n\t\t\t\tvar parent = $controller('baseController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\n\t\t\t\t$scope.onChange = function(value) {\n\t\t\t\t\t$rootScope.$broadcast('addHistory', {\n\t\t\t\t\t\ttype: 'edited',\n\t\t\t\t\t\ttitle: $scope.element.builder.name,\n\t\t\t\t\t\tsubtitle: 'Content'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn text;\n});","Magezon_Builder/js/builder/element/gmaps.js":"define([\n\t'jquery',\n\t'angular'\n], function($, angular) {\n\n\tvar directive = function($rootScope, magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/element/gmaps.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\t\t\t\tvar parent = $controller('baseController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t},\n\t\t\tlink: function(scope, element) {\n\n\t\t\t\tscope.loadElement = function() {\n\t\t\t\t\tinitGoogleMap();\n\t\t\t\t}\n\n\t\t\t\tfunction getItems()\n\t\t\t\t{ \n\t\t\t\t\tvar $newItems = [];\n\t\t\t\t\t$items        = angular.copy(scope.element.items);\n\t\t\t\t\tif ($items) {\n\t\t\t\t\t\tangular.forEach($items, function($_item) {\n\t\t\t\t\t\t\tvar newItem = $_item;\n\t\t\t\t\t\t\tif (newItem['image']) {\n\t\t\t\t\t\t\t\tnewItem['image'] = magezonBuilderUrl.getImageUrl($_item['image']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$newItems.push(newItem);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn $newItems;\n\t\t\t\t}\n\n\t\t\t\tfunction getCenterItem() {\n\t\t\t\t\tvar $result = '';\n\t\t\t\t\tangular.forEach(scope.element.items, function($_item) {\n\t\t\t\t\t\tif ($_item['center'] && $_item['lat'] && $_item['lng'] && !$result) {\n\t\t\t\t\t\t\t$result = $_item;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (!$result) {\n\t\t\t\t\t\tangular.forEach(scope.element.items, function($_item) {\n\t\t\t\t\t\t\tif ($_item['lat'] && $_item['lng'] && !$result) {\n\t\t\t\t\t\t\t\t$result = $_item;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn $result;\n\t\t\t\t}\n\n\t\t\t\tfunction initGoogleMap() {\n\t\t\t\t\tvar _element               = scope.element;\n\t\t\t\t\tvar uid                    = _element.id + '-map';\n\t\t\t\t\tvar google_map_zoom        = parseInt(_element.map_zoom);\n\t\t\t\t\tvar google_map_type        = _element.map_type;\n\t\t\t\t\tvar google_map_ui          = _element.map_ui;\n\t\t\t\t\tvar google_map_scrollwheel = _element.map_scrollwheel;\n\t\t\t\t\tvar google_map_draggable   = _element.map_draggable;\n\t\t\t\t\tvar items                  = getItems();\n\t\t\t\t\tvar centerItem             = getCenterItem();\n\t\t\t\t\tvar self      = this;\n\t\t\t\t\trequire([\n\t\t\t\t\t\t'https://maps.google.com/maps/api/js?key=' + $rootScope.builderConfig.googleApi + '&libraries=places'\n\t\t\t\t\t], function() {\n\t\t\t\t\t\tif (!$('#' + uid).length) return;\n\n\t\t\t\t\t\tvar config = {\n\t\t\t\t\t\t\tcenter: {\n\t\t\t\t\t\t\t\tlat: parseFloat(centerItem['lat']),\n\t\t\t\t\t\t\t\tlng: parseFloat(centerItem['lng'])\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tzoom: google_map_zoom,\n\t\t\t\t\t\t\tmapTypeId: google_map_type,\n\t\t\t\t\t\t\tdisableDefaultUI: google_map_ui,\n\t\t\t\t\t\t\tscrollwheel: google_map_scrollwheel,\n\t\t\t\t\t\t\tdraggable: google_map_draggable\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar map = new google.maps.Map(document.getElementById(uid), config);\n\n\t\t\t\t\t\tif (items && items.length) {\n\t\t\t\t\t\t\titems.each(function(option) {\n\t\t\t\t\t\t\t\tvar myLatLng = new google.maps.LatLng(option['lat'], option['lng']);\n\t\t\t\t\t\t\t\taddMarker(myLatLng, map, option);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction addMarker(location, map, option) {\n\t\t\t\t\t\t\tvar marker = new google.maps.Marker({\n\t\t\t\t\t\t\t\tposition: location,\n\t\t\t\t\t\t\t\tmap: map,\n\t\t\t\t\t\t\t\ticon: option['image']\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (option['info']) {\n\t\t\t\t\t\t\t\tvar infowindow = new google.maps.InfoWindow({\n\t\t\t\t\t\t\t\t\tcontent: option['info']\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tmarker.addListener('click', function() {\n\t\t\t\t\t\t\t\t\tinfowindow.open(map, marker);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (element.infobox_opened) {\n\t\t\t\t\t\t\t\t\tinfowindow.open(map, marker);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tinitGoogleMap();\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/element/single-image.js":"define([\n\t'jquery',\n\t'angular'\n], function($, angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/element/single-image.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\t\t\t\tvar parent = $controller('baseController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\n\t\t\t\t$scope.getSrc = function() {\n\t\t\t\t\tvar src = magezonBuilderUrl.getImageUrl($scope.element.image);\n\n\t\t\t\t\tswitch($scope.element.source) {\n\t\t\t\t\t\tcase 'media_library':\n\t\t\t\t\t\t\tif ($scope.element.image)\n\t\t\t\t\t\t\tsrc = magezonBuilderUrl.getImageUrl($scope.element.image);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'external_link':\n\t\t\t\t\t\t\tif ($scope.element.custom_src)\n\t\t\t\t\t\t\tsrc = $scope.element.custom_src;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn src;\n\t\t\t\t}\n\t\t\t},\n\t\t\tlink: function(scope, element) {\n\t\t\t\telement.find('.mgz-single-image-inner').hover(function() {\n\t\t\t\t\tvar hoverImage = magezonBuilderUrl.getImageUrl(scope.element.hover_image);\n\t\t\t\t\tif (hoverImage) {\n\t\t\t\t\t\t$(this).find('img').attr('src', hoverImage);\n\t\t\t\t\t}\n\t\t\t\t}, function() {\n\t\t\t\t\tvar hoverImage = magezonBuilderUrl.getImageUrl(scope.element.hover_image);\n\t\t\t\t\tif (hoverImage && scope.getSrc()) {\n\t\t\t\t\t\t$(this).find('img').attr('src', scope.getSrc());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/element/base.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/element/default.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\t\t\t\tvar parent = $controller('baseController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/element/list.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/element/list.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\t\t\t\tvar parent = $controller('listController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/element/profile.js":"define([\n\t'jquery',\n\t'angular'\n], function ($, angular) {\n\n\tvar directive = function(magezonBuilderService, magezonBuilderUrl) {\n\t\treturn {\n\t\t\tscope: {\n\t\t\t\telement: '='\n\t\t\t},\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/element/profile.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $rootScope, $controller, elementManager) {\n\t\t\t\t//$scope.element = $scope.profile;\n\t\t\t\t$scope.element.builder = elementManager.getBuilderConfig('profile');\n\t\t\t\t//$scope.element.elements = [];\n\t\t\t\tvar self = this;\n\t\t\t\tvar parent = $controller('listController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\n\t\t\t\tvar mainElement = $rootScope.builderConfig.mainElement;\n\n\t\t\t\t$scope.$on('addRootRowElement', function(event, columns) {\n\t\t\t\t\tvar row            = self.addElement(mainElement, null, false);\n\t\t\t\t\tvar builderElement = self.getBuilderElement(mainElement);\n\t\t\t\t\tvar viewMode       = magezonBuilderService.getViewMode();\n\t\t\t\t\tvar types          = columns.split('_');\n\t\t\t\t\tfor (var i = 0; i < types.length - 1; i++) {\n\t\t\t\t\t\tvar _type   = types[i].split('');\n\t\t\t\t\t\tvar element = self.addElement(builderElement.children, row);\n\t\t\t\t\t\tvar width;\n\t\t\t\t\t\tif (_type[1]==5) {\n\t\t\t\t\t\t\twidth = 15\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twidth = 12 * _type[0] / _type[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telement['xl_size'] = '';\n\t\t\t\t\t\telement['lg_size'] = '';\n\t\t\t\t\t\telement['md_size'] = width;\n\t\t\t\t\t\telement['sm_size'] = '';\n\t\t\t\t\t\telement['xs_size'] = '';\n\t\t\t\t\t}\n\n\t\t\t\t\t// First Column\n\t\t\t\t\trow['elements'][0]['xl_size'] = '';\n\t\t\t\t\trow['elements'][0]['lg_size'] = '';\n\t\t\t\t\trow['elements'][0]['md_size'] = width;\n\t\t\t\t\trow['elements'][0]['sm_size'] = '';\n\t\t\t\t\trow['elements'][0]['xs_size'] = '';\n\n\t\t\t\t\tif (!$('.mgz-fullscreen').length) {\n\t\t\t\t\t\t$rootScope.$broadcast('setViewMode', 'xl');\t\n\t\t\t\t\t}\n\n\t\t\t\t\t$rootScope.$broadcast('addHistory', {\n\t\t\t\t\t\ttype: 'changed',\n\t\t\t\t\t\tsubtitle: 'Row Layout'\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/element/countdown.js":"define([\n\t'angular',\n\t'moment',\n\t'Magezon_Builder/js/countdown',\n\t'moment-timezone-with-data'\n], function(angular, moment) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/element/countdown.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\t\t\t\tvar parent = $controller('baseController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t},\n\t\t\tlink: function(scope, element) {\n\t\t\t\tvar loadCountdown = function() {\n\t\t\t\t\tvar _element = scope.element;\n\t\t\t\t\tvar timeStr  = _element.year + '-' + _element.month + '-' + _element.day + ' ' + _element.hours + ':' + _element.minutes;\n\t\t\t\t\tvar time     = moment(timeStr, 'YYYY-MM-DD HH:mm').tz(_element.time_zone);\t\n\t\t\t\t\tif (element.data(\"countdown\")) {\n\t\t\t\t\t\telement.data(\"countdown\").clearInterval();\n\t\t\t\t\t\telement.find('.mgz-element-bar').css({\n\t\t\t\t\t\t\t'stroke-dashoffset': '',\n\t\t\t\t\t\t\t'width': ''\n\t\t\t\t\t\t});\n\t\t\t\t\t\telement.countdown('destroy');\n\t\t\t\t\t}\n\t\t\t\t\tvar time1 = time.isValid() ? time.format() : moment().format();\n\t\t\t\t\telement.countdown({\n\t\t\t\t\t\ttype:_element.layout,\n\t\t\t\t\t\ttime: time1\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tscope.loadElement = function() {\n\t\t\t\t\tloadCountdown();\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/element/separator.js":"define([\n\t'jquery',\n\t'angular',\n], function($, angular) {\n\n\tvar heading = function(magezonBuilderUrl, $compile) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/element/separator.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\t\t\t\tvar parent = $controller('baseController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t\tvar self = this;\n\t\t\t},\n\t\t\tlink: function($scope, $element, $attr) {\n\t\t\t\tvar $parent = $element.parent();\n\t\t\t\t$scope.$watch('element.title_tag', function(newVal) {\n\t\t\t\t\tvar template = '<' + newVal + ' class=\"title mgz-inline-edit\">';\n\t\t\t\t\t\tif ($scope.element.add_icon && $scope.element.icon_position == 'left') {\n\t\t\t\t\t\t\ttemplate += '<i class=\"mgz-icon-element ' + $scope.element.icon + '\"></i>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemplate += '<span content-editable=\"true\" ng-model=\"element.title\">' + $scope.element.title + '</span>';\n\t\t\t\t\t\tif ($scope.element.add_icon && $scope.element.icon_position == 'right') {\n\t\t\t\t\t\t\ttemplate += '<i class=\"mgz-icon-element ' + $scope.element.icon + '\"></i>';\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemplate += '</' + newVal + '>';\n\t\t\t\t\t\tvar html = $compile(template)($scope);\n\t\t\t\t\t\t$parent.find('.mgz-inline-edit').replaceWith(html);\n\t\t\t\t});\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn heading;\n});","Magezon_Builder/js/builder/element/heading.js":"define([\n\t'jquery',\n\t'angular',\n], function($, angular) {\n\n\tvar heading = function(magezonBuilderUrl, $compile, $timeout) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/element/heading.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\t\t\t\tvar parent = $controller('baseController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t\tvar self = this;\n\t\t\t},\n\t\t\tlink: function($scope, $element, $attr) {\n\t\t\t\tvar $parent = $element.parent();\n\t\t\t\t$scope.$watch('element.heading_type', function(newVal) {\n\t\t\t\t\tvar template = '<' + newVal + ' class=\"mgz-element-heading-text\" content-editable=\"true\" type=\"multiple\" ng-model=\"element.text\" ng-model-options=\"{ debounce: 300 }\" data-placeholder=\"Edit Heading Text\">' + $scope.element.text + '</' + newVal + '>';\n\t\t\t\t\tvar html = $compile(template)($scope);\n                    $parent.html(html);\n                    if ($scope.loaded) {\n                    \t$parent.children('.mgz-contenteditable-element').trigger('focus');\t\n                    }\n\t\t\t\t});\n\t\t\t\t$timeout(function() {\n\t\t\t\t\t$scope.loaded = true;\n\t\t\t\t}, 500);\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn heading;\n});","Magezon_Builder/js/builder/element/tabs.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl, $timeout) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getViewFileUrl('Magezon_Builder/js/templates/builder/element/tabs.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\n\t\t\t\tvar parent = $controller('listController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t\tvar self = this;\n\n\t\t\t\t$scope.element.builder.dndDisabled = true;\n\n\t\t\t\tangular.forEach($scope.element.elements, function(element, index) {\n\t\t\t\t\tif (index == 0) {\n\t\t\t\t\t\telement.builder.visible = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\telement.builder.visible = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t$scope.$on('afterAddElement', function(e, elem) {\n\t\t\t\t\t$scope.activeEventElement(elem);\n\t\t\t\t});\n\n\t\t\t\t$scope.$on('afterCloneElement', function(e, elem) {\n\t\t\t\t\tif ($scope.isChildren(elem)) {\n\t\t\t\t\t\t$scope.activeEventElement(elem);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t$scope.$on('afterDropElement', function(e, elem) {\n\t\t\t\t\tif ($scope.isChildren(elem)) {\n\t\t\t\t\t\t$scope.activeEventElement(elem);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t$scope.activeEventElement = function(elem) {\n\t\t\t\t\tif ($scope.isChildren(elem)) {\n\t\t\t\t\t\t$scope.activeElement(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$scope.$on('beforeRemoveElement', function(e, elem) {\n\t\t\t\t\tif ($scope.isChildren(elem)) {\n\t\t\t\t\t\tvar index = $scope.getElemIndex(elem);\n\t\t\t\t\t\tvar elem2 = $scope.element.elements[index+1] ? $scope.element.elements[index+1] : 0;\n\t\t\t\t\t\tif(elem2) $scope.activeElement(elem2);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t$scope.activeElement = function(element) {\n\t\t\t\t\tif (!element) return;\n\t\t\t\t\telement.builder.additionalClasses.push('mgz-tabs-tab-content');\n\t\t\t\t\tangular.forEach($scope.element.elements, function(el, index) {\n\t\t\t\t\t\tif (el !== element) {\n\t\t\t\t\t\t\tel.builder.visible = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\telement.builder.visible = true;\n\t\t\t\t\telement.builder.additionalClasses.push('mgz-active');\n\t\t\t\t}\n\n\t\t\t\t$scope.activeFirstElement = function() {\n\t\t\t\t\tvar active = true;\n\t\t\t\t\tangular.forEach($scope.element.elements, function(element) {\n\t\t\t\t\t\tif (!element.builder.visible) {\n\t\t\t\t\t\t\tactive = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (!active) {\n\t\t\t\t\t\t$scope.activeElement($scope.element.elements[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$scope.activeFirstElement();\n\n\t\t\t\t$scope.getClassess = function() {\n\t\t\t\t\tvar _elem = $scope.element;\n\t\t\t\t\tvar clasess = [];\n\t\t\t\t\tclasess.push('mgz-tabs');\n\t\t\t\t\tclasess.push('mgz-tabs-' + _elem.id);\n\t\t\t\t\tclasess.push('mgz-element-tab-align-' + _elem.tab_align);\n\t\t\t\t\tclasess.push('mgz-element-tab-position-' + _elem.tab_position);\n\t\t\t\t\tif (_elem.no_fill_content_area) clasess.push('mgz-tabs-no-fill-content');\n\t\t\t\t\tif (_elem.mobile_accordion) clasess.push('tabs-mobile-accordion');\n\t\t\t\t\treturn clasess;\n\t\t\t\t}\n\n\t\t\t\t$scope.getSpacing = function() {\n\t\t\t\t\treturn $scope.element.spacing ? parseFloat($scope.element.spacing) : 0;\n\t\t\t\t}\n\n\t\t\t\t$scope.getGap = function() {\n\t\t\t\t\treturn $scope.element.gap ? parseFloat($scope.element.gap) : 0;\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrollerAs: 'mgz'\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/element/heading/toolbar.js":"define([\n\t'jquery',\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getViewFileUrl('Magezon_Builder/js/templates/builder/element/heading/toolbar.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\n\t\t\t\tvar parent = $controller('toolbarController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t\tvar self = this;\n\n\t\t\t\t$scope.fontSize = $scope.element.font_size;\n\n\t\t\t\t$scope.updatedkey = function(key, value) {\n\t\t\t\t\tswitch(key) {\n\t\t\t\t\t\tcase 'elemHeading':\n\t\t\t\t\t\t\t$scope.element.heading_type = value;\n\t\t\t\t\t\t\t$scope.addHistory('edited', 'Type');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'elemAlign':\n\t\t\t\t\t\t\t$scope.element.align = value;\n\t\t\t\t\t\t\t$scope.addHistory('edited', 'Alignment');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$scope.$watch('element.text', function(text, old) {\n\t\t\t\t\tif ($scope.isLoaded() && (text !== old)) {\n\t\t\t\t\t\t$scope.addHistory('edited', 'Text');\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t$scope.$watch('element.color', function(color, old) {\n\t\t\t\t\tif ($scope.isLoaded() && (color !== old)) {\n\t\t\t\t\t\t$scope.addHistory('edited', 'Color');\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t$scope.changeFontSize = function(e) {\n\t\t\t\t\t$scope.element.font_size = $scope.fontSize;\n\t\t\t\t\t$scope.addHistory('edited', 'Font Size');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/element/separator/toolbar.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getViewFileUrl('Magezon_Builder/js/templates/builder/element/separator/toolbar.html');\n\t\t\t},\n\t\t\tcontroller: function($scope, $controller) {\n\t\t\t\tvar parent = $controller('toolbarController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t\tvar self = this;\n\n\t\t\t\t$scope.updatedkey = function(key, value) {\n\t\t\t\t\tswitch(key) {\n\t\t\t\t\t\tcase 'elemHeading':\n\t\t\t\t\t\t\t$scope.element.title_tag = value;\n\t\t\t\t\t\t\t$scope.addHistory('edited', 'Tag');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'elemAlign':\n\t\t\t\t\t\t\t$scope.element.title_align = value;\n\t\t\t\t\t\t\t$scope.addHistory('edited', 'Alignment');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$scope.$watch('element.text', function(text) {\n\t\t\t\t\tif ($scope.isLoaded()) {\n\t\t\t\t\t\t$scope.addHistory('edited', 'Text');\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t$scope.$watch('element.color', function(color) {\n\t\t\t\t\tif ($scope.isLoaded()) {\n\t\t\t\t\t\t$scope.addHistory('edited', 'Color');\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/element/text/toolbar.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\tcontroller: function($scope, $controller) {\n\t\t\t\tvar parent = $controller('toolbarController', {$scope: $scope});\n\t\t\t\tangular.extend(this, parent);\n\t\t\t\tvar self = this;\n\t\t\t\tvar loaded = false;\n\n\t\t\t\t$scope.$watch('element.content', function(content) {\n\t\t\t\t\tif (loaded) {\n\t\t\t\t\t\t$rootScope.$broadcast('addHistory', {\n\t\t\t\t\t\t\ttype: 'edited',\n\t\t\t\t\t\t\ttitle: $scope.element.builder.name,\n\t\t\t\t\t\t\tsubtitle: 'Content'\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tloaded = true;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/navbar/fullscreen.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/navbar/fullscreen.html')\n\t\t\t},\n\t\t\tcontroller: function($rootScope, $scope) {\n\t\t\t\t$scope.toggleFullscreen = function() {\n\t\t\t\t\t$rootScope.fullscreen = !$rootScope.fullscreen;\n\t\t\t\t\tif (!$rootScope.fullscreen) {\n\t\t\t\t\t\t$rootScope.$broadcast('setViewMode', 'xl');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/navbar/settings.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/navbar/settings.html')\n\t\t\t},\n\t\t\tcontroller: function($scope, magezonBuilderModal) {\n\t\t\t\t$scope.openModal = function () {\n\t\t\t\t\tmagezonBuilderModal.open('settings');\n\t\t        }\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/navbar/navigator.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/navbar/navigator.html')\n\t\t\t},\n\t\t\tcontroller: function($rootScope, $scope, magezonBuilderModal) {\n\t\t\t\t$scope.$on('openNavigatorModal', function() {\n\t\t\t\t\t$scope.openModal();\n\t\t\t\t});\n\t\t\t\t$scope.openModal = function() {\n\t\t\t\t\tmagezonBuilderModal.open('navigator').result.then(function() {}, function() {\n\t\t\t\t\t\tif($rootScope.activedElement) $rootScope.activedElement.builder.actived = false;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/navbar/shortcode.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/navbar/shortcode.html')\n\t\t\t},\n\t\t\tcontroller: function($scope, magezonBuilderModal) {\n\t\t\t\t$scope.openProfileShortcodeModal = function() {\n\t\t\t\t\tmagezonBuilderModal.open('profileShortcode');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/navbar/clear.js":"define([\n\t'jquery',\n\t'angular'\n], function($, angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/navbar/clear.html')\n\t\t\t},\n\t\t\tcontroller: function($rootScope, $scope, magezonBuilderModal) {\n\t\t\t\t$scope.openModal = function(e) {\n\t\t\t\t\tmagezonBuilderModal.open('clear_layout');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/navbar/my-templates.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/navbar/my_templates.html')\n\t\t\t},\n\t\t\tcontroller: function($scope, magezonBuilderModal) {\n\t\t\t\t$scope.openTemplatesModal = function() {\n\t\t\t\t\tmagezonBuilderModal.open('templates');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/navbar/view_mode.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderService, magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/navbar/view_mode.html')\n\t\t\t},\n\t\t\tcontroller: function($rootScope, $scope) {\n\n\t\t\t\t$scope.viewMode  = magezonBuilderService.getViewMode();\n\n\t\t\t\t$scope.viewModes = {\n\t\t\t\t\txl: {\n\t\t\t\t\t\ttitle: 'Desktop',\n\t\t\t\t\t\ticon: 'mgz-icon mgz-icon-desktop'\n\t\t\t\t\t},\n\t\t\t\t\tlg: {\n\t\t\t\t\t\ttitle: 'Tablet Landscape',\n\t\t\t\t\t\ticon: 'mgz-icon mgz-icon-tablet-landscape'\n\t\t\t\t\t},\n\t\t\t\t\tmd: {\n\t\t\t\t\t\ttitle: 'Tablet Portrait',\n\t\t\t\t\t\ticon: 'mgz-icon mgz-icon-tablet-portrait'\n\t\t\t\t\t},\n\t\t\t\t\tsm: {\n\t\t\t\t\t\ttitle: 'Mobile Landscape',\n\t\t\t\t\t\ticon: 'mgz-icon mgz-icon-mobile-landscape'\n\t\t\t\t\t},\n\t\t\t\t\txs: {\n\t\t\t\t\t\ttitle: 'Mobile Portrait',\n\t\t\t\t\t\ticon: 'mgz-icon mgz-icon-mobile-portrait'\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$scope.changeViewMode = function(viewMode) {\n\t\t\t\t\t$scope.viewMode = viewMode;\n\t\t\t\t\tmagezonBuilderService.setViewMode(viewMode);\n\t\t\t\t\t$rootScope.fullscreen = true;\n\t\t\t\t\t$rootScope.$broadcast('loadElements');\n\t\t\t\t}\n\n\t\t\t\t$scope.$watch('viewMode', function(viewMode) {\n\t\t\t\t\t$rootScope.$broadcast('changedViewMode', viewMode);\n\t\t\t\t});\n\n\t\t\t\t$scope.$on('setViewMode', function(event, viewMode) {\n\t\t\t\t\t$scope.viewMode = viewMode;\n\t\t\t\t\tmagezonBuilderService.setViewMode(viewMode);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/navbar/history.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/navbar/history.html')\n\t\t\t},\n\t\t\tcontroller: function($rootScope, $scope, magezonBuilderModal) {\n\t\t\t\t$scope.$on('openHistoryModal', function() {\n\t\t\t\t\t$scope.openModal();\n\t\t\t\t});\n\t\t\t\t$scope.openModal = function() {\n\t\t\t\t\tmagezonBuilderModal.open('history');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/navbar/templates.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/navbar/add.html')\n\t\t\t},\n\t\t\tcontroller: function($rootScope, $scope) {\n\t\t\t\t$scope.openModal = function() {\n\t\t\t\t\t$rootScope.$broadcast('openElementsModal', true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/builder/navbar/add.js":"define([\n\t'angular'\n], function(angular) {\n\n\tvar directive = function(magezonBuilderUrl) {\n\t\treturn {\n\t\t\treplace: true,\n\t\t\ttemplateUrl: function(elem) {\n\t\t\t\treturn magezonBuilderUrl.getTemplateUrl(elem, 'Magezon_Builder/js/templates/builder/navbar/add.html')\n\t\t\t},\n\t\t\tcontroller: function($rootScope, $scope) {\n\t\t\t\t$scope.openElementsModal = function() {\n\t\t\t\t\t$rootScope.$broadcast('openElementsModal', true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn directive;\n});","Magezon_Builder/js/apply/main.js":"/**\n * Copyright \u00a9 Magento, Inc. All rights reserved.\n * See COPYING.txt for license details.\n */\n\ndefine([\n    'underscore',\n    'jquery',\n    'mage/apply/scripts'\n], function (_, $, processScripts) {\n    'use strict';\n\n    var dataAttr = 'data-mage-init',\n        nodeSelector = '[' + dataAttr + ']';\n\n    /**\n     * Initializes components assigned to a specified element via data-* attribute.\n     *\n     * @param {HTMLElement} el - Element to initialize components with.\n     * @param {Object|String} config - Initial components' config.\n     * @param {String} component - Components' path.\n     */\n    function init(el, config, component) {\n        require([component], function (fn) {\n\n            if (typeof fn === 'object') {\n                fn = fn[component].bind(fn);\n            }\n\n            if (_.isFunction(fn)) {\n                fn(config, el);\n            } else if ($(el)[component]) {\n                $(el)[component](config);\n            }\n        }, function (error) {\n            if ('console' in window && typeof window.console.error === 'function') {\n                console.error(error);\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Parses elements 'data-mage-init' attribute as a valid JSON data.\n     * Note: data-mage-init attribute will be removed.\n     *\n     * @param {HTMLElement} el - Element whose attribute should be parsed.\n     * @returns {Object}\n     */\n    function getData(el) {\n        var data = el.getAttribute(dataAttr);\n\n        el.removeAttribute(dataAttr);\n\n        return {\n            el: el,\n            data: JSON.parse(data)\n        };\n    }\n\n    return {\n        /**\n         * Initializes components assigned to HTML elements via [data-mage-init].\n         *\n         * @example Sample 'data-mage-init' declaration.\n         *      data-mage-init='{\"path/to/component\": {\"foo\": \"bar\"}}'\n         */\n        apply: function (context) {\n            var virtuals = processScripts(!context ? document : context),\n                nodes = document.querySelectorAll(nodeSelector);\n\n            _.toArray(nodes)\n                .map(getData)\n                .concat(virtuals)\n                .forEach(function (itemContainer) {\n                    var element = itemContainer.el;\n\n                    _.each(itemContainer.data, function (obj, key) {\n                            if(key.indexOf('Magezon_Builder') != -1 || key.indexOf('Magezon_PageBuilder') != -1) {\n                                if (obj.mixins) {\n                                    require(obj.mixins, function () { //eslint-disable-line max-nested-callbacks\n                                        var i, len;\n\n                                        for (i = 0, len = arguments.length; i < len; i++) {\n                                            $.extend(\n                                                true,\n                                                itemContainer.data[key],\n                                                arguments[i](itemContainer.data[key], element)\n                                            );\n                                        }\n\n                                        delete obj.mixins;\n                                        init.call(null, element, obj, key);\n                                    });\n                                } else {\n                                    init.call(null, element, obj, key);\n                                }\n                            }\n\n                        }\n                    );\n\n                });\n        },\n        applyFor: init\n    };\n});\n","Magezon_Builder/js/waypoints/waypoints.debug.js":"/*!\nWaypoints Debug - 4.0.1\nCopyright \u00a9 2011-2016 Caleb Troughton\nLicensed under the MIT license.\nhttps://github.com/imakewebthings/waypoints/blob/master/licenses.txt\n*/\n(function() {\n  'use strict'\n\n  var displayNoneMessage = [\n    'You have a Waypoint element with display none. For more information on ',\n    'why this is a bad idea read ',\n    'http://imakewebthings.com/waypoints/guides/debugging/#display-none'\n  ].join('')\n  var fixedMessage = [\n    'You have a Waypoint element with fixed positioning. For more ',\n    'information on why this is a bad idea read ',\n    'http://imakewebthings.com/waypoints/guides/debugging/#fixed-position'\n  ].join('')\n\n  function checkWaypointStyles() {\n    var originalRefresh = window.Waypoint.Context.prototype.refresh\n\n    window.Waypoint.Context.prototype.refresh = function() {\n      for (var axis in this.waypoints) {\n        for (var key in this.waypoints[axis]) {\n          var waypoint = this.waypoints[axis][key]\n          var style = window.getComputedStyle(waypoint.element)\n          if (!waypoint.enabled) {\n            continue\n          }\n          if (style && style.display === 'none') {\n            console.error(displayNoneMessage)\n          }\n          if (style && style.position === 'fixed') {\n            console.error(fixedMessage)\n          }\n        }\n      }\n      return originalRefresh.call(this)\n    }\n  }\n\n  checkWaypointStyles()\n}())\n;","Magezon_Builder/js/waypoints/zepto.waypoints.min.js":"/*!\nWaypoints - 4.0.1\nCopyright \u00a9 2011-2016 Caleb Troughton\nLicensed under the MIT license.\nhttps://github.com/imakewebthings/waypoints/blob/master/licenses.txt\n*/\n!function(){\"use strict\";function t(o){if(!o)throw new Error(\"No options passed to Waypoint constructor\");if(!o.element)throw new Error(\"No element option passed to Waypoint constructor\");if(!o.handler)throw new Error(\"No handler option passed to Waypoint constructor\");this.key=\"waypoint-\"+e,this.options=t.Adapter.extend({},t.defaults,o),this.element=this.options.element,this.adapter=new t.Adapter(this.element),this.callback=o.handler,this.axis=this.options.horizontal?\"horizontal\":\"vertical\",this.enabled=this.options.enabled,this.triggerPoint=null,this.group=t.Group.findOrCreate({name:this.options.group,axis:this.axis}),this.context=t.Context.findOrCreateByElement(this.options.context),t.offsetAliases[this.options.offset]&&(this.options.offset=t.offsetAliases[this.options.offset]),this.group.add(this),this.context.add(this),i[this.key]=this,e+=1}var e=0,i={};t.prototype.queueTrigger=function(t){this.group.queueTrigger(this,t)},t.prototype.trigger=function(t){this.enabled&&this.callback&&this.callback.apply(this,t)},t.prototype.destroy=function(){this.context.remove(this),this.group.remove(this),delete i[this.key]},t.prototype.disable=function(){return this.enabled=!1,this},t.prototype.enable=function(){return this.context.refresh(),this.enabled=!0,this},t.prototype.next=function(){return this.group.next(this)},t.prototype.previous=function(){return this.group.previous(this)},t.invokeAll=function(t){var e=[];for(var o in i)e.push(i[o]);for(var n=0,r=e.length;r>n;n++)e[n][t]()},t.destroyAll=function(){t.invokeAll(\"destroy\")},t.disableAll=function(){t.invokeAll(\"disable\")},t.enableAll=function(){t.Context.refreshAll();for(var e in i)i[e].enabled=!0;return this},t.refreshAll=function(){t.Context.refreshAll()},t.viewportHeight=function(){return window.innerHeight||document.documentElement.clientHeight},t.viewportWidth=function(){return document.documentElement.clientWidth},t.adapters=[],t.defaults={context:window,continuous:!0,enabled:!0,group:\"default\",horizontal:!1,offset:0},t.offsetAliases={\"bottom-in-view\":function(){return this.context.innerHeight()-this.adapter.outerHeight()},\"right-in-view\":function(){return this.context.innerWidth()-this.adapter.outerWidth()}},window.Waypoint=t}(),function(){\"use strict\";function t(t){window.setTimeout(t,1e3/60)}function e(t){this.element=t,this.Adapter=n.Adapter,this.adapter=new this.Adapter(t),this.key=\"waypoint-context-\"+i,this.didScroll=!1,this.didResize=!1,this.oldScroll={x:this.adapter.scrollLeft(),y:this.adapter.scrollTop()},this.waypoints={vertical:{},horizontal:{}},t.waypointContextKey=this.key,o[t.waypointContextKey]=this,i+=1,n.windowContext||(n.windowContext=!0,n.windowContext=new e(window)),this.createThrottledScrollHandler(),this.createThrottledResizeHandler()}var i=0,o={},n=window.Waypoint,r=window.onload;e.prototype.add=function(t){var e=t.options.horizontal?\"horizontal\":\"vertical\";this.waypoints[e][t.key]=t,this.refresh()},e.prototype.checkEmpty=function(){var t=this.Adapter.isEmptyObject(this.waypoints.horizontal),e=this.Adapter.isEmptyObject(this.waypoints.vertical),i=this.element==this.element.window;t&&e&&!i&&(this.adapter.off(\".waypoints\"),delete o[this.key])},e.prototype.createThrottledResizeHandler=function(){function t(){e.handleResize(),e.didResize=!1}var e=this;this.adapter.on(\"resize.waypoints\",function(){e.didResize||(e.didResize=!0,n.requestAnimationFrame(t))})},e.prototype.createThrottledScrollHandler=function(){function t(){e.handleScroll(),e.didScroll=!1}var e=this;this.adapter.on(\"scroll.waypoints\",function(){(!e.didScroll||n.isTouch)&&(e.didScroll=!0,n.requestAnimationFrame(t))})},e.prototype.handleResize=function(){n.Context.refreshAll()},e.prototype.handleScroll=function(){var t={},e={horizontal:{newScroll:this.adapter.scrollLeft(),oldScroll:this.oldScroll.x,forward:\"right\",backward:\"left\"},vertical:{newScroll:this.adapter.scrollTop(),oldScroll:this.oldScroll.y,forward:\"down\",backward:\"up\"}};for(var i in e){var o=e[i],n=o.newScroll>o.oldScroll,r=n?o.forward:o.backward;for(var s in this.waypoints[i]){var a=this.waypoints[i][s];if(null!==a.triggerPoint){var l=o.oldScroll<a.triggerPoint,h=o.newScroll>=a.triggerPoint,p=l&&h,u=!l&&!h;(p||u)&&(a.queueTrigger(r),t[a.group.id]=a.group)}}}for(var c in t)t[c].flushTriggers();this.oldScroll={x:e.horizontal.newScroll,y:e.vertical.newScroll}},e.prototype.innerHeight=function(){return this.element==this.element.window?n.viewportHeight():this.adapter.innerHeight()},e.prototype.remove=function(t){delete this.waypoints[t.axis][t.key],this.checkEmpty()},e.prototype.innerWidth=function(){return this.element==this.element.window?n.viewportWidth():this.adapter.innerWidth()},e.prototype.destroy=function(){var t=[];for(var e in this.waypoints)for(var i in this.waypoints[e])t.push(this.waypoints[e][i]);for(var o=0,n=t.length;n>o;o++)t[o].destroy()},e.prototype.refresh=function(){var t,e=this.element==this.element.window,i=e?void 0:this.adapter.offset(),o={};this.handleScroll(),t={horizontal:{contextOffset:e?0:i.left,contextScroll:e?0:this.oldScroll.x,contextDimension:this.innerWidth(),oldScroll:this.oldScroll.x,forward:\"right\",backward:\"left\",offsetProp:\"left\"},vertical:{contextOffset:e?0:i.top,contextScroll:e?0:this.oldScroll.y,contextDimension:this.innerHeight(),oldScroll:this.oldScroll.y,forward:\"down\",backward:\"up\",offsetProp:\"top\"}};for(var r in t){var s=t[r];for(var a in this.waypoints[r]){var l,h,p,u,c,d=this.waypoints[r][a],f=d.options.offset,w=d.triggerPoint,y=0,g=null==w;d.element!==d.element.window&&(y=d.adapter.offset()[s.offsetProp]),\"function\"==typeof f?f=f.apply(d):\"string\"==typeof f&&(f=parseFloat(f),d.options.offset.indexOf(\"%\")>-1&&(f=Math.ceil(s.contextDimension*f/100))),l=s.contextScroll-s.contextOffset,d.triggerPoint=Math.floor(y+l-f),h=w<s.oldScroll,p=d.triggerPoint>=s.oldScroll,u=h&&p,c=!h&&!p,!g&&u?(d.queueTrigger(s.backward),o[d.group.id]=d.group):!g&&c?(d.queueTrigger(s.forward),o[d.group.id]=d.group):g&&s.oldScroll>=d.triggerPoint&&(d.queueTrigger(s.forward),o[d.group.id]=d.group)}}return n.requestAnimationFrame(function(){for(var t in o)o[t].flushTriggers()}),this},e.findOrCreateByElement=function(t){return e.findByElement(t)||new e(t)},e.refreshAll=function(){for(var t in o)o[t].refresh()},e.findByElement=function(t){return o[t.waypointContextKey]},window.onload=function(){r&&r(),e.refreshAll()},n.requestAnimationFrame=function(e){var i=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||t;i.call(window,e)},n.Context=e}(),function(){\"use strict\";function t(t,e){return t.triggerPoint-e.triggerPoint}function e(t,e){return e.triggerPoint-t.triggerPoint}function i(t){this.name=t.name,this.axis=t.axis,this.id=this.name+\"-\"+this.axis,this.waypoints=[],this.clearTriggerQueues(),o[this.axis][this.name]=this}var o={vertical:{},horizontal:{}},n=window.Waypoint;i.prototype.add=function(t){this.waypoints.push(t)},i.prototype.clearTriggerQueues=function(){this.triggerQueues={up:[],down:[],left:[],right:[]}},i.prototype.flushTriggers=function(){for(var i in this.triggerQueues){var o=this.triggerQueues[i],n=\"up\"===i||\"left\"===i;o.sort(n?e:t);for(var r=0,s=o.length;s>r;r+=1){var a=o[r];(a.options.continuous||r===o.length-1)&&a.trigger([i])}}this.clearTriggerQueues()},i.prototype.next=function(e){this.waypoints.sort(t);var i=n.Adapter.inArray(e,this.waypoints),o=i===this.waypoints.length-1;return o?null:this.waypoints[i+1]},i.prototype.previous=function(e){this.waypoints.sort(t);var i=n.Adapter.inArray(e,this.waypoints);return i?this.waypoints[i-1]:null},i.prototype.queueTrigger=function(t,e){this.triggerQueues[e].push(t)},i.prototype.remove=function(t){var e=n.Adapter.inArray(t,this.waypoints);e>-1&&this.waypoints.splice(e,1)},i.prototype.first=function(){return this.waypoints[0]},i.prototype.last=function(){return this.waypoints[this.waypoints.length-1]},i.findOrCreate=function(t){return o[t.axis][t.name]||new i(t)},n.Group=i}(),function(){\"use strict\";function t(t){this.element=t,this.$element=e(t)}var e=window.Zepto,i=window.Waypoint;e.each([\"off\",\"on\",\"scrollLeft\",\"scrollTop\"],function(e,i){t.prototype[i]=function(){var t=Array.prototype.slice.call(arguments);return this.$element[i].apply(this.$element,t)}}),t.prototype.offset=function(){return this.element!==this.element.window?this.$element.offset():void 0},e.each([\"width\",\"height\"],function(i,o){function n(t,i){return function(t){var n=this.$element,r=n[o](),s={width:[\"left\",\"right\"],height:[\"top\",\"bottom\"]};return e.each(s[o],function(e,o){r+=parseInt(n.css(\"padding-\"+o),10),i&&(r+=parseInt(n.css(\"border-\"+o+\"-width\"),10)),t&&(r+=parseInt(n.css(\"margin-\"+o),10))}),r}}var r=e.camelCase(\"inner-\"+o),s=e.camelCase(\"outer-\"+o);t.prototype[r]=n(!1),t.prototype[s]=n(!0)}),e.each([\"extend\",\"inArray\"],function(i,o){t[o]=e[o]}),t.isEmptyObject=function(t){for(var e in t)return!1;return!0},i.adapters.push({name:\"zepto\",Adapter:t}),i.Adapter=t}(),function(){\"use strict\";function t(t){return function(){var i=[],o=arguments[0];return t.isFunction(arguments[0])&&(o=t.extend({},arguments[1]),o.handler=arguments[0]),this.each(function(){var n=t.extend({},o,{element:this});\"string\"==typeof n.context&&(n.context=t(this).closest(n.context)[0]),i.push(new e(n))}),i}}var e=window.Waypoint;window.jQuery&&(window.jQuery.fn.waypoint=t(window.jQuery)),window.Zepto&&(window.Zepto.fn.waypoint=t(window.Zepto))}();","Magezon_Builder/js/waypoints/jquery.waypoints.js":"/*!\nWaypoints - 4.0.1\nCopyright \u00a9 2011-2016 Caleb Troughton\nLicensed under the MIT license.\nhttps://github.com/imakewebthings/waypoints/blob/master/licenses.txt\n*/\ndefine(['jquery'], function($) {\n(function() {\n  'use strict'\n\n  var keyCounter = 0\n  var allWaypoints = {}\n\n  /* http://imakewebthings.com/waypoints/api/waypoint */\n  function Waypoint(options) {\n    if (!options) {\n      throw new Error('No options passed to Waypoint constructor')\n    }\n    if (!options.element) {\n      throw new Error('No element option passed to Waypoint constructor')\n    }\n    if (!options.handler) {\n      throw new Error('No handler option passed to Waypoint constructor')\n    }\n\n    this.key = 'waypoint-' + keyCounter\n    this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options)\n    this.element = this.options.element\n    this.adapter = new Waypoint.Adapter(this.element)\n    this.callback = options.handler\n    this.axis = this.options.horizontal ? 'horizontal' : 'vertical'\n    this.enabled = this.options.enabled\n    this.triggerPoint = null\n    this.group = Waypoint.Group.findOrCreate({\n      name: this.options.group,\n      axis: this.axis\n    })\n    this.context = Waypoint.Context.findOrCreateByElement(this.options.context)\n\n    if (Waypoint.offsetAliases[this.options.offset]) {\n      this.options.offset = Waypoint.offsetAliases[this.options.offset]\n    }\n    this.group.add(this)\n    this.context.add(this)\n    allWaypoints[this.key] = this\n    keyCounter += 1\n  }\n\n  /* Private */\n  Waypoint.prototype.queueTrigger = function(direction) {\n    this.group.queueTrigger(this, direction)\n  }\n\n  /* Private */\n  Waypoint.prototype.trigger = function(args) {\n    if (!this.enabled) {\n      return\n    }\n    if (this.callback) {\n      this.callback.apply(this, args)\n    }\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/destroy */\n  Waypoint.prototype.destroy = function() {\n    this.context.remove(this)\n    this.group.remove(this)\n    delete allWaypoints[this.key]\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/disable */\n  Waypoint.prototype.disable = function() {\n    this.enabled = false\n    return this\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/enable */\n  Waypoint.prototype.enable = function() {\n    this.context.refresh()\n    this.enabled = true\n    return this\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/next */\n  Waypoint.prototype.next = function() {\n    return this.group.next(this)\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/previous */\n  Waypoint.prototype.previous = function() {\n    return this.group.previous(this)\n  }\n\n  /* Private */\n  Waypoint.invokeAll = function(method) {\n    var allWaypointsArray = []\n    for (var waypointKey in allWaypoints) {\n      allWaypointsArray.push(allWaypoints[waypointKey])\n    }\n    for (var i = 0, end = allWaypointsArray.length; i < end; i++) {\n      allWaypointsArray[i][method]()\n    }\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/destroy-all */\n  Waypoint.destroyAll = function() {\n    Waypoint.invokeAll('destroy')\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/disable-all */\n  Waypoint.disableAll = function() {\n    Waypoint.invokeAll('disable')\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/enable-all */\n  Waypoint.enableAll = function() {\n    Waypoint.Context.refreshAll()\n    for (var waypointKey in allWaypoints) {\n      allWaypoints[waypointKey].enabled = true\n    }\n    return this\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/refresh-all */\n  Waypoint.refreshAll = function() {\n    Waypoint.Context.refreshAll()\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/viewport-height */\n  Waypoint.viewportHeight = function() {\n    return window.innerHeight || document.documentElement.clientHeight\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/viewport-width */\n  Waypoint.viewportWidth = function() {\n    return document.documentElement.clientWidth\n  }\n\n  Waypoint.adapters = []\n\n  Waypoint.defaults = {\n    context: window,\n    continuous: true,\n    enabled: true,\n    group: 'default',\n    horizontal: false,\n    offset: 0\n  }\n\n  Waypoint.offsetAliases = {\n    'bottom-in-view': function() {\n      return this.context.innerHeight() - this.adapter.outerHeight()\n    },\n    'right-in-view': function() {\n      return this.context.innerWidth() - this.adapter.outerWidth()\n    }\n  }\n\n  window.Waypoint = Waypoint\n}())\n;(function() {\n  'use strict'\n\n  function requestAnimationFrameShim(callback) {\n    window.setTimeout(callback, 1000 / 60)\n  }\n\n  var keyCounter = 0\n  var contexts = {}\n  var Waypoint = window.Waypoint\n  var oldWindowLoad = window.onload\n\n  /* http://imakewebthings.com/waypoints/api/context */\n  function Context(element) {\n    this.element = element\n    this.Adapter = Waypoint.Adapter\n    this.adapter = new this.Adapter(element)\n    this.key = 'waypoint-context-' + keyCounter\n    this.didScroll = false\n    this.didResize = false\n    this.oldScroll = {\n      x: this.adapter.scrollLeft(),\n      y: this.adapter.scrollTop()\n    }\n    this.waypoints = {\n      vertical: {},\n      horizontal: {}\n    }\n\n    element.waypointContextKey = this.key\n    contexts[element.waypointContextKey] = this\n    keyCounter += 1\n    if (!Waypoint.windowContext) {\n      Waypoint.windowContext = true\n      Waypoint.windowContext = new Context(window)\n    }\n\n    this.createThrottledScrollHandler()\n    this.createThrottledResizeHandler()\n  }\n\n  /* Private */\n  Context.prototype.add = function(waypoint) {\n    var axis = waypoint.options.horizontal ? 'horizontal' : 'vertical'\n    this.waypoints[axis][waypoint.key] = waypoint\n    this.refresh()\n  }\n\n  /* Private */\n  Context.prototype.checkEmpty = function() {\n    var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal)\n    var verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical)\n    var isWindow = this.element == this.element.window\n    if (horizontalEmpty && verticalEmpty && !isWindow) {\n      this.adapter.off('.waypoints')\n      delete contexts[this.key]\n    }\n  }\n\n  /* Private */\n  Context.prototype.createThrottledResizeHandler = function() {\n    var self = this\n\n    function resizeHandler() {\n      self.handleResize()\n      self.didResize = false\n    }\n\n    this.adapter.on('resize.waypoints', function() {\n      if (!self.didResize) {\n        self.didResize = true\n        Waypoint.requestAnimationFrame(resizeHandler)\n      }\n    })\n  }\n\n  /* Private */\n  Context.prototype.createThrottledScrollHandler = function() {\n    var self = this\n    function scrollHandler() {\n      self.handleScroll()\n      self.didScroll = false\n    }\n\n    this.adapter.on('scroll.waypoints', function() {\n      if (!self.didScroll || Waypoint.isTouch) {\n        self.didScroll = true\n        Waypoint.requestAnimationFrame(scrollHandler)\n      }\n    })\n  }\n\n  /* Private */\n  Context.prototype.handleResize = function() {\n    Waypoint.Context.refreshAll()\n  }\n\n  /* Private */\n  Context.prototype.handleScroll = function() {\n    var triggeredGroups = {}\n    var axes = {\n      horizontal: {\n        newScroll: this.adapter.scrollLeft(),\n        oldScroll: this.oldScroll.x,\n        forward: 'right',\n        backward: 'left'\n      },\n      vertical: {\n        newScroll: this.adapter.scrollTop(),\n        oldScroll: this.oldScroll.y,\n        forward: 'down',\n        backward: 'up'\n      }\n    }\n\n    for (var axisKey in axes) {\n      var axis = axes[axisKey]\n      var isForward = axis.newScroll > axis.oldScroll\n      var direction = isForward ? axis.forward : axis.backward\n\n      for (var waypointKey in this.waypoints[axisKey]) {\n        var waypoint = this.waypoints[axisKey][waypointKey]\n        if (waypoint.triggerPoint === null) {\n          continue\n        }\n        var wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint\n        var nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint\n        var crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint\n        var crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint\n        if (crossedForward || crossedBackward) {\n          waypoint.queueTrigger(direction)\n          triggeredGroups[waypoint.group.id] = waypoint.group\n        }\n      }\n    }\n\n    for (var groupKey in triggeredGroups) {\n      triggeredGroups[groupKey].flushTriggers()\n    }\n\n    this.oldScroll = {\n      x: axes.horizontal.newScroll,\n      y: axes.vertical.newScroll\n    }\n  }\n\n  /* Private */\n  Context.prototype.innerHeight = function() {\n    /*eslint-disable eqeqeq */\n    if (this.element == this.element.window) {\n      return Waypoint.viewportHeight()\n    }\n    /*eslint-enable eqeqeq */\n    return this.adapter.innerHeight()\n  }\n\n  /* Private */\n  Context.prototype.remove = function(waypoint) {\n    delete this.waypoints[waypoint.axis][waypoint.key]\n    this.checkEmpty()\n  }\n\n  /* Private */\n  Context.prototype.innerWidth = function() {\n    /*eslint-disable eqeqeq */\n    if (this.element == this.element.window) {\n      return Waypoint.viewportWidth()\n    }\n    /*eslint-enable eqeqeq */\n    return this.adapter.innerWidth()\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/context-destroy */\n  Context.prototype.destroy = function() {\n    var allWaypoints = []\n    for (var axis in this.waypoints) {\n      for (var waypointKey in this.waypoints[axis]) {\n        allWaypoints.push(this.waypoints[axis][waypointKey])\n      }\n    }\n    for (var i = 0, end = allWaypoints.length; i < end; i++) {\n      allWaypoints[i].destroy()\n    }\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/context-refresh */\n  Context.prototype.refresh = function() {\n    /*eslint-disable eqeqeq */\n    var isWindow = this.element == this.element.window\n    /*eslint-enable eqeqeq */\n    var contextOffset = isWindow ? undefined : this.adapter.offset()\n    var triggeredGroups = {}\n    var axes\n\n    this.handleScroll()\n    axes = {\n      horizontal: {\n        contextOffset: isWindow ? 0 : contextOffset.left,\n        contextScroll: isWindow ? 0 : this.oldScroll.x,\n        contextDimension: this.innerWidth(),\n        oldScroll: this.oldScroll.x,\n        forward: 'right',\n        backward: 'left',\n        offsetProp: 'left'\n      },\n      vertical: {\n        contextOffset: isWindow ? 0 : contextOffset.top,\n        contextScroll: isWindow ? 0 : this.oldScroll.y,\n        contextDimension: this.innerHeight(),\n        oldScroll: this.oldScroll.y,\n        forward: 'down',\n        backward: 'up',\n        offsetProp: 'top'\n      }\n    }\n\n    for (var axisKey in axes) {\n      var axis = axes[axisKey]\n      for (var waypointKey in this.waypoints[axisKey]) {\n        var waypoint = this.waypoints[axisKey][waypointKey]\n        var adjustment = waypoint.options.offset\n        var oldTriggerPoint = waypoint.triggerPoint\n        var elementOffset = 0\n        var freshWaypoint = oldTriggerPoint == null\n        var contextModifier, wasBeforeScroll, nowAfterScroll\n        var triggeredBackward, triggeredForward\n\n        if (waypoint.element !== waypoint.element.window) {\n          elementOffset = waypoint.adapter.offset()[axis.offsetProp]\n        }\n\n        if (typeof adjustment === 'function') {\n          adjustment = adjustment.apply(waypoint)\n        }\n        else if (typeof adjustment === 'string') {\n          adjustment = parseFloat(adjustment)\n          if (waypoint.options.offset.indexOf('%') > - 1) {\n            adjustment = Math.ceil(axis.contextDimension * adjustment / 100)\n          }\n        }\n\n        contextModifier = axis.contextScroll - axis.contextOffset\n        waypoint.triggerPoint = Math.floor(elementOffset + contextModifier - adjustment)\n        wasBeforeScroll = oldTriggerPoint < axis.oldScroll\n        nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll\n        triggeredBackward = wasBeforeScroll && nowAfterScroll\n        triggeredForward = !wasBeforeScroll && !nowAfterScroll\n\n        if (!freshWaypoint && triggeredBackward) {\n          waypoint.queueTrigger(axis.backward)\n          triggeredGroups[waypoint.group.id] = waypoint.group\n        }\n        else if (!freshWaypoint && triggeredForward) {\n          waypoint.queueTrigger(axis.forward)\n          triggeredGroups[waypoint.group.id] = waypoint.group\n        }\n        else if (freshWaypoint && axis.oldScroll >= waypoint.triggerPoint) {\n          waypoint.queueTrigger(axis.forward)\n          triggeredGroups[waypoint.group.id] = waypoint.group\n        }\n      }\n    }\n\n    Waypoint.requestAnimationFrame(function() {\n      for (var groupKey in triggeredGroups) {\n        triggeredGroups[groupKey].flushTriggers()\n      }\n    })\n\n    return this\n  }\n\n  /* Private */\n  Context.findOrCreateByElement = function(element) {\n    return Context.findByElement(element) || new Context(element)\n  }\n\n  /* Private */\n  Context.refreshAll = function() {\n    for (var contextId in contexts) {\n      contexts[contextId].refresh()\n    }\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/context-find-by-element */\n  Context.findByElement = function(element) {\n    return contexts[element.waypointContextKey]\n  }\n\n  window.onload = function() {\n    if (oldWindowLoad) {\n      oldWindowLoad()\n    }\n    Context.refreshAll()\n  }\n\n\n  Waypoint.requestAnimationFrame = function(callback) {\n    var requestFn = window.requestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      requestAnimationFrameShim\n    requestFn.call(window, callback)\n  }\n  Waypoint.Context = Context\n}())\n;(function() {\n  'use strict'\n\n  function byTriggerPoint(a, b) {\n    return a.triggerPoint - b.triggerPoint\n  }\n\n  function byReverseTriggerPoint(a, b) {\n    return b.triggerPoint - a.triggerPoint\n  }\n\n  var groups = {\n    vertical: {},\n    horizontal: {}\n  }\n  var Waypoint = window.Waypoint\n\n  /* http://imakewebthings.com/waypoints/api/group */\n  function Group(options) {\n    this.name = options.name\n    this.axis = options.axis\n    this.id = this.name + '-' + this.axis\n    this.waypoints = []\n    this.clearTriggerQueues()\n    groups[this.axis][this.name] = this\n  }\n\n  /* Private */\n  Group.prototype.add = function(waypoint) {\n    this.waypoints.push(waypoint)\n  }\n\n  /* Private */\n  Group.prototype.clearTriggerQueues = function() {\n    this.triggerQueues = {\n      up: [],\n      down: [],\n      left: [],\n      right: []\n    }\n  }\n\n  /* Private */\n  Group.prototype.flushTriggers = function() {\n    for (var direction in this.triggerQueues) {\n      var waypoints = this.triggerQueues[direction]\n      var reverse = direction === 'up' || direction === 'left'\n      waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint)\n      for (var i = 0, end = waypoints.length; i < end; i += 1) {\n        var waypoint = waypoints[i]\n        if (waypoint.options.continuous || i === waypoints.length - 1) {\n          waypoint.trigger([direction])\n        }\n      }\n    }\n    this.clearTriggerQueues()\n  }\n\n  /* Private */\n  Group.prototype.next = function(waypoint) {\n    this.waypoints.sort(byTriggerPoint)\n    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)\n    var isLast = index === this.waypoints.length - 1\n    return isLast ? null : this.waypoints[index + 1]\n  }\n\n  /* Private */\n  Group.prototype.previous = function(waypoint) {\n    this.waypoints.sort(byTriggerPoint)\n    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)\n    return index ? this.waypoints[index - 1] : null\n  }\n\n  /* Private */\n  Group.prototype.queueTrigger = function(waypoint, direction) {\n    this.triggerQueues[direction].push(waypoint)\n  }\n\n  /* Private */\n  Group.prototype.remove = function(waypoint) {\n    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)\n    if (index > -1) {\n      this.waypoints.splice(index, 1)\n    }\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/first */\n  Group.prototype.first = function() {\n    return this.waypoints[0]\n  }\n\n  /* Public */\n  /* http://imakewebthings.com/waypoints/api/last */\n  Group.prototype.last = function() {\n    return this.waypoints[this.waypoints.length - 1]\n  }\n\n  /* Private */\n  Group.findOrCreate = function(options) {\n    return groups[options.axis][options.name] || new Group(options)\n  }\n\n  Waypoint.Group = Group\n}())\n;(function() {\n  'use strict'\n\n  var $ = window.jQuery\n  var Waypoint = window.Waypoint\n\n  function JQueryAdapter(element) {\n    this.$element = $(element)\n  }\n\n  $.each([\n    'innerHeight',\n    'innerWidth',\n    'off',\n    'offset',\n    'on',\n    'outerHeight',\n    'outerWidth',\n    'scrollLeft',\n    'scrollTop'\n  ], function(i, method) {\n    JQueryAdapter.prototype[method] = function() {\n      var args = Array.prototype.slice.call(arguments)\n      return this.$element[method].apply(this.$element, args)\n    }\n  })\n\n  $.each([\n    'extend',\n    'inArray',\n    'isEmptyObject'\n  ], function(i, method) {\n    JQueryAdapter[method] = $[method]\n  })\n\n  Waypoint.adapters.push({\n    name: 'jquery',\n    Adapter: JQueryAdapter\n  })\n  Waypoint.Adapter = JQueryAdapter\n}())\n;(function() {\n  'use strict'\n\n  var Waypoint = window.Waypoint\n\n  function createExtension(framework) {\n    return function() {\n      var waypoints = []\n      var overrides = arguments[0]\n\n      if (framework.isFunction(arguments[0])) {\n        overrides = framework.extend({}, arguments[1])\n        overrides.handler = arguments[0]\n      }\n\n      this.each(function() {\n        var options = framework.extend({}, overrides, {\n          element: this\n        })\n        if (typeof options.context === 'string') {\n          options.context = framework(this).closest(options.context)[0]\n        }\n        waypoints.push(new Waypoint(options))\n      })\n\n      return waypoints\n    }\n  }\n\n  if (window.jQuery) {\n    window.jQuery.fn.waypoint = createExtension(window.jQuery)\n  }\n  if (window.Zepto) {\n    window.Zepto.fn.waypoint = createExtension(window.Zepto)\n  }\n}())\n;\n})"}
}});
